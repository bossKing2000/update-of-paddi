generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id          String   @id @default(uuid())
  username    String?  @unique
  name        String
  email       String   @unique
  phoneNumber String?
  password    String?
  avatarUrl   String?
  preferences String[]
  bio         String?
  role        Role?
  brandName   String?
  brandLogo   String?
  googleId    String?  @unique

  // Relations
  products              Product[]           @relation("VendorProducts")
  vendorReviewsReceived VendorReview[]      @relation("VendorReviews")
  vendorReviewsGiven    VendorReview[]      @relation("CustomerVendorReviews")
  productReviewsGiven   ProductReview[]     @relation("CustomerProductReviews")
  customerOrders        Order[]             @relation("CustomerOrders")
  vendorOrders          Order[]             @relation("VendorOrders")
  vendorRepliesSent     VendorReply[]       @relation("VendorReplies")
  reviewVotes           ReviewVote[]        @relation("UserReviewVotes")
  reviewReports         ReviewReport[]      @relation("UserReviewReports")
  notifications         Notification[]      @relation("UserNotifications")
  loginHistory          LoginHistory[]      @relation("UserLoginHistory")
  addresses             Address[]           @relation("UserAddresses")
  carts                 Cart[]              @relation("UserCarts")
  UserPaymentMethod     UserPaymentMethod[]
  deliveryPerson        DeliveryPerson?

  tokenVersion               Int                 @default(0)
  createdAt                  DateTime            @default(now())
  updatedAt                  DateTime            @updatedAt
  authProviders              String[]
  lastLoginAt                DateTime?
  loginMethod                String?
  isEmailVerified            Boolean             @default(false)
  emailVerificationToken     String?
  emailVerificationExpiresAt DateTime?
  passwordResetToken         PasswordResetToken? @relation("UserPasswordResetToken")
  payments                   Payment[]           @relation("UserPayments")
  RefundRequest              RefundRequest[]

  // âœ… Fixed Activity relations
  vendorActivities   Activity[] @relation("ActivityVendor")
  customerActivities Activity[] @relation("ActivityCustomer")

  // âœ… Vendor followers
  followers VendorFollower[] @relation("VendorFollowers") // people following this vendor
  following VendorFollower[] @relation("CustomerFollowing") // vendors this customer follows

  // Special Requests made by this user (as a customer)
  specialRequestsMade SpecialOrderRequest[] @relation("CustomerSpecialRequests")

  // Special Requests received by this user (as a vendor)
  specialRequestsReceived SpecialOrderRequest[] @relation("VendorSpecialRequests")

  // Special Offers sent by this vendor
  specialOffersSent SpecialOrderOffer[] @relation("VendorSpecialOffers")
}

// 

model Address {
  id        String   @id @default(uuid())
  userId    String
  label     String
  street    String
  city      String
  state     String?
  country   String
  zipCode   String?
  landmark  String? // e.g. "Near Zenith Bank"
  latitude  Float?
  longitude Float?
  isDefault Boolean  @default(false)
  createdAt DateTime @default(now())

  user   User    @relation("UserAddresses", fields: [userId], references: [id], onDelete: Cascade)
  orders Order[]

  @@index([latitude, longitude])
  @@index([isDefault])
}

model Product {
  id          String   @id @default(uuid())
  name        String
  description String
  price       Float
  archived    Boolean  @default(false) // just like a delete function
  category    Category

  images              String[]
  thumbnail           String?   // ðŸ‘ˆ ADD THIS
  video               String[]
  vendorId            String
  vendor              User                  @relation(name: "VendorProducts", fields: [vendorId], references: [id], onDelete: Cascade)
  reviews             ProductReview[]       @relation("ProductReviews")
  orders              Order[]               @relation("ProductOrders")
  orderItems          OrderItem[]
  options             ProductOption[]       @relation("ProductOptions")
  averageRating       Float?                @default(0)
  reviewCount         Int                   @default(0)
  createdAt           DateTime              @default(now())
  updatedAt           DateTime              @updatedAt
  CartItem            CartItem[]
  totalViews          Int                   @default(0) // all-time total views
  popularityScore     Float                 @default(0)
  popularityUpdatedAt DateTime? // <-- add this line
  popularityPercent   Float                 @default(0) // âœ… new field
  isNew               Boolean               @default(false) // âœ… Make sure this is here
  // Special requests associated with this product
  specialRequests     SpecialOrderRequest[] @relation("ProductSpecialRequests")

  // ðŸ•’ Default grace control (fallback)
  // graceEnabled        Boolean         @default(true)
  // graceMinutes        Int?            @default(10)

  // ðŸŸ¢ Live scheduling (mirrored for performance)
  isLive    Boolean   @default(false) // current live state
  liveUntil DateTime? // takeDownAt mirror

  // ðŸ”— Full schedule relation
  productSchedule ProductSchedule?

  // Essential indexes (keep these)
  @@index([name], map: "product_name_idx") // Speeds up search suggestions
  @@index([category], map: "product_category_idx") // Faster category filtering
  @@index([vendorId], map: "product_vendor_idx") // Helps with vendor-specific queries
  @@index([archived])
  @@index([createdAt])
  @@index([price])
  @@index([isLive])
}

model ProductSchedule {
  id        String  @id @default(uuid())
  productId String  @unique
  product   Product @relation(fields: [productId], references: [id])

  goLiveAt   DateTime?
  takeDownAt DateTime?
  isLive     Boolean   @default(false)

  // ðŸ§­ Grace control for this session
  graceMinutes       Int?    @default(0)
  autoGraceEnabled   Boolean @default(false)
  manualGraceEnabled Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ProductOption {
  id              String            @id @default(uuid())
  productId       String
  name            String
  price           Float
  product         Product           @relation("ProductOptions", fields: [productId], references: [id], onDelete: Cascade)
  OrderItemOption OrderItemOption[]
  CartItemOption  CartItemOption[]
}

model Order {
  id               String      @id @default(uuid())
  customerId       String
  vendorId         String
  addressId        String?
  basePrice        Float
  extraCharge      Float       @default(0)
  totalPrice       Float
  vendorNote       String?
  customerApproval Boolean     @default(false)
  status           OrderStatus @default(PENDING)
  createdAt        DateTime    @default(now())
  updatedAt        DateTime    @default(now()) @updatedAt // âœ… add default

  customer    User                 @relation("CustomerOrders", fields: [customerId], references: [id], onDelete: Cascade)
  vendor      User                 @relation("VendorOrders", fields: [vendorId], references: [id], onDelete: Cascade)
  address     Address?             @relation(fields: [addressId], references: [id], onDelete: SetNull)
  items       OrderItem[]
  payments    Payment[]            @relation("OrderPayments")
  Product     Product[]            @relation("ProductOrders")
  assignments DeliveryAssignment[]
  earnings    DeliveryEarning[]

  paymentInitiatedAt DateTime? // you already had this; kept for compatibility
  paymentStartedAt   DateTime? // optional clearer alias if you want to set it explicitly

  // paymentExpiresAt   DateTime? // Track payment expiration time
  paidAt        DateTime? // âœ… add this
  paymentStatus PaymentStatus? @default(PENDING)

  cancelledAt         DateTime?
  cancellationReason  String? // "PAYMENT_EXPIRED" | "USER_CANCELLED" | "VENDOR_REJECTED"
  protectedUntil      DateTime? // â† new field
  paymentGraceMinutes Int?                @default(15)
  Activity            Activity[]
  DeliveryBroadcast   DeliveryBroadcast[]
  // @@index([paymentExpiresAt])

  @@index([customerId, createdAt])
  @@index([vendorId, createdAt])
  @@index([status])
}

model OrderItem {
  id        String            @id @default(uuid())
  orderId   String
  productId String
  quantity  Int
  unitPrice Float
  subtotal  Float
  createdAt DateTime          @default(now())
  // specialRequest String? // NEW FIELD
  order     Order             @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product   Product           @relation(fields: [productId], references: [id], onDelete: Cascade)
  options   OrderItemOption[]
}

model OrderItemOption {
  id            String        @id @default(uuid())
  optionId      String
  name          String
  price         Float
  orderItemId   String
  orderItem     OrderItem     @relation(fields: [orderItemId], references: [id], onDelete: Cascade)
  productOption ProductOption @relation(fields: [optionId], references: [id], onDelete: Cascade)

  @@index([orderItemId])
  @@index([optionId])
}

model ProductReview {
  id               String   @id @default(uuid())
  productId        String
  customerId       String
  rating           Int
  comment          String?
  images           String[]
  createdAt        DateTime @default(now())
  verifiedPurchase Boolean  @default(false)

  product  Product        @relation("ProductReviews", fields: [productId], references: [id], onDelete: Cascade)
  customer User           @relation("CustomerProductReviews", fields: [customerId], references: [id], onDelete: Cascade)
  reply    VendorReply?
  votes    ReviewVote[]
  reports  ReviewReport[]

  @@index([productId, createdAt])
  @@index([customerId])
}

model VendorReply {
  id        String   @id @default(uuid())
  reviewId  String   @unique
  vendorId  String
  message   String
  createdAt DateTime @default(now())

  review ProductReview @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  vendor User          @relation("VendorReplies", fields: [vendorId], references: [id], onDelete: Cascade)
}

model ReviewVote {
  id        String   @id @default(uuid())
  reviewId  String
  userId    String
  isHelpful Boolean
  createdAt DateTime @default(now())

  review ProductReview @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  user   User          @relation("UserReviewVotes", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([reviewId, userId])
}

model ReviewReport {
  id        String   @id @default(uuid())
  reviewId  String
  userId    String
  reason    String
  createdAt DateTime @default(now())

  review ProductReview @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  user   User          @relation("UserReviewReports", fields: [userId], references: [id], onDelete: Cascade)
}

model VendorReview {
  id         String   @id @default(uuid())
  vendorId   String
  customerId String
  rating     Int
  comment    String?
  createdAt  DateTime @default(now())

  vendor   User @relation("VendorReviews", fields: [vendorId], references: [id], onDelete: Cascade)
  customer User @relation("CustomerVendorReviews", fields: [customerId], references: [id], onDelete: Cascade)
}

model Notification {
  id        String   @id @default(uuid())
  userId    String
  title     String
  message   String
  type      String
  metadata  Json?
  read      Boolean  @default(false)
  createdAt DateTime @default(now())

  user User @relation("UserNotifications", fields: [userId], references: [id], onDelete: Cascade)
}

model LoginHistory {
  id         String   @id @default(uuid())
  userId     String
  method     String
  deviceId   String? // optional fingerprint
  location   String? // e.g. "Lagos, Nigeria"
  ip         String?
  userAgent  String?
  geoCity    String? // <-- add
  geoRegion  String? // <-- add
  geoCountry String? // <-- add
  createdAt  DateTime @default(now())

  user User @relation("UserLoginHistory", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
}

model PasswordResetToken {
  userId    String   @id
  token     String
  expiresAt DateTime

  user User @relation("UserPasswordResetToken", fields: [userId], references: [id], onDelete: Cascade)
}

model Payment {
  id           String   @id @default(cuid())
  userId       String
  orderId      String
  amount       Int //mount in kobo, e.g. 600000 = â‚¦6,000.00 âœ…
  reference    String   @unique
  status       String
  paystackData Json? // âœ… Add this
  channel      String? // âœ… Optional
  ipAddress    String   @default("unknown") // âœ… fraud logs
  userAgent    String   @default("unknown") // âœ… fraud logs
  deviceId     String? // optional
  geoCity      String? // <-- add this
  geoCountry   String? // <-- add this
  createdAt    DateTime @default(now())
  updatedAt    DateTime @default(now()) @updatedAt // âœ… add default
  metadata     Json? // âœ… add this line

  user  User  @relation("UserPayments", fields: [userId], references: [id])
  order Order @relation("OrderPayments", fields: [orderId], references: [id])

  // More explicit payment timestamps to support cleanup/cron logic
  startedAt   DateTime? // when payment was initiated (same moment you create Payment record)
  completedAt DateTime? // when the gateway/webhook confirmed success
  expiresAt   DateTime? // kobo amount must be paid before this time

  Receipt Receipt[]

  @@index([userId])
  @@index([orderId])
  @@index([status])
}

enum Role {
  CUSTOMER
  VENDOR
  ADMIN
  DELIVERY
}

enum Category {
  BREAKFAST
  LUNCH
  DINNER
  DESSERT
  DRINK
}

enum OrderStatus {
  PENDING // customer placed order
  WAITING_VENDOR_CONFIRMATION
  WAITING_CUSTOMER_APPROVAL
  AWAITING_PAYMENT
  PAYMENT_CONFIRMED
  COOKING
  READY_FOR_PICKUP // optional if you want vendor to mark ready
  OUT_FOR_DELIVERY // order handed over to driver
  COMPLETED // customer received (final)
  CANCELLED // cancelled before/after payment
  FAILED_DELIVERY // if you want to track failed attempts
  PAYMENT_EXPIRED
  CANCELLED_UNPAID
}

enum PaymentStatus {
  PENDING
  SUCCESS
  FAILED
  EXPIRED
  REFUNDED
  INITIATED // user clicked "Pay Now", payment flow started
}

model AuditLog {
  id         String   @id @default(cuid())
  userId     String?
  action     String
  ipAddress  String
  userAgent  String
  deviceId   String?
  geoCity    String? // <-- add
  geoRegion  String? // <-- add
  geoCountry String? // <-- add
  details    Json?
  path       String
  metadata   Json?
  createdAt  DateTime @default(now())
}

model RefundRequest {
  id         String       @id @default(uuid())
  user       User         @relation(fields: [userId], references: [id])
  userId     String
  paymentRef String // Paystack reference
  reason     String
  status     RefundStatus @default(PENDING)
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt
}

enum RefundStatus {
  PENDING
  APPROVED
  REJECTED
  COMPLETED
}

model Cart {
  id         String   @id @default(uuid())
  customerId String
  basePrice  Float    @default(0)
  totalPrice Float    @default(0)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relations
  customer User       @relation("UserCarts", fields: [customerId], references: [id], onDelete: Cascade)
  items    CartItem[]

  // Ensure all items are from same vendor
  @@index([customerId])
}

model CartItem {
  id        String @id @default(uuid())
  cartId    String
  productId String
  quantity  Int
  unitPrice Float
  subtotal  Float

  cart           Cart             @relation(fields: [cartId], references: [id], onDelete: Cascade)
  product        Product          @relation(fields: [productId], references: [id], onDelete: Cascade)
  specialRequest String? // âœ… keep the note for this product
  options        CartItemOption[]
}

model CartItemOption {
  id              String @id @default(uuid())
  cartItemId      String
  productOptionId String
  name            String
  price           Float

  // Relations
  cartItem      CartItem      @relation(fields: [cartItemId], references: [id], onDelete: Cascade)
  productOption ProductOption @relation(fields: [productOptionId], references: [id], onDelete: Cascade)

  @@index([cartItemId])
  @@index([productOptionId])
}

model UserPaymentMethod {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  cardToken String   @unique
  last4     String
  brand     String // visa, mastercard, etc
  isDefault Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model DeliveryPerson {
  id              String               @id @default(uuid())
  userId          String               @unique
  user            User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  vehicleType     String?
  licensePlate    String?
  status          String               @default("ACTIVE")
  rating          Float                @default(0)
  totalDeliveries Int                  @default(0)
  isOnline        Boolean              @default(false)
  latitude        Float?
  longitude       Float?
  lastSeenAt      DateTime?
  assignedOrders  DeliveryAssignment[]
  earnings        DeliveryEarning[]
  walletBalance   Float                @default(0)
  createdAt       DateTime             @default(now())
  updatedAt       DateTime             @updatedAt

  DriverLocationLog DriverLocationLog[]

  Activity Activity[]

  @@index([userId])
}

model DeliveryAssignment {
  id               String         @id @default(uuid())
  orderId          String
  deliveryPersonId String
  status           DeliveryStatus @default(ASSIGNED)
  assignedAt       DateTime       @default(now())
  acceptedAt       DateTime?
  startedAt        DateTime?
  completedAt      DateTime?
  declinedAt       DateTime?
  timeoutSeconds   Int            @default(30)
  attempts         Int            @default(0)
  batchId          String? // For grouping multiple orders

  order          Order          @relation(fields: [orderId], references: [id], onDelete: Cascade)
  deliveryPerson DeliveryPerson @relation(fields: [deliveryPersonId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([deliveryPersonId])
  @@index([orderId])
}

model DeliveryEarning {
  id               String   @id @default(uuid())
  deliveryPersonId String
  orderId          String
  baseFee          Float
  distanceFee      Float
  tip              Float    @default(0)
  deductions       Float    @default(0)
  totalEarned      Float
  createdAt        DateTime @default(now())

  deliveryPerson DeliveryPerson @relation(fields: [deliveryPersonId], references: [id])
  order          Order          @relation(fields: [orderId], references: [id])
}

enum DeliveryStatus {
  ASSIGNED // system auto-assigned to a driver
  ACCEPTED // driver accepted
  DECLINED // driver declined
  PICKED_UP // driver has collected order from vendor
  EN_ROUTE // on the way to customer
  DELIVERED // successfully delivered to customer
  FAILED // driver couldnâ€™t deliver
  RETURNED // item returned to vendor
  CANCELLED // cancelled by system/vendor/customer
}

model DriverLocationLog {
  id        String   @id @default(cuid())
  driverId  String
  latitude  Float
  longitude Float
  timestamp DateTime @default(now())

  driver DeliveryPerson @relation(fields: [driverId], references: [id], onDelete: Cascade)
}

enum ActivityType {
  ORDER_CREATED
  PAYMENT_SUCCESS
  NEW_PAID_ORDER
  REFUND_REQUESTED
  REFUND_ISSUED
  REVIEW_POSTED
  DELIVERY_ASSIGNED
  DELIVERY_COMPLETED
  ORDER_EXPIRED
  ORDER_CANCELLED
  GENERAL
}

model Activity {
  id String @id @default(uuid())

  // Optional relationships
  orderId    String?
  vendorId   String?
  customerId String?
  deliveryId String?

  // Core fields
  type      ActivityType
  title     String
  message   String
  meta      Json?
  createdAt DateTime     @default(now())

  // âœ… Relations
  order    Order?          @relation(fields: [orderId], references: [id], onDelete: Cascade)
  vendor   User?           @relation("ActivityVendor", fields: [vendorId], references: [id], onDelete: Cascade)
  customer User?           @relation("ActivityCustomer", fields: [customerId], references: [id], onDelete: Cascade)
  delivery DeliveryPerson? @relation(fields: [deliveryId], references: [id], onDelete: Cascade)

  @@index([orderId])
  @@index([vendorId])
  @@index([customerId])
  @@index([type])
}

enum BroadcastStatus {
  PENDING
  ACCEPTED
  EXPIRED
}

model DeliveryBroadcast {
  id               String   @id @default(cuid())
  orderId          String
  driverIds        String[] // Array of driver UUIDs
  acceptedDriverId String?
  status           String // "PENDING" | "ACCEPTED" | "EXPIRED"
  expiresAt        DateTime
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  order Order @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([orderId])
  @@index([status])
}

model WebhookEvent {
  id          String    @id @default(cuid())
  reference   String
  event       String
  payload     Json
  status      String    @default("pending") // pending, processing, done, failed
  createdAt   DateTime  @default(now())
  processedAt DateTime?

  @@unique([reference, event])
}

model Receipt {
  id        String   @id @default(cuid())
  payment   Payment  @relation(fields: [paymentId], references: [id])
  paymentId String
  pdfUrl    String? // optional, if generating PDF
  createdAt DateTime @default(now())
}

model VendorFollower {
  id         String   @id @default(uuid())
  vendorId   String
  customerId String
  createdAt  DateTime @default(now())

  vendor   User @relation("VendorFollowers", fields: [vendorId], references: [id], onDelete: Cascade)
  customer User @relation("CustomerFollowing", fields: [customerId], references: [id], onDelete: Cascade)

  @@unique([vendorId, customerId])
  @@index([vendorId])
  @@index([customerId])
}

model SpecialOrderRequest {
  id         String   @id @default(uuid())
  customerId String
  vendorId   String?       // optional, because request may exist before a vendor responds
  productId  String
  quantity   Int
  message    String        // you can use this as "details"
  status     String   @default("PENDING")
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  customer User    @relation("CustomerSpecialRequests", fields: [customerId], references: [id], onDelete: Cascade)
  vendor   User?   @relation("VendorSpecialRequests", fields: [vendorId], references: [id], onDelete: Cascade)
  product  Product @relation("ProductSpecialRequests", fields: [productId], references: [id], onDelete: Cascade)

  offers SpecialOrderOffer[]
}


model SpecialOrderOffer {
  id        String   @id @default(uuid())
  requestId String
  vendorId  String
  price     Float
  message   String?
  status    String   @default("PENDING")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  request SpecialOrderRequest @relation(fields: [requestId], references: [id], onDelete: Cascade)
  vendor  User                @relation("VendorSpecialOffers", fields: [vendorId], references: [id], onDelete: Cascade)
}

enum RequestStatus {
  PENDING // waiting for vendor offers
  OFFER_MADE // vendor has made at least one offer
  ACCEPTED // customer accepted an offer
  REJECTED // customer rejected all offers
  CANCELLED // customer cancelled request
}

enum OfferStatus {
  PENDING // vendor submitted, customer has not responded
  ACCEPTED // customer accepted this offer
  REJECTED // customer rejected
  EXPIRED // offer timed out
}
