
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Address
 * 
 */
export type Address = $Result.DefaultSelection<Prisma.$AddressPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model ProductSchedule
 * 
 */
export type ProductSchedule = $Result.DefaultSelection<Prisma.$ProductSchedulePayload>
/**
 * Model ProductOption
 * 
 */
export type ProductOption = $Result.DefaultSelection<Prisma.$ProductOptionPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model OrderItemOption
 * 
 */
export type OrderItemOption = $Result.DefaultSelection<Prisma.$OrderItemOptionPayload>
/**
 * Model ProductReview
 * 
 */
export type ProductReview = $Result.DefaultSelection<Prisma.$ProductReviewPayload>
/**
 * Model VendorReply
 * 
 */
export type VendorReply = $Result.DefaultSelection<Prisma.$VendorReplyPayload>
/**
 * Model ReviewVote
 * 
 */
export type ReviewVote = $Result.DefaultSelection<Prisma.$ReviewVotePayload>
/**
 * Model ReviewReport
 * 
 */
export type ReviewReport = $Result.DefaultSelection<Prisma.$ReviewReportPayload>
/**
 * Model VendorReview
 * 
 */
export type VendorReview = $Result.DefaultSelection<Prisma.$VendorReviewPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model LoginHistory
 * 
 */
export type LoginHistory = $Result.DefaultSelection<Prisma.$LoginHistoryPayload>
/**
 * Model PasswordResetToken
 * 
 */
export type PasswordResetToken = $Result.DefaultSelection<Prisma.$PasswordResetTokenPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model RefundRequest
 * 
 */
export type RefundRequest = $Result.DefaultSelection<Prisma.$RefundRequestPayload>
/**
 * Model Cart
 * 
 */
export type Cart = $Result.DefaultSelection<Prisma.$CartPayload>
/**
 * Model CartItem
 * 
 */
export type CartItem = $Result.DefaultSelection<Prisma.$CartItemPayload>
/**
 * Model CartItemOption
 * 
 */
export type CartItemOption = $Result.DefaultSelection<Prisma.$CartItemOptionPayload>
/**
 * Model UserPaymentMethod
 * 
 */
export type UserPaymentMethod = $Result.DefaultSelection<Prisma.$UserPaymentMethodPayload>
/**
 * Model DeliveryPerson
 * 
 */
export type DeliveryPerson = $Result.DefaultSelection<Prisma.$DeliveryPersonPayload>
/**
 * Model DeliveryAssignment
 * 
 */
export type DeliveryAssignment = $Result.DefaultSelection<Prisma.$DeliveryAssignmentPayload>
/**
 * Model DeliveryEarning
 * 
 */
export type DeliveryEarning = $Result.DefaultSelection<Prisma.$DeliveryEarningPayload>
/**
 * Model DriverLocationLog
 * 
 */
export type DriverLocationLog = $Result.DefaultSelection<Prisma.$DriverLocationLogPayload>
/**
 * Model Activity
 * 
 */
export type Activity = $Result.DefaultSelection<Prisma.$ActivityPayload>
/**
 * Model DeliveryBroadcast
 * 
 */
export type DeliveryBroadcast = $Result.DefaultSelection<Prisma.$DeliveryBroadcastPayload>
/**
 * Model WebhookEvent
 * 
 */
export type WebhookEvent = $Result.DefaultSelection<Prisma.$WebhookEventPayload>
/**
 * Model Receipt
 * 
 */
export type Receipt = $Result.DefaultSelection<Prisma.$ReceiptPayload>
/**
 * Model VendorFollower
 * 
 */
export type VendorFollower = $Result.DefaultSelection<Prisma.$VendorFollowerPayload>
/**
 * Model SpecialOrderRequest
 * 
 */
export type SpecialOrderRequest = $Result.DefaultSelection<Prisma.$SpecialOrderRequestPayload>
/**
 * Model SpecialOrderOffer
 * 
 */
export type SpecialOrderOffer = $Result.DefaultSelection<Prisma.$SpecialOrderOfferPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  CUSTOMER: 'CUSTOMER',
  VENDOR: 'VENDOR',
  ADMIN: 'ADMIN',
  DELIVERY: 'DELIVERY'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Category: {
  BREAKFAST: 'BREAKFAST',
  LUNCH: 'LUNCH',
  DINNER: 'DINNER',
  DESSERT: 'DESSERT',
  DRINK: 'DRINK'
};

export type Category = (typeof Category)[keyof typeof Category]


export const OrderStatus: {
  PENDING: 'PENDING',
  WAITING_VENDOR_CONFIRMATION: 'WAITING_VENDOR_CONFIRMATION',
  WAITING_CUSTOMER_APPROVAL: 'WAITING_CUSTOMER_APPROVAL',
  AWAITING_PAYMENT: 'AWAITING_PAYMENT',
  PAYMENT_CONFIRMED: 'PAYMENT_CONFIRMED',
  COOKING: 'COOKING',
  READY_FOR_PICKUP: 'READY_FOR_PICKUP',
  OUT_FOR_DELIVERY: 'OUT_FOR_DELIVERY',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  FAILED_DELIVERY: 'FAILED_DELIVERY',
  PAYMENT_EXPIRED: 'PAYMENT_EXPIRED',
  CANCELLED_UNPAID: 'CANCELLED_UNPAID'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const PaymentStatus: {
  PENDING: 'PENDING',
  SUCCESS: 'SUCCESS',
  FAILED: 'FAILED',
  EXPIRED: 'EXPIRED',
  REFUNDED: 'REFUNDED',
  INITIATED: 'INITIATED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const RefundStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  COMPLETED: 'COMPLETED'
};

export type RefundStatus = (typeof RefundStatus)[keyof typeof RefundStatus]


export const DeliveryStatus: {
  ASSIGNED: 'ASSIGNED',
  ACCEPTED: 'ACCEPTED',
  DECLINED: 'DECLINED',
  PICKED_UP: 'PICKED_UP',
  EN_ROUTE: 'EN_ROUTE',
  DELIVERED: 'DELIVERED',
  FAILED: 'FAILED',
  RETURNED: 'RETURNED',
  CANCELLED: 'CANCELLED'
};

export type DeliveryStatus = (typeof DeliveryStatus)[keyof typeof DeliveryStatus]


export const ActivityType: {
  ORDER_CREATED: 'ORDER_CREATED',
  PAYMENT_SUCCESS: 'PAYMENT_SUCCESS',
  NEW_PAID_ORDER: 'NEW_PAID_ORDER',
  REFUND_REQUESTED: 'REFUND_REQUESTED',
  REFUND_ISSUED: 'REFUND_ISSUED',
  REVIEW_POSTED: 'REVIEW_POSTED',
  DELIVERY_ASSIGNED: 'DELIVERY_ASSIGNED',
  DELIVERY_COMPLETED: 'DELIVERY_COMPLETED',
  ORDER_EXPIRED: 'ORDER_EXPIRED',
  ORDER_CANCELLED: 'ORDER_CANCELLED',
  GENERAL: 'GENERAL'
};

export type ActivityType = (typeof ActivityType)[keyof typeof ActivityType]


export const BroadcastStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  EXPIRED: 'EXPIRED'
};

export type BroadcastStatus = (typeof BroadcastStatus)[keyof typeof BroadcastStatus]


export const RequestStatus: {
  PENDING: 'PENDING',
  OFFER_MADE: 'OFFER_MADE',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED',
  CANCELLED: 'CANCELLED'
};

export type RequestStatus = (typeof RequestStatus)[keyof typeof RequestStatus]


export const OfferStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED',
  EXPIRED: 'EXPIRED'
};

export type OfferStatus = (typeof OfferStatus)[keyof typeof OfferStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Category = $Enums.Category

export const Category: typeof $Enums.Category

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type RefundStatus = $Enums.RefundStatus

export const RefundStatus: typeof $Enums.RefundStatus

export type DeliveryStatus = $Enums.DeliveryStatus

export const DeliveryStatus: typeof $Enums.DeliveryStatus

export type ActivityType = $Enums.ActivityType

export const ActivityType: typeof $Enums.ActivityType

export type BroadcastStatus = $Enums.BroadcastStatus

export const BroadcastStatus: typeof $Enums.BroadcastStatus

export type RequestStatus = $Enums.RequestStatus

export const RequestStatus: typeof $Enums.RequestStatus

export type OfferStatus = $Enums.OfferStatus

export const OfferStatus: typeof $Enums.OfferStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productSchedule`: Exposes CRUD operations for the **ProductSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductSchedules
    * const productSchedules = await prisma.productSchedule.findMany()
    * ```
    */
  get productSchedule(): Prisma.ProductScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productOption`: Exposes CRUD operations for the **ProductOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductOptions
    * const productOptions = await prisma.productOption.findMany()
    * ```
    */
  get productOption(): Prisma.ProductOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItemOption`: Exposes CRUD operations for the **OrderItemOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItemOptions
    * const orderItemOptions = await prisma.orderItemOption.findMany()
    * ```
    */
  get orderItemOption(): Prisma.OrderItemOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productReview`: Exposes CRUD operations for the **ProductReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductReviews
    * const productReviews = await prisma.productReview.findMany()
    * ```
    */
  get productReview(): Prisma.ProductReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendorReply`: Exposes CRUD operations for the **VendorReply** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VendorReplies
    * const vendorReplies = await prisma.vendorReply.findMany()
    * ```
    */
  get vendorReply(): Prisma.VendorReplyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reviewVote`: Exposes CRUD operations for the **ReviewVote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReviewVotes
    * const reviewVotes = await prisma.reviewVote.findMany()
    * ```
    */
  get reviewVote(): Prisma.ReviewVoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reviewReport`: Exposes CRUD operations for the **ReviewReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReviewReports
    * const reviewReports = await prisma.reviewReport.findMany()
    * ```
    */
  get reviewReport(): Prisma.ReviewReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendorReview`: Exposes CRUD operations for the **VendorReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VendorReviews
    * const vendorReviews = await prisma.vendorReview.findMany()
    * ```
    */
  get vendorReview(): Prisma.VendorReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.loginHistory`: Exposes CRUD operations for the **LoginHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoginHistories
    * const loginHistories = await prisma.loginHistory.findMany()
    * ```
    */
  get loginHistory(): Prisma.LoginHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordResetToken`: Exposes CRUD operations for the **PasswordResetToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResetTokens
    * const passwordResetTokens = await prisma.passwordResetToken.findMany()
    * ```
    */
  get passwordResetToken(): Prisma.PasswordResetTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refundRequest`: Exposes CRUD operations for the **RefundRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefundRequests
    * const refundRequests = await prisma.refundRequest.findMany()
    * ```
    */
  get refundRequest(): Prisma.RefundRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cart`: Exposes CRUD operations for the **Cart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Carts
    * const carts = await prisma.cart.findMany()
    * ```
    */
  get cart(): Prisma.CartDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cartItem`: Exposes CRUD operations for the **CartItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CartItems
    * const cartItems = await prisma.cartItem.findMany()
    * ```
    */
  get cartItem(): Prisma.CartItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cartItemOption`: Exposes CRUD operations for the **CartItemOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CartItemOptions
    * const cartItemOptions = await prisma.cartItemOption.findMany()
    * ```
    */
  get cartItemOption(): Prisma.CartItemOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPaymentMethod`: Exposes CRUD operations for the **UserPaymentMethod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPaymentMethods
    * const userPaymentMethods = await prisma.userPaymentMethod.findMany()
    * ```
    */
  get userPaymentMethod(): Prisma.UserPaymentMethodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deliveryPerson`: Exposes CRUD operations for the **DeliveryPerson** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryPeople
    * const deliveryPeople = await prisma.deliveryPerson.findMany()
    * ```
    */
  get deliveryPerson(): Prisma.DeliveryPersonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deliveryAssignment`: Exposes CRUD operations for the **DeliveryAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryAssignments
    * const deliveryAssignments = await prisma.deliveryAssignment.findMany()
    * ```
    */
  get deliveryAssignment(): Prisma.DeliveryAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deliveryEarning`: Exposes CRUD operations for the **DeliveryEarning** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryEarnings
    * const deliveryEarnings = await prisma.deliveryEarning.findMany()
    * ```
    */
  get deliveryEarning(): Prisma.DeliveryEarningDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.driverLocationLog`: Exposes CRUD operations for the **DriverLocationLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DriverLocationLogs
    * const driverLocationLogs = await prisma.driverLocationLog.findMany()
    * ```
    */
  get driverLocationLog(): Prisma.DriverLocationLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.ActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deliveryBroadcast`: Exposes CRUD operations for the **DeliveryBroadcast** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryBroadcasts
    * const deliveryBroadcasts = await prisma.deliveryBroadcast.findMany()
    * ```
    */
  get deliveryBroadcast(): Prisma.DeliveryBroadcastDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.webhookEvent`: Exposes CRUD operations for the **WebhookEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebhookEvents
    * const webhookEvents = await prisma.webhookEvent.findMany()
    * ```
    */
  get webhookEvent(): Prisma.WebhookEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.receipt`: Exposes CRUD operations for the **Receipt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Receipts
    * const receipts = await prisma.receipt.findMany()
    * ```
    */
  get receipt(): Prisma.ReceiptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendorFollower`: Exposes CRUD operations for the **VendorFollower** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VendorFollowers
    * const vendorFollowers = await prisma.vendorFollower.findMany()
    * ```
    */
  get vendorFollower(): Prisma.VendorFollowerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.specialOrderRequest`: Exposes CRUD operations for the **SpecialOrderRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpecialOrderRequests
    * const specialOrderRequests = await prisma.specialOrderRequest.findMany()
    * ```
    */
  get specialOrderRequest(): Prisma.SpecialOrderRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.specialOrderOffer`: Exposes CRUD operations for the **SpecialOrderOffer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpecialOrderOffers
    * const specialOrderOffers = await prisma.specialOrderOffer.findMany()
    * ```
    */
  get specialOrderOffer(): Prisma.SpecialOrderOfferDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.1
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Address: 'Address',
    Product: 'Product',
    ProductSchedule: 'ProductSchedule',
    ProductOption: 'ProductOption',
    Order: 'Order',
    OrderItem: 'OrderItem',
    OrderItemOption: 'OrderItemOption',
    ProductReview: 'ProductReview',
    VendorReply: 'VendorReply',
    ReviewVote: 'ReviewVote',
    ReviewReport: 'ReviewReport',
    VendorReview: 'VendorReview',
    Notification: 'Notification',
    LoginHistory: 'LoginHistory',
    PasswordResetToken: 'PasswordResetToken',
    Payment: 'Payment',
    AuditLog: 'AuditLog',
    RefundRequest: 'RefundRequest',
    Cart: 'Cart',
    CartItem: 'CartItem',
    CartItemOption: 'CartItemOption',
    UserPaymentMethod: 'UserPaymentMethod',
    DeliveryPerson: 'DeliveryPerson',
    DeliveryAssignment: 'DeliveryAssignment',
    DeliveryEarning: 'DeliveryEarning',
    DriverLocationLog: 'DriverLocationLog',
    Activity: 'Activity',
    DeliveryBroadcast: 'DeliveryBroadcast',
    WebhookEvent: 'WebhookEvent',
    Receipt: 'Receipt',
    VendorFollower: 'VendorFollower',
    SpecialOrderRequest: 'SpecialOrderRequest',
    SpecialOrderOffer: 'SpecialOrderOffer'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "address" | "product" | "productSchedule" | "productOption" | "order" | "orderItem" | "orderItemOption" | "productReview" | "vendorReply" | "reviewVote" | "reviewReport" | "vendorReview" | "notification" | "loginHistory" | "passwordResetToken" | "payment" | "auditLog" | "refundRequest" | "cart" | "cartItem" | "cartItemOption" | "userPaymentMethod" | "deliveryPerson" | "deliveryAssignment" | "deliveryEarning" | "driverLocationLog" | "activity" | "deliveryBroadcast" | "webhookEvent" | "receipt" | "vendorFollower" | "specialOrderRequest" | "specialOrderOffer"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Address: {
        payload: Prisma.$AddressPayload<ExtArgs>
        fields: Prisma.AddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findFirst: {
            args: Prisma.AddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findMany: {
            args: Prisma.AddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          create: {
            args: Prisma.AddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          createMany: {
            args: Prisma.AddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          delete: {
            args: Prisma.AddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          update: {
            args: Prisma.AddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          deleteMany: {
            args: Prisma.AddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          upsert: {
            args: Prisma.AddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddress>
          }
          groupBy: {
            args: Prisma.AddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressCountArgs<ExtArgs>
            result: $Utils.Optional<AddressCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      ProductSchedule: {
        payload: Prisma.$ProductSchedulePayload<ExtArgs>
        fields: Prisma.ProductScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSchedulePayload>
          }
          findFirst: {
            args: Prisma.ProductScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSchedulePayload>
          }
          findMany: {
            args: Prisma.ProductScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSchedulePayload>[]
          }
          create: {
            args: Prisma.ProductScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSchedulePayload>
          }
          createMany: {
            args: Prisma.ProductScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSchedulePayload>[]
          }
          delete: {
            args: Prisma.ProductScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSchedulePayload>
          }
          update: {
            args: Prisma.ProductScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSchedulePayload>
          }
          deleteMany: {
            args: Prisma.ProductScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSchedulePayload>[]
          }
          upsert: {
            args: Prisma.ProductScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSchedulePayload>
          }
          aggregate: {
            args: Prisma.ProductScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductSchedule>
          }
          groupBy: {
            args: Prisma.ProductScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<ProductScheduleCountAggregateOutputType> | number
          }
        }
      }
      ProductOption: {
        payload: Prisma.$ProductOptionPayload<ExtArgs>
        fields: Prisma.ProductOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductOptionPayload>
          }
          findFirst: {
            args: Prisma.ProductOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductOptionPayload>
          }
          findMany: {
            args: Prisma.ProductOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductOptionPayload>[]
          }
          create: {
            args: Prisma.ProductOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductOptionPayload>
          }
          createMany: {
            args: Prisma.ProductOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductOptionPayload>[]
          }
          delete: {
            args: Prisma.ProductOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductOptionPayload>
          }
          update: {
            args: Prisma.ProductOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductOptionPayload>
          }
          deleteMany: {
            args: Prisma.ProductOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductOptionPayload>[]
          }
          upsert: {
            args: Prisma.ProductOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductOptionPayload>
          }
          aggregate: {
            args: Prisma.ProductOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductOption>
          }
          groupBy: {
            args: Prisma.ProductOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductOptionCountArgs<ExtArgs>
            result: $Utils.Optional<ProductOptionCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      OrderItemOption: {
        payload: Prisma.$OrderItemOptionPayload<ExtArgs>
        fields: Prisma.OrderItemOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemOptionPayload>
          }
          findFirst: {
            args: Prisma.OrderItemOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemOptionPayload>
          }
          findMany: {
            args: Prisma.OrderItemOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemOptionPayload>[]
          }
          create: {
            args: Prisma.OrderItemOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemOptionPayload>
          }
          createMany: {
            args: Prisma.OrderItemOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemOptionPayload>[]
          }
          delete: {
            args: Prisma.OrderItemOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemOptionPayload>
          }
          update: {
            args: Prisma.OrderItemOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemOptionPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderItemOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemOptionPayload>[]
          }
          upsert: {
            args: Prisma.OrderItemOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemOptionPayload>
          }
          aggregate: {
            args: Prisma.OrderItemOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItemOption>
          }
          groupBy: {
            args: Prisma.OrderItemOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemOptionCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemOptionCountAggregateOutputType> | number
          }
        }
      }
      ProductReview: {
        payload: Prisma.$ProductReviewPayload<ExtArgs>
        fields: Prisma.ProductReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload>
          }
          findFirst: {
            args: Prisma.ProductReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload>
          }
          findMany: {
            args: Prisma.ProductReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload>[]
          }
          create: {
            args: Prisma.ProductReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload>
          }
          createMany: {
            args: Prisma.ProductReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload>[]
          }
          delete: {
            args: Prisma.ProductReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload>
          }
          update: {
            args: Prisma.ProductReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload>
          }
          deleteMany: {
            args: Prisma.ProductReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload>[]
          }
          upsert: {
            args: Prisma.ProductReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload>
          }
          aggregate: {
            args: Prisma.ProductReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductReview>
          }
          groupBy: {
            args: Prisma.ProductReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ProductReviewCountAggregateOutputType> | number
          }
        }
      }
      VendorReply: {
        payload: Prisma.$VendorReplyPayload<ExtArgs>
        fields: Prisma.VendorReplyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorReplyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorReplyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorReplyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorReplyPayload>
          }
          findFirst: {
            args: Prisma.VendorReplyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorReplyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorReplyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorReplyPayload>
          }
          findMany: {
            args: Prisma.VendorReplyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorReplyPayload>[]
          }
          create: {
            args: Prisma.VendorReplyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorReplyPayload>
          }
          createMany: {
            args: Prisma.VendorReplyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorReplyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorReplyPayload>[]
          }
          delete: {
            args: Prisma.VendorReplyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorReplyPayload>
          }
          update: {
            args: Prisma.VendorReplyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorReplyPayload>
          }
          deleteMany: {
            args: Prisma.VendorReplyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorReplyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VendorReplyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorReplyPayload>[]
          }
          upsert: {
            args: Prisma.VendorReplyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorReplyPayload>
          }
          aggregate: {
            args: Prisma.VendorReplyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendorReply>
          }
          groupBy: {
            args: Prisma.VendorReplyGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorReplyGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorReplyCountArgs<ExtArgs>
            result: $Utils.Optional<VendorReplyCountAggregateOutputType> | number
          }
        }
      }
      ReviewVote: {
        payload: Prisma.$ReviewVotePayload<ExtArgs>
        fields: Prisma.ReviewVoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewVoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewVotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewVoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewVotePayload>
          }
          findFirst: {
            args: Prisma.ReviewVoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewVotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewVoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewVotePayload>
          }
          findMany: {
            args: Prisma.ReviewVoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewVotePayload>[]
          }
          create: {
            args: Prisma.ReviewVoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewVotePayload>
          }
          createMany: {
            args: Prisma.ReviewVoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewVoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewVotePayload>[]
          }
          delete: {
            args: Prisma.ReviewVoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewVotePayload>
          }
          update: {
            args: Prisma.ReviewVoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewVotePayload>
          }
          deleteMany: {
            args: Prisma.ReviewVoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewVoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewVoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewVotePayload>[]
          }
          upsert: {
            args: Prisma.ReviewVoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewVotePayload>
          }
          aggregate: {
            args: Prisma.ReviewVoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviewVote>
          }
          groupBy: {
            args: Prisma.ReviewVoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewVoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewVoteCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewVoteCountAggregateOutputType> | number
          }
        }
      }
      ReviewReport: {
        payload: Prisma.$ReviewReportPayload<ExtArgs>
        fields: Prisma.ReviewReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReportPayload>
          }
          findFirst: {
            args: Prisma.ReviewReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReportPayload>
          }
          findMany: {
            args: Prisma.ReviewReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReportPayload>[]
          }
          create: {
            args: Prisma.ReviewReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReportPayload>
          }
          createMany: {
            args: Prisma.ReviewReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReportPayload>[]
          }
          delete: {
            args: Prisma.ReviewReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReportPayload>
          }
          update: {
            args: Prisma.ReviewReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReportPayload>
          }
          deleteMany: {
            args: Prisma.ReviewReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReportPayload>[]
          }
          upsert: {
            args: Prisma.ReviewReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReportPayload>
          }
          aggregate: {
            args: Prisma.ReviewReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviewReport>
          }
          groupBy: {
            args: Prisma.ReviewReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewReportCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewReportCountAggregateOutputType> | number
          }
        }
      }
      VendorReview: {
        payload: Prisma.$VendorReviewPayload<ExtArgs>
        fields: Prisma.VendorReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorReviewPayload>
          }
          findFirst: {
            args: Prisma.VendorReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorReviewPayload>
          }
          findMany: {
            args: Prisma.VendorReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorReviewPayload>[]
          }
          create: {
            args: Prisma.VendorReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorReviewPayload>
          }
          createMany: {
            args: Prisma.VendorReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorReviewPayload>[]
          }
          delete: {
            args: Prisma.VendorReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorReviewPayload>
          }
          update: {
            args: Prisma.VendorReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorReviewPayload>
          }
          deleteMany: {
            args: Prisma.VendorReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VendorReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorReviewPayload>[]
          }
          upsert: {
            args: Prisma.VendorReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorReviewPayload>
          }
          aggregate: {
            args: Prisma.VendorReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendorReview>
          }
          groupBy: {
            args: Prisma.VendorReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorReviewCountArgs<ExtArgs>
            result: $Utils.Optional<VendorReviewCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      LoginHistory: {
        payload: Prisma.$LoginHistoryPayload<ExtArgs>
        fields: Prisma.LoginHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoginHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoginHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginHistoryPayload>
          }
          findFirst: {
            args: Prisma.LoginHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoginHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginHistoryPayload>
          }
          findMany: {
            args: Prisma.LoginHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginHistoryPayload>[]
          }
          create: {
            args: Prisma.LoginHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginHistoryPayload>
          }
          createMany: {
            args: Prisma.LoginHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoginHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginHistoryPayload>[]
          }
          delete: {
            args: Prisma.LoginHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginHistoryPayload>
          }
          update: {
            args: Prisma.LoginHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginHistoryPayload>
          }
          deleteMany: {
            args: Prisma.LoginHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoginHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LoginHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginHistoryPayload>[]
          }
          upsert: {
            args: Prisma.LoginHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginHistoryPayload>
          }
          aggregate: {
            args: Prisma.LoginHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoginHistory>
          }
          groupBy: {
            args: Prisma.LoginHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoginHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoginHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<LoginHistoryCountAggregateOutputType> | number
          }
        }
      }
      PasswordResetToken: {
        payload: Prisma.$PasswordResetTokenPayload<ExtArgs>
        fields: Prisma.PasswordResetTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findMany: {
            args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          create: {
            args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          createMany: {
            args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          update: {
            args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          upsert: {
            args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordResetToken>
          }
          groupBy: {
            args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      RefundRequest: {
        payload: Prisma.$RefundRequestPayload<ExtArgs>
        fields: Prisma.RefundRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefundRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefundRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundRequestPayload>
          }
          findFirst: {
            args: Prisma.RefundRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefundRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundRequestPayload>
          }
          findMany: {
            args: Prisma.RefundRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundRequestPayload>[]
          }
          create: {
            args: Prisma.RefundRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundRequestPayload>
          }
          createMany: {
            args: Prisma.RefundRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefundRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundRequestPayload>[]
          }
          delete: {
            args: Prisma.RefundRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundRequestPayload>
          }
          update: {
            args: Prisma.RefundRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundRequestPayload>
          }
          deleteMany: {
            args: Prisma.RefundRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefundRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefundRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundRequestPayload>[]
          }
          upsert: {
            args: Prisma.RefundRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundRequestPayload>
          }
          aggregate: {
            args: Prisma.RefundRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefundRequest>
          }
          groupBy: {
            args: Prisma.RefundRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefundRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefundRequestCountArgs<ExtArgs>
            result: $Utils.Optional<RefundRequestCountAggregateOutputType> | number
          }
        }
      }
      Cart: {
        payload: Prisma.$CartPayload<ExtArgs>
        fields: Prisma.CartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          findFirst: {
            args: Prisma.CartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          findMany: {
            args: Prisma.CartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
          }
          create: {
            args: Prisma.CartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          createMany: {
            args: Prisma.CartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CartCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
          }
          delete: {
            args: Prisma.CartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          update: {
            args: Prisma.CartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          deleteMany: {
            args: Prisma.CartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CartUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
          }
          upsert: {
            args: Prisma.CartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          aggregate: {
            args: Prisma.CartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCart>
          }
          groupBy: {
            args: Prisma.CartGroupByArgs<ExtArgs>
            result: $Utils.Optional<CartGroupByOutputType>[]
          }
          count: {
            args: Prisma.CartCountArgs<ExtArgs>
            result: $Utils.Optional<CartCountAggregateOutputType> | number
          }
        }
      }
      CartItem: {
        payload: Prisma.$CartItemPayload<ExtArgs>
        fields: Prisma.CartItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CartItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CartItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          findFirst: {
            args: Prisma.CartItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CartItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          findMany: {
            args: Prisma.CartItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>[]
          }
          create: {
            args: Prisma.CartItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          createMany: {
            args: Prisma.CartItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CartItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>[]
          }
          delete: {
            args: Prisma.CartItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          update: {
            args: Prisma.CartItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          deleteMany: {
            args: Prisma.CartItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CartItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CartItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>[]
          }
          upsert: {
            args: Prisma.CartItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          aggregate: {
            args: Prisma.CartItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCartItem>
          }
          groupBy: {
            args: Prisma.CartItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<CartItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.CartItemCountArgs<ExtArgs>
            result: $Utils.Optional<CartItemCountAggregateOutputType> | number
          }
        }
      }
      CartItemOption: {
        payload: Prisma.$CartItemOptionPayload<ExtArgs>
        fields: Prisma.CartItemOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CartItemOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CartItemOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemOptionPayload>
          }
          findFirst: {
            args: Prisma.CartItemOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CartItemOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemOptionPayload>
          }
          findMany: {
            args: Prisma.CartItemOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemOptionPayload>[]
          }
          create: {
            args: Prisma.CartItemOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemOptionPayload>
          }
          createMany: {
            args: Prisma.CartItemOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CartItemOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemOptionPayload>[]
          }
          delete: {
            args: Prisma.CartItemOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemOptionPayload>
          }
          update: {
            args: Prisma.CartItemOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemOptionPayload>
          }
          deleteMany: {
            args: Prisma.CartItemOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CartItemOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CartItemOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemOptionPayload>[]
          }
          upsert: {
            args: Prisma.CartItemOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemOptionPayload>
          }
          aggregate: {
            args: Prisma.CartItemOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCartItemOption>
          }
          groupBy: {
            args: Prisma.CartItemOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CartItemOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CartItemOptionCountArgs<ExtArgs>
            result: $Utils.Optional<CartItemOptionCountAggregateOutputType> | number
          }
        }
      }
      UserPaymentMethod: {
        payload: Prisma.$UserPaymentMethodPayload<ExtArgs>
        fields: Prisma.UserPaymentMethodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPaymentMethodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPaymentMethodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPaymentMethodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPaymentMethodPayload>
          }
          findFirst: {
            args: Prisma.UserPaymentMethodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPaymentMethodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPaymentMethodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPaymentMethodPayload>
          }
          findMany: {
            args: Prisma.UserPaymentMethodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPaymentMethodPayload>[]
          }
          create: {
            args: Prisma.UserPaymentMethodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPaymentMethodPayload>
          }
          createMany: {
            args: Prisma.UserPaymentMethodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPaymentMethodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPaymentMethodPayload>[]
          }
          delete: {
            args: Prisma.UserPaymentMethodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPaymentMethodPayload>
          }
          update: {
            args: Prisma.UserPaymentMethodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPaymentMethodPayload>
          }
          deleteMany: {
            args: Prisma.UserPaymentMethodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPaymentMethodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPaymentMethodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPaymentMethodPayload>[]
          }
          upsert: {
            args: Prisma.UserPaymentMethodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPaymentMethodPayload>
          }
          aggregate: {
            args: Prisma.UserPaymentMethodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPaymentMethod>
          }
          groupBy: {
            args: Prisma.UserPaymentMethodGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPaymentMethodGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPaymentMethodCountArgs<ExtArgs>
            result: $Utils.Optional<UserPaymentMethodCountAggregateOutputType> | number
          }
        }
      }
      DeliveryPerson: {
        payload: Prisma.$DeliveryPersonPayload<ExtArgs>
        fields: Prisma.DeliveryPersonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryPersonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPersonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryPersonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPersonPayload>
          }
          findFirst: {
            args: Prisma.DeliveryPersonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPersonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryPersonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPersonPayload>
          }
          findMany: {
            args: Prisma.DeliveryPersonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPersonPayload>[]
          }
          create: {
            args: Prisma.DeliveryPersonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPersonPayload>
          }
          createMany: {
            args: Prisma.DeliveryPersonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryPersonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPersonPayload>[]
          }
          delete: {
            args: Prisma.DeliveryPersonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPersonPayload>
          }
          update: {
            args: Prisma.DeliveryPersonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPersonPayload>
          }
          deleteMany: {
            args: Prisma.DeliveryPersonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryPersonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeliveryPersonUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPersonPayload>[]
          }
          upsert: {
            args: Prisma.DeliveryPersonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPersonPayload>
          }
          aggregate: {
            args: Prisma.DeliveryPersonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryPerson>
          }
          groupBy: {
            args: Prisma.DeliveryPersonGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryPersonGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryPersonCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryPersonCountAggregateOutputType> | number
          }
        }
      }
      DeliveryAssignment: {
        payload: Prisma.$DeliveryAssignmentPayload<ExtArgs>
        fields: Prisma.DeliveryAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryAssignmentPayload>
          }
          findFirst: {
            args: Prisma.DeliveryAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryAssignmentPayload>
          }
          findMany: {
            args: Prisma.DeliveryAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryAssignmentPayload>[]
          }
          create: {
            args: Prisma.DeliveryAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryAssignmentPayload>
          }
          createMany: {
            args: Prisma.DeliveryAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryAssignmentPayload>[]
          }
          delete: {
            args: Prisma.DeliveryAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryAssignmentPayload>
          }
          update: {
            args: Prisma.DeliveryAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.DeliveryAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeliveryAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.DeliveryAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryAssignmentPayload>
          }
          aggregate: {
            args: Prisma.DeliveryAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryAssignment>
          }
          groupBy: {
            args: Prisma.DeliveryAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryAssignmentCountAggregateOutputType> | number
          }
        }
      }
      DeliveryEarning: {
        payload: Prisma.$DeliveryEarningPayload<ExtArgs>
        fields: Prisma.DeliveryEarningFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryEarningFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryEarningPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryEarningFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryEarningPayload>
          }
          findFirst: {
            args: Prisma.DeliveryEarningFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryEarningPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryEarningFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryEarningPayload>
          }
          findMany: {
            args: Prisma.DeliveryEarningFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryEarningPayload>[]
          }
          create: {
            args: Prisma.DeliveryEarningCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryEarningPayload>
          }
          createMany: {
            args: Prisma.DeliveryEarningCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryEarningCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryEarningPayload>[]
          }
          delete: {
            args: Prisma.DeliveryEarningDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryEarningPayload>
          }
          update: {
            args: Prisma.DeliveryEarningUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryEarningPayload>
          }
          deleteMany: {
            args: Prisma.DeliveryEarningDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryEarningUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeliveryEarningUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryEarningPayload>[]
          }
          upsert: {
            args: Prisma.DeliveryEarningUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryEarningPayload>
          }
          aggregate: {
            args: Prisma.DeliveryEarningAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryEarning>
          }
          groupBy: {
            args: Prisma.DeliveryEarningGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryEarningGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryEarningCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryEarningCountAggregateOutputType> | number
          }
        }
      }
      DriverLocationLog: {
        payload: Prisma.$DriverLocationLogPayload<ExtArgs>
        fields: Prisma.DriverLocationLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DriverLocationLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverLocationLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DriverLocationLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverLocationLogPayload>
          }
          findFirst: {
            args: Prisma.DriverLocationLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverLocationLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DriverLocationLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverLocationLogPayload>
          }
          findMany: {
            args: Prisma.DriverLocationLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverLocationLogPayload>[]
          }
          create: {
            args: Prisma.DriverLocationLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverLocationLogPayload>
          }
          createMany: {
            args: Prisma.DriverLocationLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DriverLocationLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverLocationLogPayload>[]
          }
          delete: {
            args: Prisma.DriverLocationLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverLocationLogPayload>
          }
          update: {
            args: Prisma.DriverLocationLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverLocationLogPayload>
          }
          deleteMany: {
            args: Prisma.DriverLocationLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DriverLocationLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DriverLocationLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverLocationLogPayload>[]
          }
          upsert: {
            args: Prisma.DriverLocationLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverLocationLogPayload>
          }
          aggregate: {
            args: Prisma.DriverLocationLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDriverLocationLog>
          }
          groupBy: {
            args: Prisma.DriverLocationLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<DriverLocationLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.DriverLocationLogCountArgs<ExtArgs>
            result: $Utils.Optional<DriverLocationLogCountAggregateOutputType> | number
          }
        }
      }
      Activity: {
        payload: Prisma.$ActivityPayload<ExtArgs>
        fields: Prisma.ActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findFirst: {
            args: Prisma.ActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findMany: {
            args: Prisma.ActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          create: {
            args: Prisma.ActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          createMany: {
            args: Prisma.ActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          delete: {
            args: Prisma.ActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          update: {
            args: Prisma.ActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          deleteMany: {
            args: Prisma.ActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          upsert: {
            args: Prisma.ActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          aggregate: {
            args: Prisma.ActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivity>
          }
          groupBy: {
            args: Prisma.ActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityCountAggregateOutputType> | number
          }
        }
      }
      DeliveryBroadcast: {
        payload: Prisma.$DeliveryBroadcastPayload<ExtArgs>
        fields: Prisma.DeliveryBroadcastFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryBroadcastFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryBroadcastPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryBroadcastFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryBroadcastPayload>
          }
          findFirst: {
            args: Prisma.DeliveryBroadcastFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryBroadcastPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryBroadcastFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryBroadcastPayload>
          }
          findMany: {
            args: Prisma.DeliveryBroadcastFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryBroadcastPayload>[]
          }
          create: {
            args: Prisma.DeliveryBroadcastCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryBroadcastPayload>
          }
          createMany: {
            args: Prisma.DeliveryBroadcastCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryBroadcastCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryBroadcastPayload>[]
          }
          delete: {
            args: Prisma.DeliveryBroadcastDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryBroadcastPayload>
          }
          update: {
            args: Prisma.DeliveryBroadcastUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryBroadcastPayload>
          }
          deleteMany: {
            args: Prisma.DeliveryBroadcastDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryBroadcastUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeliveryBroadcastUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryBroadcastPayload>[]
          }
          upsert: {
            args: Prisma.DeliveryBroadcastUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryBroadcastPayload>
          }
          aggregate: {
            args: Prisma.DeliveryBroadcastAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryBroadcast>
          }
          groupBy: {
            args: Prisma.DeliveryBroadcastGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryBroadcastGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryBroadcastCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryBroadcastCountAggregateOutputType> | number
          }
        }
      }
      WebhookEvent: {
        payload: Prisma.$WebhookEventPayload<ExtArgs>
        fields: Prisma.WebhookEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          findFirst: {
            args: Prisma.WebhookEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          findMany: {
            args: Prisma.WebhookEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>[]
          }
          create: {
            args: Prisma.WebhookEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          createMany: {
            args: Prisma.WebhookEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>[]
          }
          delete: {
            args: Prisma.WebhookEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          update: {
            args: Prisma.WebhookEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          deleteMany: {
            args: Prisma.WebhookEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WebhookEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>[]
          }
          upsert: {
            args: Prisma.WebhookEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          aggregate: {
            args: Prisma.WebhookEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhookEvent>
          }
          groupBy: {
            args: Prisma.WebhookEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookEventCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookEventCountAggregateOutputType> | number
          }
        }
      }
      Receipt: {
        payload: Prisma.$ReceiptPayload<ExtArgs>
        fields: Prisma.ReceiptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReceiptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReceiptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          findFirst: {
            args: Prisma.ReceiptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReceiptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          findMany: {
            args: Prisma.ReceiptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>[]
          }
          create: {
            args: Prisma.ReceiptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          createMany: {
            args: Prisma.ReceiptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReceiptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>[]
          }
          delete: {
            args: Prisma.ReceiptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          update: {
            args: Prisma.ReceiptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          deleteMany: {
            args: Prisma.ReceiptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReceiptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReceiptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>[]
          }
          upsert: {
            args: Prisma.ReceiptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          aggregate: {
            args: Prisma.ReceiptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReceipt>
          }
          groupBy: {
            args: Prisma.ReceiptGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReceiptGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReceiptCountArgs<ExtArgs>
            result: $Utils.Optional<ReceiptCountAggregateOutputType> | number
          }
        }
      }
      VendorFollower: {
        payload: Prisma.$VendorFollowerPayload<ExtArgs>
        fields: Prisma.VendorFollowerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorFollowerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorFollowerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorFollowerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorFollowerPayload>
          }
          findFirst: {
            args: Prisma.VendorFollowerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorFollowerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorFollowerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorFollowerPayload>
          }
          findMany: {
            args: Prisma.VendorFollowerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorFollowerPayload>[]
          }
          create: {
            args: Prisma.VendorFollowerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorFollowerPayload>
          }
          createMany: {
            args: Prisma.VendorFollowerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorFollowerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorFollowerPayload>[]
          }
          delete: {
            args: Prisma.VendorFollowerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorFollowerPayload>
          }
          update: {
            args: Prisma.VendorFollowerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorFollowerPayload>
          }
          deleteMany: {
            args: Prisma.VendorFollowerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorFollowerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VendorFollowerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorFollowerPayload>[]
          }
          upsert: {
            args: Prisma.VendorFollowerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorFollowerPayload>
          }
          aggregate: {
            args: Prisma.VendorFollowerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendorFollower>
          }
          groupBy: {
            args: Prisma.VendorFollowerGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorFollowerGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorFollowerCountArgs<ExtArgs>
            result: $Utils.Optional<VendorFollowerCountAggregateOutputType> | number
          }
        }
      }
      SpecialOrderRequest: {
        payload: Prisma.$SpecialOrderRequestPayload<ExtArgs>
        fields: Prisma.SpecialOrderRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpecialOrderRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialOrderRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpecialOrderRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialOrderRequestPayload>
          }
          findFirst: {
            args: Prisma.SpecialOrderRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialOrderRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpecialOrderRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialOrderRequestPayload>
          }
          findMany: {
            args: Prisma.SpecialOrderRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialOrderRequestPayload>[]
          }
          create: {
            args: Prisma.SpecialOrderRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialOrderRequestPayload>
          }
          createMany: {
            args: Prisma.SpecialOrderRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpecialOrderRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialOrderRequestPayload>[]
          }
          delete: {
            args: Prisma.SpecialOrderRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialOrderRequestPayload>
          }
          update: {
            args: Prisma.SpecialOrderRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialOrderRequestPayload>
          }
          deleteMany: {
            args: Prisma.SpecialOrderRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpecialOrderRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SpecialOrderRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialOrderRequestPayload>[]
          }
          upsert: {
            args: Prisma.SpecialOrderRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialOrderRequestPayload>
          }
          aggregate: {
            args: Prisma.SpecialOrderRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpecialOrderRequest>
          }
          groupBy: {
            args: Prisma.SpecialOrderRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpecialOrderRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpecialOrderRequestCountArgs<ExtArgs>
            result: $Utils.Optional<SpecialOrderRequestCountAggregateOutputType> | number
          }
        }
      }
      SpecialOrderOffer: {
        payload: Prisma.$SpecialOrderOfferPayload<ExtArgs>
        fields: Prisma.SpecialOrderOfferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpecialOrderOfferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialOrderOfferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpecialOrderOfferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialOrderOfferPayload>
          }
          findFirst: {
            args: Prisma.SpecialOrderOfferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialOrderOfferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpecialOrderOfferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialOrderOfferPayload>
          }
          findMany: {
            args: Prisma.SpecialOrderOfferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialOrderOfferPayload>[]
          }
          create: {
            args: Prisma.SpecialOrderOfferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialOrderOfferPayload>
          }
          createMany: {
            args: Prisma.SpecialOrderOfferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpecialOrderOfferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialOrderOfferPayload>[]
          }
          delete: {
            args: Prisma.SpecialOrderOfferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialOrderOfferPayload>
          }
          update: {
            args: Prisma.SpecialOrderOfferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialOrderOfferPayload>
          }
          deleteMany: {
            args: Prisma.SpecialOrderOfferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpecialOrderOfferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SpecialOrderOfferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialOrderOfferPayload>[]
          }
          upsert: {
            args: Prisma.SpecialOrderOfferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialOrderOfferPayload>
          }
          aggregate: {
            args: Prisma.SpecialOrderOfferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpecialOrderOffer>
          }
          groupBy: {
            args: Prisma.SpecialOrderOfferGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpecialOrderOfferGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpecialOrderOfferCountArgs<ExtArgs>
            result: $Utils.Optional<SpecialOrderOfferCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    address?: AddressOmit
    product?: ProductOmit
    productSchedule?: ProductScheduleOmit
    productOption?: ProductOptionOmit
    order?: OrderOmit
    orderItem?: OrderItemOmit
    orderItemOption?: OrderItemOptionOmit
    productReview?: ProductReviewOmit
    vendorReply?: VendorReplyOmit
    reviewVote?: ReviewVoteOmit
    reviewReport?: ReviewReportOmit
    vendorReview?: VendorReviewOmit
    notification?: NotificationOmit
    loginHistory?: LoginHistoryOmit
    passwordResetToken?: PasswordResetTokenOmit
    payment?: PaymentOmit
    auditLog?: AuditLogOmit
    refundRequest?: RefundRequestOmit
    cart?: CartOmit
    cartItem?: CartItemOmit
    cartItemOption?: CartItemOptionOmit
    userPaymentMethod?: UserPaymentMethodOmit
    deliveryPerson?: DeliveryPersonOmit
    deliveryAssignment?: DeliveryAssignmentOmit
    deliveryEarning?: DeliveryEarningOmit
    driverLocationLog?: DriverLocationLogOmit
    activity?: ActivityOmit
    deliveryBroadcast?: DeliveryBroadcastOmit
    webhookEvent?: WebhookEventOmit
    receipt?: ReceiptOmit
    vendorFollower?: VendorFollowerOmit
    specialOrderRequest?: SpecialOrderRequestOmit
    specialOrderOffer?: SpecialOrderOfferOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    products: number
    vendorReviewsReceived: number
    vendorReviewsGiven: number
    productReviewsGiven: number
    customerOrders: number
    vendorOrders: number
    vendorRepliesSent: number
    reviewVotes: number
    reviewReports: number
    notifications: number
    loginHistory: number
    addresses: number
    carts: number
    UserPaymentMethod: number
    payments: number
    RefundRequest: number
    vendorActivities: number
    customerActivities: number
    followers: number
    following: number
    specialRequestsMade: number
    specialRequestsReceived: number
    specialOffersSent: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | UserCountOutputTypeCountProductsArgs
    vendorReviewsReceived?: boolean | UserCountOutputTypeCountVendorReviewsReceivedArgs
    vendorReviewsGiven?: boolean | UserCountOutputTypeCountVendorReviewsGivenArgs
    productReviewsGiven?: boolean | UserCountOutputTypeCountProductReviewsGivenArgs
    customerOrders?: boolean | UserCountOutputTypeCountCustomerOrdersArgs
    vendorOrders?: boolean | UserCountOutputTypeCountVendorOrdersArgs
    vendorRepliesSent?: boolean | UserCountOutputTypeCountVendorRepliesSentArgs
    reviewVotes?: boolean | UserCountOutputTypeCountReviewVotesArgs
    reviewReports?: boolean | UserCountOutputTypeCountReviewReportsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    loginHistory?: boolean | UserCountOutputTypeCountLoginHistoryArgs
    addresses?: boolean | UserCountOutputTypeCountAddressesArgs
    carts?: boolean | UserCountOutputTypeCountCartsArgs
    UserPaymentMethod?: boolean | UserCountOutputTypeCountUserPaymentMethodArgs
    payments?: boolean | UserCountOutputTypeCountPaymentsArgs
    RefundRequest?: boolean | UserCountOutputTypeCountRefundRequestArgs
    vendorActivities?: boolean | UserCountOutputTypeCountVendorActivitiesArgs
    customerActivities?: boolean | UserCountOutputTypeCountCustomerActivitiesArgs
    followers?: boolean | UserCountOutputTypeCountFollowersArgs
    following?: boolean | UserCountOutputTypeCountFollowingArgs
    specialRequestsMade?: boolean | UserCountOutputTypeCountSpecialRequestsMadeArgs
    specialRequestsReceived?: boolean | UserCountOutputTypeCountSpecialRequestsReceivedArgs
    specialOffersSent?: boolean | UserCountOutputTypeCountSpecialOffersSentArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVendorReviewsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVendorReviewsGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProductReviewsGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCustomerOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVendorOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVendorRepliesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorReplyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewVoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLoginHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoginHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserPaymentMethodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPaymentMethodWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefundRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefundRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVendorActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCustomerActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorFollowerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorFollowerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSpecialRequestsMadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecialOrderRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSpecialRequestsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecialOrderRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSpecialOffersSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecialOrderOfferWhereInput
  }


  /**
   * Count Type AddressCountOutputType
   */

  export type AddressCountOutputType = {
    orders: number
  }

  export type AddressCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | AddressCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressCountOutputType
     */
    select?: AddressCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    reviews: number
    orders: number
    orderItems: number
    options: number
    CartItem: number
    specialRequests: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews?: boolean | ProductCountOutputTypeCountReviewsArgs
    orders?: boolean | ProductCountOutputTypeCountOrdersArgs
    orderItems?: boolean | ProductCountOutputTypeCountOrderItemsArgs
    options?: boolean | ProductCountOutputTypeCountOptionsArgs
    CartItem?: boolean | ProductCountOutputTypeCountCartItemArgs
    specialRequests?: boolean | ProductCountOutputTypeCountSpecialRequestsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductReviewWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductOptionWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCartItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountSpecialRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecialOrderRequestWhereInput
  }


  /**
   * Count Type ProductOptionCountOutputType
   */

  export type ProductOptionCountOutputType = {
    OrderItemOption: number
    CartItemOption: number
  }

  export type ProductOptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OrderItemOption?: boolean | ProductOptionCountOutputTypeCountOrderItemOptionArgs
    CartItemOption?: boolean | ProductOptionCountOutputTypeCountCartItemOptionArgs
  }

  // Custom InputTypes
  /**
   * ProductOptionCountOutputType without action
   */
  export type ProductOptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOptionCountOutputType
     */
    select?: ProductOptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductOptionCountOutputType without action
   */
  export type ProductOptionCountOutputTypeCountOrderItemOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemOptionWhereInput
  }

  /**
   * ProductOptionCountOutputType without action
   */
  export type ProductOptionCountOutputTypeCountCartItemOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemOptionWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    items: number
    payments: number
    Product: number
    assignments: number
    earnings: number
    Activity: number
    DeliveryBroadcast: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | OrderCountOutputTypeCountItemsArgs
    payments?: boolean | OrderCountOutputTypeCountPaymentsArgs
    Product?: boolean | OrderCountOutputTypeCountProductArgs
    assignments?: boolean | OrderCountOutputTypeCountAssignmentsArgs
    earnings?: boolean | OrderCountOutputTypeCountEarningsArgs
    Activity?: boolean | OrderCountOutputTypeCountActivityArgs
    DeliveryBroadcast?: boolean | OrderCountOutputTypeCountDeliveryBroadcastArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryAssignmentWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountEarningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryEarningWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountDeliveryBroadcastArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryBroadcastWhereInput
  }


  /**
   * Count Type OrderItemCountOutputType
   */

  export type OrderItemCountOutputType = {
    options: number
  }

  export type OrderItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    options?: boolean | OrderItemCountOutputTypeCountOptionsArgs
  }

  // Custom InputTypes
  /**
   * OrderItemCountOutputType without action
   */
  export type OrderItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemCountOutputType
     */
    select?: OrderItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderItemCountOutputType without action
   */
  export type OrderItemCountOutputTypeCountOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemOptionWhereInput
  }


  /**
   * Count Type ProductReviewCountOutputType
   */

  export type ProductReviewCountOutputType = {
    votes: number
    reports: number
  }

  export type ProductReviewCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    votes?: boolean | ProductReviewCountOutputTypeCountVotesArgs
    reports?: boolean | ProductReviewCountOutputTypeCountReportsArgs
  }

  // Custom InputTypes
  /**
   * ProductReviewCountOutputType without action
   */
  export type ProductReviewCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReviewCountOutputType
     */
    select?: ProductReviewCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductReviewCountOutputType without action
   */
  export type ProductReviewCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewVoteWhereInput
  }

  /**
   * ProductReviewCountOutputType without action
   */
  export type ProductReviewCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewReportWhereInput
  }


  /**
   * Count Type PaymentCountOutputType
   */

  export type PaymentCountOutputType = {
    Receipt: number
  }

  export type PaymentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Receipt?: boolean | PaymentCountOutputTypeCountReceiptArgs
  }

  // Custom InputTypes
  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentCountOutputType
     */
    select?: PaymentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeCountReceiptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceiptWhereInput
  }


  /**
   * Count Type CartCountOutputType
   */

  export type CartCountOutputType = {
    items: number
  }

  export type CartCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | CartCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * CartCountOutputType without action
   */
  export type CartCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartCountOutputType
     */
    select?: CartCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CartCountOutputType without action
   */
  export type CartCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
  }


  /**
   * Count Type CartItemCountOutputType
   */

  export type CartItemCountOutputType = {
    options: number
  }

  export type CartItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    options?: boolean | CartItemCountOutputTypeCountOptionsArgs
  }

  // Custom InputTypes
  /**
   * CartItemCountOutputType without action
   */
  export type CartItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItemCountOutputType
     */
    select?: CartItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CartItemCountOutputType without action
   */
  export type CartItemCountOutputTypeCountOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemOptionWhereInput
  }


  /**
   * Count Type DeliveryPersonCountOutputType
   */

  export type DeliveryPersonCountOutputType = {
    assignedOrders: number
    earnings: number
    DriverLocationLog: number
    Activity: number
  }

  export type DeliveryPersonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedOrders?: boolean | DeliveryPersonCountOutputTypeCountAssignedOrdersArgs
    earnings?: boolean | DeliveryPersonCountOutputTypeCountEarningsArgs
    DriverLocationLog?: boolean | DeliveryPersonCountOutputTypeCountDriverLocationLogArgs
    Activity?: boolean | DeliveryPersonCountOutputTypeCountActivityArgs
  }

  // Custom InputTypes
  /**
   * DeliveryPersonCountOutputType without action
   */
  export type DeliveryPersonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPersonCountOutputType
     */
    select?: DeliveryPersonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeliveryPersonCountOutputType without action
   */
  export type DeliveryPersonCountOutputTypeCountAssignedOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryAssignmentWhereInput
  }

  /**
   * DeliveryPersonCountOutputType without action
   */
  export type DeliveryPersonCountOutputTypeCountEarningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryEarningWhereInput
  }

  /**
   * DeliveryPersonCountOutputType without action
   */
  export type DeliveryPersonCountOutputTypeCountDriverLocationLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriverLocationLogWhereInput
  }

  /**
   * DeliveryPersonCountOutputType without action
   */
  export type DeliveryPersonCountOutputTypeCountActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }


  /**
   * Count Type SpecialOrderRequestCountOutputType
   */

  export type SpecialOrderRequestCountOutputType = {
    offers: number
  }

  export type SpecialOrderRequestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offers?: boolean | SpecialOrderRequestCountOutputTypeCountOffersArgs
  }

  // Custom InputTypes
  /**
   * SpecialOrderRequestCountOutputType without action
   */
  export type SpecialOrderRequestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOrderRequestCountOutputType
     */
    select?: SpecialOrderRequestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SpecialOrderRequestCountOutputType without action
   */
  export type SpecialOrderRequestCountOutputTypeCountOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecialOrderOfferWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    tokenVersion: number | null
  }

  export type UserSumAggregateOutputType = {
    tokenVersion: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    username: string | null
    name: string | null
    email: string | null
    phoneNumber: string | null
    password: string | null
    avatarUrl: string | null
    bio: string | null
    role: $Enums.Role | null
    brandName: string | null
    brandLogo: string | null
    googleId: string | null
    tokenVersion: number | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
    loginMethod: string | null
    isEmailVerified: boolean | null
    emailVerificationToken: string | null
    emailVerificationExpiresAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    name: string | null
    email: string | null
    phoneNumber: string | null
    password: string | null
    avatarUrl: string | null
    bio: string | null
    role: $Enums.Role | null
    brandName: string | null
    brandLogo: string | null
    googleId: string | null
    tokenVersion: number | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
    loginMethod: string | null
    isEmailVerified: boolean | null
    emailVerificationToken: string | null
    emailVerificationExpiresAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    name: number
    email: number
    phoneNumber: number
    password: number
    avatarUrl: number
    preferences: number
    bio: number
    role: number
    brandName: number
    brandLogo: number
    googleId: number
    tokenVersion: number
    createdAt: number
    updatedAt: number
    authProviders: number
    lastLoginAt: number
    loginMethod: number
    isEmailVerified: number
    emailVerificationToken: number
    emailVerificationExpiresAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    tokenVersion?: true
  }

  export type UserSumAggregateInputType = {
    tokenVersion?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    name?: true
    email?: true
    phoneNumber?: true
    password?: true
    avatarUrl?: true
    bio?: true
    role?: true
    brandName?: true
    brandLogo?: true
    googleId?: true
    tokenVersion?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    loginMethod?: true
    isEmailVerified?: true
    emailVerificationToken?: true
    emailVerificationExpiresAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    name?: true
    email?: true
    phoneNumber?: true
    password?: true
    avatarUrl?: true
    bio?: true
    role?: true
    brandName?: true
    brandLogo?: true
    googleId?: true
    tokenVersion?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    loginMethod?: true
    isEmailVerified?: true
    emailVerificationToken?: true
    emailVerificationExpiresAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    name?: true
    email?: true
    phoneNumber?: true
    password?: true
    avatarUrl?: true
    preferences?: true
    bio?: true
    role?: true
    brandName?: true
    brandLogo?: true
    googleId?: true
    tokenVersion?: true
    createdAt?: true
    updatedAt?: true
    authProviders?: true
    lastLoginAt?: true
    loginMethod?: true
    isEmailVerified?: true
    emailVerificationToken?: true
    emailVerificationExpiresAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    username: string | null
    name: string
    email: string
    phoneNumber: string | null
    password: string | null
    avatarUrl: string | null
    preferences: string[]
    bio: string | null
    role: $Enums.Role | null
    brandName: string | null
    brandLogo: string | null
    googleId: string | null
    tokenVersion: number
    createdAt: Date
    updatedAt: Date
    authProviders: string[]
    lastLoginAt: Date | null
    loginMethod: string | null
    isEmailVerified: boolean
    emailVerificationToken: string | null
    emailVerificationExpiresAt: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    name?: boolean
    email?: boolean
    phoneNumber?: boolean
    password?: boolean
    avatarUrl?: boolean
    preferences?: boolean
    bio?: boolean
    role?: boolean
    brandName?: boolean
    brandLogo?: boolean
    googleId?: boolean
    tokenVersion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authProviders?: boolean
    lastLoginAt?: boolean
    loginMethod?: boolean
    isEmailVerified?: boolean
    emailVerificationToken?: boolean
    emailVerificationExpiresAt?: boolean
    products?: boolean | User$productsArgs<ExtArgs>
    vendorReviewsReceived?: boolean | User$vendorReviewsReceivedArgs<ExtArgs>
    vendorReviewsGiven?: boolean | User$vendorReviewsGivenArgs<ExtArgs>
    productReviewsGiven?: boolean | User$productReviewsGivenArgs<ExtArgs>
    customerOrders?: boolean | User$customerOrdersArgs<ExtArgs>
    vendorOrders?: boolean | User$vendorOrdersArgs<ExtArgs>
    vendorRepliesSent?: boolean | User$vendorRepliesSentArgs<ExtArgs>
    reviewVotes?: boolean | User$reviewVotesArgs<ExtArgs>
    reviewReports?: boolean | User$reviewReportsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    loginHistory?: boolean | User$loginHistoryArgs<ExtArgs>
    addresses?: boolean | User$addressesArgs<ExtArgs>
    carts?: boolean | User$cartsArgs<ExtArgs>
    UserPaymentMethod?: boolean | User$UserPaymentMethodArgs<ExtArgs>
    deliveryPerson?: boolean | User$deliveryPersonArgs<ExtArgs>
    passwordResetToken?: boolean | User$passwordResetTokenArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    RefundRequest?: boolean | User$RefundRequestArgs<ExtArgs>
    vendorActivities?: boolean | User$vendorActivitiesArgs<ExtArgs>
    customerActivities?: boolean | User$customerActivitiesArgs<ExtArgs>
    followers?: boolean | User$followersArgs<ExtArgs>
    following?: boolean | User$followingArgs<ExtArgs>
    specialRequestsMade?: boolean | User$specialRequestsMadeArgs<ExtArgs>
    specialRequestsReceived?: boolean | User$specialRequestsReceivedArgs<ExtArgs>
    specialOffersSent?: boolean | User$specialOffersSentArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    name?: boolean
    email?: boolean
    phoneNumber?: boolean
    password?: boolean
    avatarUrl?: boolean
    preferences?: boolean
    bio?: boolean
    role?: boolean
    brandName?: boolean
    brandLogo?: boolean
    googleId?: boolean
    tokenVersion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authProviders?: boolean
    lastLoginAt?: boolean
    loginMethod?: boolean
    isEmailVerified?: boolean
    emailVerificationToken?: boolean
    emailVerificationExpiresAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    name?: boolean
    email?: boolean
    phoneNumber?: boolean
    password?: boolean
    avatarUrl?: boolean
    preferences?: boolean
    bio?: boolean
    role?: boolean
    brandName?: boolean
    brandLogo?: boolean
    googleId?: boolean
    tokenVersion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authProviders?: boolean
    lastLoginAt?: boolean
    loginMethod?: boolean
    isEmailVerified?: boolean
    emailVerificationToken?: boolean
    emailVerificationExpiresAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    name?: boolean
    email?: boolean
    phoneNumber?: boolean
    password?: boolean
    avatarUrl?: boolean
    preferences?: boolean
    bio?: boolean
    role?: boolean
    brandName?: boolean
    brandLogo?: boolean
    googleId?: boolean
    tokenVersion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authProviders?: boolean
    lastLoginAt?: boolean
    loginMethod?: boolean
    isEmailVerified?: boolean
    emailVerificationToken?: boolean
    emailVerificationExpiresAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "name" | "email" | "phoneNumber" | "password" | "avatarUrl" | "preferences" | "bio" | "role" | "brandName" | "brandLogo" | "googleId" | "tokenVersion" | "createdAt" | "updatedAt" | "authProviders" | "lastLoginAt" | "loginMethod" | "isEmailVerified" | "emailVerificationToken" | "emailVerificationExpiresAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | User$productsArgs<ExtArgs>
    vendorReviewsReceived?: boolean | User$vendorReviewsReceivedArgs<ExtArgs>
    vendorReviewsGiven?: boolean | User$vendorReviewsGivenArgs<ExtArgs>
    productReviewsGiven?: boolean | User$productReviewsGivenArgs<ExtArgs>
    customerOrders?: boolean | User$customerOrdersArgs<ExtArgs>
    vendorOrders?: boolean | User$vendorOrdersArgs<ExtArgs>
    vendorRepliesSent?: boolean | User$vendorRepliesSentArgs<ExtArgs>
    reviewVotes?: boolean | User$reviewVotesArgs<ExtArgs>
    reviewReports?: boolean | User$reviewReportsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    loginHistory?: boolean | User$loginHistoryArgs<ExtArgs>
    addresses?: boolean | User$addressesArgs<ExtArgs>
    carts?: boolean | User$cartsArgs<ExtArgs>
    UserPaymentMethod?: boolean | User$UserPaymentMethodArgs<ExtArgs>
    deliveryPerson?: boolean | User$deliveryPersonArgs<ExtArgs>
    passwordResetToken?: boolean | User$passwordResetTokenArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    RefundRequest?: boolean | User$RefundRequestArgs<ExtArgs>
    vendorActivities?: boolean | User$vendorActivitiesArgs<ExtArgs>
    customerActivities?: boolean | User$customerActivitiesArgs<ExtArgs>
    followers?: boolean | User$followersArgs<ExtArgs>
    following?: boolean | User$followingArgs<ExtArgs>
    specialRequestsMade?: boolean | User$specialRequestsMadeArgs<ExtArgs>
    specialRequestsReceived?: boolean | User$specialRequestsReceivedArgs<ExtArgs>
    specialOffersSent?: boolean | User$specialOffersSentArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
      vendorReviewsReceived: Prisma.$VendorReviewPayload<ExtArgs>[]
      vendorReviewsGiven: Prisma.$VendorReviewPayload<ExtArgs>[]
      productReviewsGiven: Prisma.$ProductReviewPayload<ExtArgs>[]
      customerOrders: Prisma.$OrderPayload<ExtArgs>[]
      vendorOrders: Prisma.$OrderPayload<ExtArgs>[]
      vendorRepliesSent: Prisma.$VendorReplyPayload<ExtArgs>[]
      reviewVotes: Prisma.$ReviewVotePayload<ExtArgs>[]
      reviewReports: Prisma.$ReviewReportPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      loginHistory: Prisma.$LoginHistoryPayload<ExtArgs>[]
      addresses: Prisma.$AddressPayload<ExtArgs>[]
      carts: Prisma.$CartPayload<ExtArgs>[]
      UserPaymentMethod: Prisma.$UserPaymentMethodPayload<ExtArgs>[]
      deliveryPerson: Prisma.$DeliveryPersonPayload<ExtArgs> | null
      passwordResetToken: Prisma.$PasswordResetTokenPayload<ExtArgs> | null
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      RefundRequest: Prisma.$RefundRequestPayload<ExtArgs>[]
      vendorActivities: Prisma.$ActivityPayload<ExtArgs>[]
      customerActivities: Prisma.$ActivityPayload<ExtArgs>[]
      followers: Prisma.$VendorFollowerPayload<ExtArgs>[]
      following: Prisma.$VendorFollowerPayload<ExtArgs>[]
      specialRequestsMade: Prisma.$SpecialOrderRequestPayload<ExtArgs>[]
      specialRequestsReceived: Prisma.$SpecialOrderRequestPayload<ExtArgs>[]
      specialOffersSent: Prisma.$SpecialOrderOfferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string | null
      name: string
      email: string
      phoneNumber: string | null
      password: string | null
      avatarUrl: string | null
      preferences: string[]
      bio: string | null
      role: $Enums.Role | null
      brandName: string | null
      brandLogo: string | null
      googleId: string | null
      tokenVersion: number
      createdAt: Date
      updatedAt: Date
      authProviders: string[]
      lastLoginAt: Date | null
      loginMethod: string | null
      isEmailVerified: boolean
      emailVerificationToken: string | null
      emailVerificationExpiresAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends User$productsArgs<ExtArgs> = {}>(args?: Subset<T, User$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vendorReviewsReceived<T extends User$vendorReviewsReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$vendorReviewsReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vendorReviewsGiven<T extends User$vendorReviewsGivenArgs<ExtArgs> = {}>(args?: Subset<T, User$vendorReviewsGivenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productReviewsGiven<T extends User$productReviewsGivenArgs<ExtArgs> = {}>(args?: Subset<T, User$productReviewsGivenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customerOrders<T extends User$customerOrdersArgs<ExtArgs> = {}>(args?: Subset<T, User$customerOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vendorOrders<T extends User$vendorOrdersArgs<ExtArgs> = {}>(args?: Subset<T, User$vendorOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vendorRepliesSent<T extends User$vendorRepliesSentArgs<ExtArgs> = {}>(args?: Subset<T, User$vendorRepliesSentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorReplyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviewVotes<T extends User$reviewVotesArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewVotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviewReports<T extends User$reviewReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    loginHistory<T extends User$loginHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$loginHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoginHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    addresses<T extends User$addressesArgs<ExtArgs> = {}>(args?: Subset<T, User$addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    carts<T extends User$cartsArgs<ExtArgs> = {}>(args?: Subset<T, User$cartsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    UserPaymentMethod<T extends User$UserPaymentMethodArgs<ExtArgs> = {}>(args?: Subset<T, User$UserPaymentMethodArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPaymentMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deliveryPerson<T extends User$deliveryPersonArgs<ExtArgs> = {}>(args?: Subset<T, User$deliveryPersonArgs<ExtArgs>>): Prisma__DeliveryPersonClient<$Result.GetResult<Prisma.$DeliveryPersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    passwordResetToken<T extends User$passwordResetTokenArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordResetTokenArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payments<T extends User$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    RefundRequest<T extends User$RefundRequestArgs<ExtArgs> = {}>(args?: Subset<T, User$RefundRequestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vendorActivities<T extends User$vendorActivitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$vendorActivitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customerActivities<T extends User$customerActivitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$customerActivitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    followers<T extends User$followersArgs<ExtArgs> = {}>(args?: Subset<T, User$followersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorFollowerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    following<T extends User$followingArgs<ExtArgs> = {}>(args?: Subset<T, User$followingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorFollowerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    specialRequestsMade<T extends User$specialRequestsMadeArgs<ExtArgs> = {}>(args?: Subset<T, User$specialRequestsMadeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialOrderRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    specialRequestsReceived<T extends User$specialRequestsReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$specialRequestsReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialOrderRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    specialOffersSent<T extends User$specialOffersSentArgs<ExtArgs> = {}>(args?: Subset<T, User$specialOffersSentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialOrderOfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly preferences: FieldRef<"User", 'String[]'>
    readonly bio: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly brandName: FieldRef<"User", 'String'>
    readonly brandLogo: FieldRef<"User", 'String'>
    readonly googleId: FieldRef<"User", 'String'>
    readonly tokenVersion: FieldRef<"User", 'Int'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly authProviders: FieldRef<"User", 'String[]'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly loginMethod: FieldRef<"User", 'String'>
    readonly isEmailVerified: FieldRef<"User", 'Boolean'>
    readonly emailVerificationToken: FieldRef<"User", 'String'>
    readonly emailVerificationExpiresAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.products
   */
  export type User$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * User.vendorReviewsReceived
   */
  export type User$vendorReviewsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorReview
     */
    select?: VendorReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorReview
     */
    omit?: VendorReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorReviewInclude<ExtArgs> | null
    where?: VendorReviewWhereInput
    orderBy?: VendorReviewOrderByWithRelationInput | VendorReviewOrderByWithRelationInput[]
    cursor?: VendorReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorReviewScalarFieldEnum | VendorReviewScalarFieldEnum[]
  }

  /**
   * User.vendorReviewsGiven
   */
  export type User$vendorReviewsGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorReview
     */
    select?: VendorReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorReview
     */
    omit?: VendorReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorReviewInclude<ExtArgs> | null
    where?: VendorReviewWhereInput
    orderBy?: VendorReviewOrderByWithRelationInput | VendorReviewOrderByWithRelationInput[]
    cursor?: VendorReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorReviewScalarFieldEnum | VendorReviewScalarFieldEnum[]
  }

  /**
   * User.productReviewsGiven
   */
  export type User$productReviewsGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductReview
     */
    omit?: ProductReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
    where?: ProductReviewWhereInput
    orderBy?: ProductReviewOrderByWithRelationInput | ProductReviewOrderByWithRelationInput[]
    cursor?: ProductReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductReviewScalarFieldEnum | ProductReviewScalarFieldEnum[]
  }

  /**
   * User.customerOrders
   */
  export type User$customerOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.vendorOrders
   */
  export type User$vendorOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.vendorRepliesSent
   */
  export type User$vendorRepliesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorReply
     */
    select?: VendorReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorReply
     */
    omit?: VendorReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorReplyInclude<ExtArgs> | null
    where?: VendorReplyWhereInput
    orderBy?: VendorReplyOrderByWithRelationInput | VendorReplyOrderByWithRelationInput[]
    cursor?: VendorReplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorReplyScalarFieldEnum | VendorReplyScalarFieldEnum[]
  }

  /**
   * User.reviewVotes
   */
  export type User$reviewVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
    where?: ReviewVoteWhereInput
    orderBy?: ReviewVoteOrderByWithRelationInput | ReviewVoteOrderByWithRelationInput[]
    cursor?: ReviewVoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewVoteScalarFieldEnum | ReviewVoteScalarFieldEnum[]
  }

  /**
   * User.reviewReports
   */
  export type User$reviewReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReport
     */
    select?: ReviewReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReport
     */
    omit?: ReviewReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReportInclude<ExtArgs> | null
    where?: ReviewReportWhereInput
    orderBy?: ReviewReportOrderByWithRelationInput | ReviewReportOrderByWithRelationInput[]
    cursor?: ReviewReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewReportScalarFieldEnum | ReviewReportScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.loginHistory
   */
  export type User$loginHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginHistory
     */
    select?: LoginHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginHistory
     */
    omit?: LoginHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginHistoryInclude<ExtArgs> | null
    where?: LoginHistoryWhereInput
    orderBy?: LoginHistoryOrderByWithRelationInput | LoginHistoryOrderByWithRelationInput[]
    cursor?: LoginHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoginHistoryScalarFieldEnum | LoginHistoryScalarFieldEnum[]
  }

  /**
   * User.addresses
   */
  export type User$addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    cursor?: AddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * User.carts
   */
  export type User$cartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    where?: CartWhereInput
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    cursor?: CartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * User.UserPaymentMethod
   */
  export type User$UserPaymentMethodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPaymentMethod
     */
    select?: UserPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPaymentMethod
     */
    omit?: UserPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaymentMethodInclude<ExtArgs> | null
    where?: UserPaymentMethodWhereInput
    orderBy?: UserPaymentMethodOrderByWithRelationInput | UserPaymentMethodOrderByWithRelationInput[]
    cursor?: UserPaymentMethodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPaymentMethodScalarFieldEnum | UserPaymentMethodScalarFieldEnum[]
  }

  /**
   * User.deliveryPerson
   */
  export type User$deliveryPersonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPerson
     */
    select?: DeliveryPersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPerson
     */
    omit?: DeliveryPersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPersonInclude<ExtArgs> | null
    where?: DeliveryPersonWhereInput
  }

  /**
   * User.passwordResetToken
   */
  export type User$passwordResetTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    where?: PasswordResetTokenWhereInput
  }

  /**
   * User.payments
   */
  export type User$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User.RefundRequest
   */
  export type User$RefundRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequest
     */
    select?: RefundRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequest
     */
    omit?: RefundRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestInclude<ExtArgs> | null
    where?: RefundRequestWhereInput
    orderBy?: RefundRequestOrderByWithRelationInput | RefundRequestOrderByWithRelationInput[]
    cursor?: RefundRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefundRequestScalarFieldEnum | RefundRequestScalarFieldEnum[]
  }

  /**
   * User.vendorActivities
   */
  export type User$vendorActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * User.customerActivities
   */
  export type User$customerActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * User.followers
   */
  export type User$followersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorFollower
     */
    select?: VendorFollowerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorFollower
     */
    omit?: VendorFollowerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorFollowerInclude<ExtArgs> | null
    where?: VendorFollowerWhereInput
    orderBy?: VendorFollowerOrderByWithRelationInput | VendorFollowerOrderByWithRelationInput[]
    cursor?: VendorFollowerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorFollowerScalarFieldEnum | VendorFollowerScalarFieldEnum[]
  }

  /**
   * User.following
   */
  export type User$followingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorFollower
     */
    select?: VendorFollowerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorFollower
     */
    omit?: VendorFollowerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorFollowerInclude<ExtArgs> | null
    where?: VendorFollowerWhereInput
    orderBy?: VendorFollowerOrderByWithRelationInput | VendorFollowerOrderByWithRelationInput[]
    cursor?: VendorFollowerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorFollowerScalarFieldEnum | VendorFollowerScalarFieldEnum[]
  }

  /**
   * User.specialRequestsMade
   */
  export type User$specialRequestsMadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOrderRequest
     */
    select?: SpecialOrderRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOrderRequest
     */
    omit?: SpecialOrderRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialOrderRequestInclude<ExtArgs> | null
    where?: SpecialOrderRequestWhereInput
    orderBy?: SpecialOrderRequestOrderByWithRelationInput | SpecialOrderRequestOrderByWithRelationInput[]
    cursor?: SpecialOrderRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpecialOrderRequestScalarFieldEnum | SpecialOrderRequestScalarFieldEnum[]
  }

  /**
   * User.specialRequestsReceived
   */
  export type User$specialRequestsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOrderRequest
     */
    select?: SpecialOrderRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOrderRequest
     */
    omit?: SpecialOrderRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialOrderRequestInclude<ExtArgs> | null
    where?: SpecialOrderRequestWhereInput
    orderBy?: SpecialOrderRequestOrderByWithRelationInput | SpecialOrderRequestOrderByWithRelationInput[]
    cursor?: SpecialOrderRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpecialOrderRequestScalarFieldEnum | SpecialOrderRequestScalarFieldEnum[]
  }

  /**
   * User.specialOffersSent
   */
  export type User$specialOffersSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOrderOffer
     */
    select?: SpecialOrderOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOrderOffer
     */
    omit?: SpecialOrderOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialOrderOfferInclude<ExtArgs> | null
    where?: SpecialOrderOfferWhereInput
    orderBy?: SpecialOrderOfferOrderByWithRelationInput | SpecialOrderOfferOrderByWithRelationInput[]
    cursor?: SpecialOrderOfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpecialOrderOfferScalarFieldEnum | SpecialOrderOfferScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type AddressSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type AddressMinAggregateOutputType = {
    id: string | null
    userId: string | null
    label: string | null
    street: string | null
    city: string | null
    state: string | null
    country: string | null
    zipCode: string | null
    landmark: string | null
    latitude: number | null
    longitude: number | null
    isDefault: boolean | null
    createdAt: Date | null
  }

  export type AddressMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    label: string | null
    street: string | null
    city: string | null
    state: string | null
    country: string | null
    zipCode: string | null
    landmark: string | null
    latitude: number | null
    longitude: number | null
    isDefault: boolean | null
    createdAt: Date | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    userId: number
    label: number
    street: number
    city: number
    state: number
    country: number
    zipCode: number
    landmark: number
    latitude: number
    longitude: number
    isDefault: number
    createdAt: number
    _all: number
  }


  export type AddressAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type AddressSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type AddressMinAggregateInputType = {
    id?: true
    userId?: true
    label?: true
    street?: true
    city?: true
    state?: true
    country?: true
    zipCode?: true
    landmark?: true
    latitude?: true
    longitude?: true
    isDefault?: true
    createdAt?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    userId?: true
    label?: true
    street?: true
    city?: true
    state?: true
    country?: true
    zipCode?: true
    landmark?: true
    latitude?: true
    longitude?: true
    isDefault?: true
    createdAt?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    userId?: true
    label?: true
    street?: true
    city?: true
    state?: true
    country?: true
    zipCode?: true
    landmark?: true
    latitude?: true
    longitude?: true
    isDefault?: true
    createdAt?: true
    _all?: true
  }

  export type AddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Address to aggregate.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithAggregationInput | AddressOrderByWithAggregationInput[]
    by: AddressScalarFieldEnum[] | AddressScalarFieldEnum
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _avg?: AddressAvgAggregateInputType
    _sum?: AddressSumAggregateInputType
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }

  export type AddressGroupByOutputType = {
    id: string
    userId: string
    label: string
    street: string
    city: string
    state: string | null
    country: string
    zipCode: string | null
    landmark: string | null
    latitude: number | null
    longitude: number | null
    isDefault: boolean
    createdAt: Date
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    label?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    zipCode?: boolean
    landmark?: boolean
    latitude?: boolean
    longitude?: boolean
    isDefault?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    orders?: boolean | Address$ordersArgs<ExtArgs>
    _count?: boolean | AddressCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    label?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    zipCode?: boolean
    landmark?: boolean
    latitude?: boolean
    longitude?: boolean
    isDefault?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    label?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    zipCode?: boolean
    landmark?: boolean
    latitude?: boolean
    longitude?: boolean
    isDefault?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectScalar = {
    id?: boolean
    userId?: boolean
    label?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    zipCode?: boolean
    landmark?: boolean
    latitude?: boolean
    longitude?: boolean
    isDefault?: boolean
    createdAt?: boolean
  }

  export type AddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "label" | "street" | "city" | "state" | "country" | "zipCode" | "landmark" | "latitude" | "longitude" | "isDefault" | "createdAt", ExtArgs["result"]["address"]>
  export type AddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    orders?: boolean | Address$ordersArgs<ExtArgs>
    _count?: boolean | AddressCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Address"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      orders: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      label: string
      street: string
      city: string
      state: string | null
      country: string
      zipCode: string | null
      landmark: string | null
      latitude: number | null
      longitude: number | null
      isDefault: boolean
      createdAt: Date
    }, ExtArgs["result"]["address"]>
    composites: {}
  }

  type AddressGetPayload<S extends boolean | null | undefined | AddressDefaultArgs> = $Result.GetResult<Prisma.$AddressPayload, S>

  type AddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddressCountAggregateInputType | true
    }

  export interface AddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Address'], meta: { name: 'Address' } }
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddressFindUniqueArgs>(args: SelectSubset<T, AddressFindUniqueArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Address that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs>(args: SelectSubset<T, AddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddressFindFirstArgs>(args?: SelectSubset<T, AddressFindFirstArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs>(args?: SelectSubset<T, AddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddressFindManyArgs>(args?: SelectSubset<T, AddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
     */
    create<T extends AddressCreateArgs>(args: SelectSubset<T, AddressCreateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Addresses.
     * @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddressCreateManyArgs>(args?: SelectSubset<T, AddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Addresses and returns the data saved in the database.
     * @param {AddressCreateManyAndReturnArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddressCreateManyAndReturnArgs>(args?: SelectSubset<T, AddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
     */
    delete<T extends AddressDeleteArgs>(args: SelectSubset<T, AddressDeleteArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddressUpdateArgs>(args: SelectSubset<T, AddressUpdateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddressDeleteManyArgs>(args?: SelectSubset<T, AddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddressUpdateManyArgs>(args: SelectSubset<T, AddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses and returns the data updated in the database.
     * @param {AddressUpdateManyAndReturnArgs} args - Arguments to update many Addresses.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AddressUpdateManyAndReturnArgs>(args: SelectSubset<T, AddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
     */
    upsert<T extends AddressUpsertArgs>(args: SelectSubset<T, AddressUpsertArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Address model
   */
  readonly fields: AddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orders<T extends Address$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Address$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Address model
   */
  interface AddressFieldRefs {
    readonly id: FieldRef<"Address", 'String'>
    readonly userId: FieldRef<"Address", 'String'>
    readonly label: FieldRef<"Address", 'String'>
    readonly street: FieldRef<"Address", 'String'>
    readonly city: FieldRef<"Address", 'String'>
    readonly state: FieldRef<"Address", 'String'>
    readonly country: FieldRef<"Address", 'String'>
    readonly zipCode: FieldRef<"Address", 'String'>
    readonly landmark: FieldRef<"Address", 'String'>
    readonly latitude: FieldRef<"Address", 'Float'>
    readonly longitude: FieldRef<"Address", 'Float'>
    readonly isDefault: FieldRef<"Address", 'Boolean'>
    readonly createdAt: FieldRef<"Address", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findMany
   */
  export type AddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address create
   */
  export type AddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to create a Address.
     */
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }

  /**
   * Address createMany
   */
  export type AddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Address createManyAndReturn
   */
  export type AddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address update
   */
  export type AddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to update a Address.
     */
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
  }

  /**
   * Address updateManyAndReturn
   */
  export type AddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address upsert
   */
  export type AddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The filter to search for the Address to update in case it exists.
     */
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     */
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }

  /**
   * Address delete
   */
  export type AddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter which Address to delete.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to delete.
     */
    limit?: number
  }

  /**
   * Address.orders
   */
  export type Address$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Address without action
   */
  export type AddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    price: number | null
    averageRating: number | null
    reviewCount: number | null
    totalViews: number | null
    popularityScore: number | null
    popularityPercent: number | null
  }

  export type ProductSumAggregateOutputType = {
    price: number | null
    averageRating: number | null
    reviewCount: number | null
    totalViews: number | null
    popularityScore: number | null
    popularityPercent: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    archived: boolean | null
    category: $Enums.Category | null
    thumbnail: string | null
    vendorId: string | null
    averageRating: number | null
    reviewCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    totalViews: number | null
    popularityScore: number | null
    popularityUpdatedAt: Date | null
    popularityPercent: number | null
    isNew: boolean | null
    isLive: boolean | null
    liveUntil: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    archived: boolean | null
    category: $Enums.Category | null
    thumbnail: string | null
    vendorId: string | null
    averageRating: number | null
    reviewCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    totalViews: number | null
    popularityScore: number | null
    popularityUpdatedAt: Date | null
    popularityPercent: number | null
    isNew: boolean | null
    isLive: boolean | null
    liveUntil: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    description: number
    price: number
    archived: number
    category: number
    images: number
    thumbnail: number
    video: number
    vendorId: number
    averageRating: number
    reviewCount: number
    createdAt: number
    updatedAt: number
    totalViews: number
    popularityScore: number
    popularityUpdatedAt: number
    popularityPercent: number
    isNew: number
    isLive: number
    liveUntil: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    price?: true
    averageRating?: true
    reviewCount?: true
    totalViews?: true
    popularityScore?: true
    popularityPercent?: true
  }

  export type ProductSumAggregateInputType = {
    price?: true
    averageRating?: true
    reviewCount?: true
    totalViews?: true
    popularityScore?: true
    popularityPercent?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    archived?: true
    category?: true
    thumbnail?: true
    vendorId?: true
    averageRating?: true
    reviewCount?: true
    createdAt?: true
    updatedAt?: true
    totalViews?: true
    popularityScore?: true
    popularityUpdatedAt?: true
    popularityPercent?: true
    isNew?: true
    isLive?: true
    liveUntil?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    archived?: true
    category?: true
    thumbnail?: true
    vendorId?: true
    averageRating?: true
    reviewCount?: true
    createdAt?: true
    updatedAt?: true
    totalViews?: true
    popularityScore?: true
    popularityUpdatedAt?: true
    popularityPercent?: true
    isNew?: true
    isLive?: true
    liveUntil?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    archived?: true
    category?: true
    images?: true
    thumbnail?: true
    video?: true
    vendorId?: true
    averageRating?: true
    reviewCount?: true
    createdAt?: true
    updatedAt?: true
    totalViews?: true
    popularityScore?: true
    popularityUpdatedAt?: true
    popularityPercent?: true
    isNew?: true
    isLive?: true
    liveUntil?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    name: string
    description: string
    price: number
    archived: boolean
    category: $Enums.Category
    images: string[]
    thumbnail: string | null
    video: string[]
    vendorId: string
    averageRating: number | null
    reviewCount: number
    createdAt: Date
    updatedAt: Date
    totalViews: number
    popularityScore: number
    popularityUpdatedAt: Date | null
    popularityPercent: number
    isNew: boolean
    isLive: boolean
    liveUntil: Date | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    archived?: boolean
    category?: boolean
    images?: boolean
    thumbnail?: boolean
    video?: boolean
    vendorId?: boolean
    averageRating?: boolean
    reviewCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    totalViews?: boolean
    popularityScore?: boolean
    popularityUpdatedAt?: boolean
    popularityPercent?: boolean
    isNew?: boolean
    isLive?: boolean
    liveUntil?: boolean
    vendor?: boolean | UserDefaultArgs<ExtArgs>
    reviews?: boolean | Product$reviewsArgs<ExtArgs>
    orders?: boolean | Product$ordersArgs<ExtArgs>
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    options?: boolean | Product$optionsArgs<ExtArgs>
    CartItem?: boolean | Product$CartItemArgs<ExtArgs>
    specialRequests?: boolean | Product$specialRequestsArgs<ExtArgs>
    productSchedule?: boolean | Product$productScheduleArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    archived?: boolean
    category?: boolean
    images?: boolean
    thumbnail?: boolean
    video?: boolean
    vendorId?: boolean
    averageRating?: boolean
    reviewCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    totalViews?: boolean
    popularityScore?: boolean
    popularityUpdatedAt?: boolean
    popularityPercent?: boolean
    isNew?: boolean
    isLive?: boolean
    liveUntil?: boolean
    vendor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    archived?: boolean
    category?: boolean
    images?: boolean
    thumbnail?: boolean
    video?: boolean
    vendorId?: boolean
    averageRating?: boolean
    reviewCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    totalViews?: boolean
    popularityScore?: boolean
    popularityUpdatedAt?: boolean
    popularityPercent?: boolean
    isNew?: boolean
    isLive?: boolean
    liveUntil?: boolean
    vendor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    archived?: boolean
    category?: boolean
    images?: boolean
    thumbnail?: boolean
    video?: boolean
    vendorId?: boolean
    averageRating?: boolean
    reviewCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    totalViews?: boolean
    popularityScore?: boolean
    popularityUpdatedAt?: boolean
    popularityPercent?: boolean
    isNew?: boolean
    isLive?: boolean
    liveUntil?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "price" | "archived" | "category" | "images" | "thumbnail" | "video" | "vendorId" | "averageRating" | "reviewCount" | "createdAt" | "updatedAt" | "totalViews" | "popularityScore" | "popularityUpdatedAt" | "popularityPercent" | "isNew" | "isLive" | "liveUntil", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | UserDefaultArgs<ExtArgs>
    reviews?: boolean | Product$reviewsArgs<ExtArgs>
    orders?: boolean | Product$ordersArgs<ExtArgs>
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    options?: boolean | Product$optionsArgs<ExtArgs>
    CartItem?: boolean | Product$CartItemArgs<ExtArgs>
    specialRequests?: boolean | Product$specialRequestsArgs<ExtArgs>
    productSchedule?: boolean | Product$productScheduleArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      vendor: Prisma.$UserPayload<ExtArgs>
      reviews: Prisma.$ProductReviewPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
      options: Prisma.$ProductOptionPayload<ExtArgs>[]
      CartItem: Prisma.$CartItemPayload<ExtArgs>[]
      specialRequests: Prisma.$SpecialOrderRequestPayload<ExtArgs>[]
      productSchedule: Prisma.$ProductSchedulePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      price: number
      archived: boolean
      category: $Enums.Category
      images: string[]
      thumbnail: string | null
      video: string[]
      vendorId: string
      averageRating: number | null
      reviewCount: number
      createdAt: Date
      updatedAt: Date
      totalViews: number
      popularityScore: number
      popularityUpdatedAt: Date | null
      popularityPercent: number
      isNew: boolean
      isLive: boolean
      liveUntil: Date | null
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reviews<T extends Product$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Product$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends Product$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Product$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderItems<T extends Product$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    options<T extends Product$optionsArgs<ExtArgs> = {}>(args?: Subset<T, Product$optionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CartItem<T extends Product$CartItemArgs<ExtArgs> = {}>(args?: Subset<T, Product$CartItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    specialRequests<T extends Product$specialRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Product$specialRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialOrderRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productSchedule<T extends Product$productScheduleArgs<ExtArgs> = {}>(args?: Subset<T, Product$productScheduleArgs<ExtArgs>>): Prisma__ProductScheduleClient<$Result.GetResult<Prisma.$ProductSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Float'>
    readonly archived: FieldRef<"Product", 'Boolean'>
    readonly category: FieldRef<"Product", 'Category'>
    readonly images: FieldRef<"Product", 'String[]'>
    readonly thumbnail: FieldRef<"Product", 'String'>
    readonly video: FieldRef<"Product", 'String[]'>
    readonly vendorId: FieldRef<"Product", 'String'>
    readonly averageRating: FieldRef<"Product", 'Float'>
    readonly reviewCount: FieldRef<"Product", 'Int'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
    readonly totalViews: FieldRef<"Product", 'Int'>
    readonly popularityScore: FieldRef<"Product", 'Float'>
    readonly popularityUpdatedAt: FieldRef<"Product", 'DateTime'>
    readonly popularityPercent: FieldRef<"Product", 'Float'>
    readonly isNew: FieldRef<"Product", 'Boolean'>
    readonly isLive: FieldRef<"Product", 'Boolean'>
    readonly liveUntil: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.reviews
   */
  export type Product$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductReview
     */
    omit?: ProductReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
    where?: ProductReviewWhereInput
    orderBy?: ProductReviewOrderByWithRelationInput | ProductReviewOrderByWithRelationInput[]
    cursor?: ProductReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductReviewScalarFieldEnum | ProductReviewScalarFieldEnum[]
  }

  /**
   * Product.orders
   */
  export type Product$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Product.orderItems
   */
  export type Product$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Product.options
   */
  export type Product$optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOption
     */
    select?: ProductOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOption
     */
    omit?: ProductOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionInclude<ExtArgs> | null
    where?: ProductOptionWhereInput
    orderBy?: ProductOptionOrderByWithRelationInput | ProductOptionOrderByWithRelationInput[]
    cursor?: ProductOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductOptionScalarFieldEnum | ProductOptionScalarFieldEnum[]
  }

  /**
   * Product.CartItem
   */
  export type Product$CartItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    cursor?: CartItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * Product.specialRequests
   */
  export type Product$specialRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOrderRequest
     */
    select?: SpecialOrderRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOrderRequest
     */
    omit?: SpecialOrderRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialOrderRequestInclude<ExtArgs> | null
    where?: SpecialOrderRequestWhereInput
    orderBy?: SpecialOrderRequestOrderByWithRelationInput | SpecialOrderRequestOrderByWithRelationInput[]
    cursor?: SpecialOrderRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpecialOrderRequestScalarFieldEnum | SpecialOrderRequestScalarFieldEnum[]
  }

  /**
   * Product.productSchedule
   */
  export type Product$productScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSchedule
     */
    select?: ProductScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSchedule
     */
    omit?: ProductScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductScheduleInclude<ExtArgs> | null
    where?: ProductScheduleWhereInput
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model ProductSchedule
   */

  export type AggregateProductSchedule = {
    _count: ProductScheduleCountAggregateOutputType | null
    _avg: ProductScheduleAvgAggregateOutputType | null
    _sum: ProductScheduleSumAggregateOutputType | null
    _min: ProductScheduleMinAggregateOutputType | null
    _max: ProductScheduleMaxAggregateOutputType | null
  }

  export type ProductScheduleAvgAggregateOutputType = {
    graceMinutes: number | null
  }

  export type ProductScheduleSumAggregateOutputType = {
    graceMinutes: number | null
  }

  export type ProductScheduleMinAggregateOutputType = {
    id: string | null
    productId: string | null
    goLiveAt: Date | null
    takeDownAt: Date | null
    isLive: boolean | null
    graceMinutes: number | null
    autoGraceEnabled: boolean | null
    manualGraceEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductScheduleMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    goLiveAt: Date | null
    takeDownAt: Date | null
    isLive: boolean | null
    graceMinutes: number | null
    autoGraceEnabled: boolean | null
    manualGraceEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductScheduleCountAggregateOutputType = {
    id: number
    productId: number
    goLiveAt: number
    takeDownAt: number
    isLive: number
    graceMinutes: number
    autoGraceEnabled: number
    manualGraceEnabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductScheduleAvgAggregateInputType = {
    graceMinutes?: true
  }

  export type ProductScheduleSumAggregateInputType = {
    graceMinutes?: true
  }

  export type ProductScheduleMinAggregateInputType = {
    id?: true
    productId?: true
    goLiveAt?: true
    takeDownAt?: true
    isLive?: true
    graceMinutes?: true
    autoGraceEnabled?: true
    manualGraceEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductScheduleMaxAggregateInputType = {
    id?: true
    productId?: true
    goLiveAt?: true
    takeDownAt?: true
    isLive?: true
    graceMinutes?: true
    autoGraceEnabled?: true
    manualGraceEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductScheduleCountAggregateInputType = {
    id?: true
    productId?: true
    goLiveAt?: true
    takeDownAt?: true
    isLive?: true
    graceMinutes?: true
    autoGraceEnabled?: true
    manualGraceEnabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductSchedule to aggregate.
     */
    where?: ProductScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSchedules to fetch.
     */
    orderBy?: ProductScheduleOrderByWithRelationInput | ProductScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductSchedules
    **/
    _count?: true | ProductScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductScheduleMaxAggregateInputType
  }

  export type GetProductScheduleAggregateType<T extends ProductScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateProductSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductSchedule[P]>
      : GetScalarType<T[P], AggregateProductSchedule[P]>
  }




  export type ProductScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductScheduleWhereInput
    orderBy?: ProductScheduleOrderByWithAggregationInput | ProductScheduleOrderByWithAggregationInput[]
    by: ProductScheduleScalarFieldEnum[] | ProductScheduleScalarFieldEnum
    having?: ProductScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductScheduleCountAggregateInputType | true
    _avg?: ProductScheduleAvgAggregateInputType
    _sum?: ProductScheduleSumAggregateInputType
    _min?: ProductScheduleMinAggregateInputType
    _max?: ProductScheduleMaxAggregateInputType
  }

  export type ProductScheduleGroupByOutputType = {
    id: string
    productId: string
    goLiveAt: Date | null
    takeDownAt: Date | null
    isLive: boolean
    graceMinutes: number | null
    autoGraceEnabled: boolean
    manualGraceEnabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductScheduleCountAggregateOutputType | null
    _avg: ProductScheduleAvgAggregateOutputType | null
    _sum: ProductScheduleSumAggregateOutputType | null
    _min: ProductScheduleMinAggregateOutputType | null
    _max: ProductScheduleMaxAggregateOutputType | null
  }

  type GetProductScheduleGroupByPayload<T extends ProductScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], ProductScheduleGroupByOutputType[P]>
        }
      >
    >


  export type ProductScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    goLiveAt?: boolean
    takeDownAt?: boolean
    isLive?: boolean
    graceMinutes?: boolean
    autoGraceEnabled?: boolean
    manualGraceEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productSchedule"]>

  export type ProductScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    goLiveAt?: boolean
    takeDownAt?: boolean
    isLive?: boolean
    graceMinutes?: boolean
    autoGraceEnabled?: boolean
    manualGraceEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productSchedule"]>

  export type ProductScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    goLiveAt?: boolean
    takeDownAt?: boolean
    isLive?: boolean
    graceMinutes?: boolean
    autoGraceEnabled?: boolean
    manualGraceEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productSchedule"]>

  export type ProductScheduleSelectScalar = {
    id?: boolean
    productId?: boolean
    goLiveAt?: boolean
    takeDownAt?: boolean
    isLive?: boolean
    graceMinutes?: boolean
    autoGraceEnabled?: boolean
    manualGraceEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "goLiveAt" | "takeDownAt" | "isLive" | "graceMinutes" | "autoGraceEnabled" | "manualGraceEnabled" | "createdAt" | "updatedAt", ExtArgs["result"]["productSchedule"]>
  export type ProductScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductScheduleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductSchedule"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      goLiveAt: Date | null
      takeDownAt: Date | null
      isLive: boolean
      graceMinutes: number | null
      autoGraceEnabled: boolean
      manualGraceEnabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productSchedule"]>
    composites: {}
  }

  type ProductScheduleGetPayload<S extends boolean | null | undefined | ProductScheduleDefaultArgs> = $Result.GetResult<Prisma.$ProductSchedulePayload, S>

  type ProductScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductScheduleCountAggregateInputType | true
    }

  export interface ProductScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductSchedule'], meta: { name: 'ProductSchedule' } }
    /**
     * Find zero or one ProductSchedule that matches the filter.
     * @param {ProductScheduleFindUniqueArgs} args - Arguments to find a ProductSchedule
     * @example
     * // Get one ProductSchedule
     * const productSchedule = await prisma.productSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductScheduleFindUniqueArgs>(args: SelectSubset<T, ProductScheduleFindUniqueArgs<ExtArgs>>): Prisma__ProductScheduleClient<$Result.GetResult<Prisma.$ProductSchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductSchedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductScheduleFindUniqueOrThrowArgs} args - Arguments to find a ProductSchedule
     * @example
     * // Get one ProductSchedule
     * const productSchedule = await prisma.productSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductScheduleClient<$Result.GetResult<Prisma.$ProductSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductScheduleFindFirstArgs} args - Arguments to find a ProductSchedule
     * @example
     * // Get one ProductSchedule
     * const productSchedule = await prisma.productSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductScheduleFindFirstArgs>(args?: SelectSubset<T, ProductScheduleFindFirstArgs<ExtArgs>>): Prisma__ProductScheduleClient<$Result.GetResult<Prisma.$ProductSchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductScheduleFindFirstOrThrowArgs} args - Arguments to find a ProductSchedule
     * @example
     * // Get one ProductSchedule
     * const productSchedule = await prisma.productSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductScheduleClient<$Result.GetResult<Prisma.$ProductSchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductSchedules
     * const productSchedules = await prisma.productSchedule.findMany()
     * 
     * // Get first 10 ProductSchedules
     * const productSchedules = await prisma.productSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productScheduleWithIdOnly = await prisma.productSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductScheduleFindManyArgs>(args?: SelectSubset<T, ProductScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductSchedule.
     * @param {ProductScheduleCreateArgs} args - Arguments to create a ProductSchedule.
     * @example
     * // Create one ProductSchedule
     * const ProductSchedule = await prisma.productSchedule.create({
     *   data: {
     *     // ... data to create a ProductSchedule
     *   }
     * })
     * 
     */
    create<T extends ProductScheduleCreateArgs>(args: SelectSubset<T, ProductScheduleCreateArgs<ExtArgs>>): Prisma__ProductScheduleClient<$Result.GetResult<Prisma.$ProductSchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductSchedules.
     * @param {ProductScheduleCreateManyArgs} args - Arguments to create many ProductSchedules.
     * @example
     * // Create many ProductSchedules
     * const productSchedule = await prisma.productSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductScheduleCreateManyArgs>(args?: SelectSubset<T, ProductScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductSchedules and returns the data saved in the database.
     * @param {ProductScheduleCreateManyAndReturnArgs} args - Arguments to create many ProductSchedules.
     * @example
     * // Create many ProductSchedules
     * const productSchedule = await prisma.productSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductSchedules and only return the `id`
     * const productScheduleWithIdOnly = await prisma.productSchedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductSchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductSchedule.
     * @param {ProductScheduleDeleteArgs} args - Arguments to delete one ProductSchedule.
     * @example
     * // Delete one ProductSchedule
     * const ProductSchedule = await prisma.productSchedule.delete({
     *   where: {
     *     // ... filter to delete one ProductSchedule
     *   }
     * })
     * 
     */
    delete<T extends ProductScheduleDeleteArgs>(args: SelectSubset<T, ProductScheduleDeleteArgs<ExtArgs>>): Prisma__ProductScheduleClient<$Result.GetResult<Prisma.$ProductSchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductSchedule.
     * @param {ProductScheduleUpdateArgs} args - Arguments to update one ProductSchedule.
     * @example
     * // Update one ProductSchedule
     * const productSchedule = await prisma.productSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductScheduleUpdateArgs>(args: SelectSubset<T, ProductScheduleUpdateArgs<ExtArgs>>): Prisma__ProductScheduleClient<$Result.GetResult<Prisma.$ProductSchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductSchedules.
     * @param {ProductScheduleDeleteManyArgs} args - Arguments to filter ProductSchedules to delete.
     * @example
     * // Delete a few ProductSchedules
     * const { count } = await prisma.productSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductScheduleDeleteManyArgs>(args?: SelectSubset<T, ProductScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductSchedules
     * const productSchedule = await prisma.productSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductScheduleUpdateManyArgs>(args: SelectSubset<T, ProductScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductSchedules and returns the data updated in the database.
     * @param {ProductScheduleUpdateManyAndReturnArgs} args - Arguments to update many ProductSchedules.
     * @example
     * // Update many ProductSchedules
     * const productSchedule = await prisma.productSchedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductSchedules and only return the `id`
     * const productScheduleWithIdOnly = await prisma.productSchedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductSchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductSchedule.
     * @param {ProductScheduleUpsertArgs} args - Arguments to update or create a ProductSchedule.
     * @example
     * // Update or create a ProductSchedule
     * const productSchedule = await prisma.productSchedule.upsert({
     *   create: {
     *     // ... data to create a ProductSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductSchedule we want to update
     *   }
     * })
     */
    upsert<T extends ProductScheduleUpsertArgs>(args: SelectSubset<T, ProductScheduleUpsertArgs<ExtArgs>>): Prisma__ProductScheduleClient<$Result.GetResult<Prisma.$ProductSchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductScheduleCountArgs} args - Arguments to filter ProductSchedules to count.
     * @example
     * // Count the number of ProductSchedules
     * const count = await prisma.productSchedule.count({
     *   where: {
     *     // ... the filter for the ProductSchedules we want to count
     *   }
     * })
    **/
    count<T extends ProductScheduleCountArgs>(
      args?: Subset<T, ProductScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductScheduleAggregateArgs>(args: Subset<T, ProductScheduleAggregateArgs>): Prisma.PrismaPromise<GetProductScheduleAggregateType<T>>

    /**
     * Group by ProductSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductScheduleGroupByArgs['orderBy'] }
        : { orderBy?: ProductScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductSchedule model
   */
  readonly fields: ProductScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductSchedule model
   */
  interface ProductScheduleFieldRefs {
    readonly id: FieldRef<"ProductSchedule", 'String'>
    readonly productId: FieldRef<"ProductSchedule", 'String'>
    readonly goLiveAt: FieldRef<"ProductSchedule", 'DateTime'>
    readonly takeDownAt: FieldRef<"ProductSchedule", 'DateTime'>
    readonly isLive: FieldRef<"ProductSchedule", 'Boolean'>
    readonly graceMinutes: FieldRef<"ProductSchedule", 'Int'>
    readonly autoGraceEnabled: FieldRef<"ProductSchedule", 'Boolean'>
    readonly manualGraceEnabled: FieldRef<"ProductSchedule", 'Boolean'>
    readonly createdAt: FieldRef<"ProductSchedule", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductSchedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductSchedule findUnique
   */
  export type ProductScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSchedule
     */
    select?: ProductScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSchedule
     */
    omit?: ProductScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ProductSchedule to fetch.
     */
    where: ProductScheduleWhereUniqueInput
  }

  /**
   * ProductSchedule findUniqueOrThrow
   */
  export type ProductScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSchedule
     */
    select?: ProductScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSchedule
     */
    omit?: ProductScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ProductSchedule to fetch.
     */
    where: ProductScheduleWhereUniqueInput
  }

  /**
   * ProductSchedule findFirst
   */
  export type ProductScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSchedule
     */
    select?: ProductScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSchedule
     */
    omit?: ProductScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ProductSchedule to fetch.
     */
    where?: ProductScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSchedules to fetch.
     */
    orderBy?: ProductScheduleOrderByWithRelationInput | ProductScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductSchedules.
     */
    cursor?: ProductScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductSchedules.
     */
    distinct?: ProductScheduleScalarFieldEnum | ProductScheduleScalarFieldEnum[]
  }

  /**
   * ProductSchedule findFirstOrThrow
   */
  export type ProductScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSchedule
     */
    select?: ProductScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSchedule
     */
    omit?: ProductScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ProductSchedule to fetch.
     */
    where?: ProductScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSchedules to fetch.
     */
    orderBy?: ProductScheduleOrderByWithRelationInput | ProductScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductSchedules.
     */
    cursor?: ProductScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductSchedules.
     */
    distinct?: ProductScheduleScalarFieldEnum | ProductScheduleScalarFieldEnum[]
  }

  /**
   * ProductSchedule findMany
   */
  export type ProductScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSchedule
     */
    select?: ProductScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSchedule
     */
    omit?: ProductScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ProductSchedules to fetch.
     */
    where?: ProductScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSchedules to fetch.
     */
    orderBy?: ProductScheduleOrderByWithRelationInput | ProductScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductSchedules.
     */
    cursor?: ProductScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSchedules.
     */
    skip?: number
    distinct?: ProductScheduleScalarFieldEnum | ProductScheduleScalarFieldEnum[]
  }

  /**
   * ProductSchedule create
   */
  export type ProductScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSchedule
     */
    select?: ProductScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSchedule
     */
    omit?: ProductScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductSchedule.
     */
    data: XOR<ProductScheduleCreateInput, ProductScheduleUncheckedCreateInput>
  }

  /**
   * ProductSchedule createMany
   */
  export type ProductScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductSchedules.
     */
    data: ProductScheduleCreateManyInput | ProductScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductSchedule createManyAndReturn
   */
  export type ProductScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSchedule
     */
    select?: ProductScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSchedule
     */
    omit?: ProductScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many ProductSchedules.
     */
    data: ProductScheduleCreateManyInput | ProductScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductSchedule update
   */
  export type ProductScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSchedule
     */
    select?: ProductScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSchedule
     */
    omit?: ProductScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductSchedule.
     */
    data: XOR<ProductScheduleUpdateInput, ProductScheduleUncheckedUpdateInput>
    /**
     * Choose, which ProductSchedule to update.
     */
    where: ProductScheduleWhereUniqueInput
  }

  /**
   * ProductSchedule updateMany
   */
  export type ProductScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductSchedules.
     */
    data: XOR<ProductScheduleUpdateManyMutationInput, ProductScheduleUncheckedUpdateManyInput>
    /**
     * Filter which ProductSchedules to update
     */
    where?: ProductScheduleWhereInput
    /**
     * Limit how many ProductSchedules to update.
     */
    limit?: number
  }

  /**
   * ProductSchedule updateManyAndReturn
   */
  export type ProductScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSchedule
     */
    select?: ProductScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSchedule
     */
    omit?: ProductScheduleOmit<ExtArgs> | null
    /**
     * The data used to update ProductSchedules.
     */
    data: XOR<ProductScheduleUpdateManyMutationInput, ProductScheduleUncheckedUpdateManyInput>
    /**
     * Filter which ProductSchedules to update
     */
    where?: ProductScheduleWhereInput
    /**
     * Limit how many ProductSchedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductScheduleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductSchedule upsert
   */
  export type ProductScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSchedule
     */
    select?: ProductScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSchedule
     */
    omit?: ProductScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductSchedule to update in case it exists.
     */
    where: ProductScheduleWhereUniqueInput
    /**
     * In case the ProductSchedule found by the `where` argument doesn't exist, create a new ProductSchedule with this data.
     */
    create: XOR<ProductScheduleCreateInput, ProductScheduleUncheckedCreateInput>
    /**
     * In case the ProductSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductScheduleUpdateInput, ProductScheduleUncheckedUpdateInput>
  }

  /**
   * ProductSchedule delete
   */
  export type ProductScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSchedule
     */
    select?: ProductScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSchedule
     */
    omit?: ProductScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductScheduleInclude<ExtArgs> | null
    /**
     * Filter which ProductSchedule to delete.
     */
    where: ProductScheduleWhereUniqueInput
  }

  /**
   * ProductSchedule deleteMany
   */
  export type ProductScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductSchedules to delete
     */
    where?: ProductScheduleWhereInput
    /**
     * Limit how many ProductSchedules to delete.
     */
    limit?: number
  }

  /**
   * ProductSchedule without action
   */
  export type ProductScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSchedule
     */
    select?: ProductScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSchedule
     */
    omit?: ProductScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductScheduleInclude<ExtArgs> | null
  }


  /**
   * Model ProductOption
   */

  export type AggregateProductOption = {
    _count: ProductOptionCountAggregateOutputType | null
    _avg: ProductOptionAvgAggregateOutputType | null
    _sum: ProductOptionSumAggregateOutputType | null
    _min: ProductOptionMinAggregateOutputType | null
    _max: ProductOptionMaxAggregateOutputType | null
  }

  export type ProductOptionAvgAggregateOutputType = {
    price: number | null
  }

  export type ProductOptionSumAggregateOutputType = {
    price: number | null
  }

  export type ProductOptionMinAggregateOutputType = {
    id: string | null
    productId: string | null
    name: string | null
    price: number | null
  }

  export type ProductOptionMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    name: string | null
    price: number | null
  }

  export type ProductOptionCountAggregateOutputType = {
    id: number
    productId: number
    name: number
    price: number
    _all: number
  }


  export type ProductOptionAvgAggregateInputType = {
    price?: true
  }

  export type ProductOptionSumAggregateInputType = {
    price?: true
  }

  export type ProductOptionMinAggregateInputType = {
    id?: true
    productId?: true
    name?: true
    price?: true
  }

  export type ProductOptionMaxAggregateInputType = {
    id?: true
    productId?: true
    name?: true
    price?: true
  }

  export type ProductOptionCountAggregateInputType = {
    id?: true
    productId?: true
    name?: true
    price?: true
    _all?: true
  }

  export type ProductOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductOption to aggregate.
     */
    where?: ProductOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductOptions to fetch.
     */
    orderBy?: ProductOptionOrderByWithRelationInput | ProductOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductOptions
    **/
    _count?: true | ProductOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductOptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductOptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductOptionMaxAggregateInputType
  }

  export type GetProductOptionAggregateType<T extends ProductOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateProductOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductOption[P]>
      : GetScalarType<T[P], AggregateProductOption[P]>
  }




  export type ProductOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductOptionWhereInput
    orderBy?: ProductOptionOrderByWithAggregationInput | ProductOptionOrderByWithAggregationInput[]
    by: ProductOptionScalarFieldEnum[] | ProductOptionScalarFieldEnum
    having?: ProductOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductOptionCountAggregateInputType | true
    _avg?: ProductOptionAvgAggregateInputType
    _sum?: ProductOptionSumAggregateInputType
    _min?: ProductOptionMinAggregateInputType
    _max?: ProductOptionMaxAggregateInputType
  }

  export type ProductOptionGroupByOutputType = {
    id: string
    productId: string
    name: string
    price: number
    _count: ProductOptionCountAggregateOutputType | null
    _avg: ProductOptionAvgAggregateOutputType | null
    _sum: ProductOptionSumAggregateOutputType | null
    _min: ProductOptionMinAggregateOutputType | null
    _max: ProductOptionMaxAggregateOutputType | null
  }

  type GetProductOptionGroupByPayload<T extends ProductOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductOptionGroupByOutputType[P]>
            : GetScalarType<T[P], ProductOptionGroupByOutputType[P]>
        }
      >
    >


  export type ProductOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    name?: boolean
    price?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    OrderItemOption?: boolean | ProductOption$OrderItemOptionArgs<ExtArgs>
    CartItemOption?: boolean | ProductOption$CartItemOptionArgs<ExtArgs>
    _count?: boolean | ProductOptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productOption"]>

  export type ProductOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    name?: boolean
    price?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productOption"]>

  export type ProductOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    name?: boolean
    price?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productOption"]>

  export type ProductOptionSelectScalar = {
    id?: boolean
    productId?: boolean
    name?: boolean
    price?: boolean
  }

  export type ProductOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "name" | "price", ExtArgs["result"]["productOption"]>
  export type ProductOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    OrderItemOption?: boolean | ProductOption$OrderItemOptionArgs<ExtArgs>
    CartItemOption?: boolean | ProductOption$CartItemOptionArgs<ExtArgs>
    _count?: boolean | ProductOptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductOptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductOption"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      OrderItemOption: Prisma.$OrderItemOptionPayload<ExtArgs>[]
      CartItemOption: Prisma.$CartItemOptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      name: string
      price: number
    }, ExtArgs["result"]["productOption"]>
    composites: {}
  }

  type ProductOptionGetPayload<S extends boolean | null | undefined | ProductOptionDefaultArgs> = $Result.GetResult<Prisma.$ProductOptionPayload, S>

  type ProductOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductOptionCountAggregateInputType | true
    }

  export interface ProductOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductOption'], meta: { name: 'ProductOption' } }
    /**
     * Find zero or one ProductOption that matches the filter.
     * @param {ProductOptionFindUniqueArgs} args - Arguments to find a ProductOption
     * @example
     * // Get one ProductOption
     * const productOption = await prisma.productOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductOptionFindUniqueArgs>(args: SelectSubset<T, ProductOptionFindUniqueArgs<ExtArgs>>): Prisma__ProductOptionClient<$Result.GetResult<Prisma.$ProductOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductOptionFindUniqueOrThrowArgs} args - Arguments to find a ProductOption
     * @example
     * // Get one ProductOption
     * const productOption = await prisma.productOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductOptionClient<$Result.GetResult<Prisma.$ProductOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductOptionFindFirstArgs} args - Arguments to find a ProductOption
     * @example
     * // Get one ProductOption
     * const productOption = await prisma.productOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductOptionFindFirstArgs>(args?: SelectSubset<T, ProductOptionFindFirstArgs<ExtArgs>>): Prisma__ProductOptionClient<$Result.GetResult<Prisma.$ProductOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductOptionFindFirstOrThrowArgs} args - Arguments to find a ProductOption
     * @example
     * // Get one ProductOption
     * const productOption = await prisma.productOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductOptionClient<$Result.GetResult<Prisma.$ProductOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductOptions
     * const productOptions = await prisma.productOption.findMany()
     * 
     * // Get first 10 ProductOptions
     * const productOptions = await prisma.productOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productOptionWithIdOnly = await prisma.productOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductOptionFindManyArgs>(args?: SelectSubset<T, ProductOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductOption.
     * @param {ProductOptionCreateArgs} args - Arguments to create a ProductOption.
     * @example
     * // Create one ProductOption
     * const ProductOption = await prisma.productOption.create({
     *   data: {
     *     // ... data to create a ProductOption
     *   }
     * })
     * 
     */
    create<T extends ProductOptionCreateArgs>(args: SelectSubset<T, ProductOptionCreateArgs<ExtArgs>>): Prisma__ProductOptionClient<$Result.GetResult<Prisma.$ProductOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductOptions.
     * @param {ProductOptionCreateManyArgs} args - Arguments to create many ProductOptions.
     * @example
     * // Create many ProductOptions
     * const productOption = await prisma.productOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductOptionCreateManyArgs>(args?: SelectSubset<T, ProductOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductOptions and returns the data saved in the database.
     * @param {ProductOptionCreateManyAndReturnArgs} args - Arguments to create many ProductOptions.
     * @example
     * // Create many ProductOptions
     * const productOption = await prisma.productOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductOptions and only return the `id`
     * const productOptionWithIdOnly = await prisma.productOption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductOption.
     * @param {ProductOptionDeleteArgs} args - Arguments to delete one ProductOption.
     * @example
     * // Delete one ProductOption
     * const ProductOption = await prisma.productOption.delete({
     *   where: {
     *     // ... filter to delete one ProductOption
     *   }
     * })
     * 
     */
    delete<T extends ProductOptionDeleteArgs>(args: SelectSubset<T, ProductOptionDeleteArgs<ExtArgs>>): Prisma__ProductOptionClient<$Result.GetResult<Prisma.$ProductOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductOption.
     * @param {ProductOptionUpdateArgs} args - Arguments to update one ProductOption.
     * @example
     * // Update one ProductOption
     * const productOption = await prisma.productOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductOptionUpdateArgs>(args: SelectSubset<T, ProductOptionUpdateArgs<ExtArgs>>): Prisma__ProductOptionClient<$Result.GetResult<Prisma.$ProductOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductOptions.
     * @param {ProductOptionDeleteManyArgs} args - Arguments to filter ProductOptions to delete.
     * @example
     * // Delete a few ProductOptions
     * const { count } = await prisma.productOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductOptionDeleteManyArgs>(args?: SelectSubset<T, ProductOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductOptions
     * const productOption = await prisma.productOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductOptionUpdateManyArgs>(args: SelectSubset<T, ProductOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductOptions and returns the data updated in the database.
     * @param {ProductOptionUpdateManyAndReturnArgs} args - Arguments to update many ProductOptions.
     * @example
     * // Update many ProductOptions
     * const productOption = await prisma.productOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductOptions and only return the `id`
     * const productOptionWithIdOnly = await prisma.productOption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductOption.
     * @param {ProductOptionUpsertArgs} args - Arguments to update or create a ProductOption.
     * @example
     * // Update or create a ProductOption
     * const productOption = await prisma.productOption.upsert({
     *   create: {
     *     // ... data to create a ProductOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductOption we want to update
     *   }
     * })
     */
    upsert<T extends ProductOptionUpsertArgs>(args: SelectSubset<T, ProductOptionUpsertArgs<ExtArgs>>): Prisma__ProductOptionClient<$Result.GetResult<Prisma.$ProductOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductOptionCountArgs} args - Arguments to filter ProductOptions to count.
     * @example
     * // Count the number of ProductOptions
     * const count = await prisma.productOption.count({
     *   where: {
     *     // ... the filter for the ProductOptions we want to count
     *   }
     * })
    **/
    count<T extends ProductOptionCountArgs>(
      args?: Subset<T, ProductOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductOptionAggregateArgs>(args: Subset<T, ProductOptionAggregateArgs>): Prisma.PrismaPromise<GetProductOptionAggregateType<T>>

    /**
     * Group by ProductOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductOptionGroupByArgs['orderBy'] }
        : { orderBy?: ProductOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductOption model
   */
  readonly fields: ProductOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    OrderItemOption<T extends ProductOption$OrderItemOptionArgs<ExtArgs> = {}>(args?: Subset<T, ProductOption$OrderItemOptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CartItemOption<T extends ProductOption$CartItemOptionArgs<ExtArgs> = {}>(args?: Subset<T, ProductOption$CartItemOptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductOption model
   */
  interface ProductOptionFieldRefs {
    readonly id: FieldRef<"ProductOption", 'String'>
    readonly productId: FieldRef<"ProductOption", 'String'>
    readonly name: FieldRef<"ProductOption", 'String'>
    readonly price: FieldRef<"ProductOption", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * ProductOption findUnique
   */
  export type ProductOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOption
     */
    select?: ProductOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOption
     */
    omit?: ProductOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionInclude<ExtArgs> | null
    /**
     * Filter, which ProductOption to fetch.
     */
    where: ProductOptionWhereUniqueInput
  }

  /**
   * ProductOption findUniqueOrThrow
   */
  export type ProductOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOption
     */
    select?: ProductOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOption
     */
    omit?: ProductOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionInclude<ExtArgs> | null
    /**
     * Filter, which ProductOption to fetch.
     */
    where: ProductOptionWhereUniqueInput
  }

  /**
   * ProductOption findFirst
   */
  export type ProductOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOption
     */
    select?: ProductOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOption
     */
    omit?: ProductOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionInclude<ExtArgs> | null
    /**
     * Filter, which ProductOption to fetch.
     */
    where?: ProductOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductOptions to fetch.
     */
    orderBy?: ProductOptionOrderByWithRelationInput | ProductOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductOptions.
     */
    cursor?: ProductOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductOptions.
     */
    distinct?: ProductOptionScalarFieldEnum | ProductOptionScalarFieldEnum[]
  }

  /**
   * ProductOption findFirstOrThrow
   */
  export type ProductOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOption
     */
    select?: ProductOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOption
     */
    omit?: ProductOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionInclude<ExtArgs> | null
    /**
     * Filter, which ProductOption to fetch.
     */
    where?: ProductOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductOptions to fetch.
     */
    orderBy?: ProductOptionOrderByWithRelationInput | ProductOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductOptions.
     */
    cursor?: ProductOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductOptions.
     */
    distinct?: ProductOptionScalarFieldEnum | ProductOptionScalarFieldEnum[]
  }

  /**
   * ProductOption findMany
   */
  export type ProductOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOption
     */
    select?: ProductOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOption
     */
    omit?: ProductOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionInclude<ExtArgs> | null
    /**
     * Filter, which ProductOptions to fetch.
     */
    where?: ProductOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductOptions to fetch.
     */
    orderBy?: ProductOptionOrderByWithRelationInput | ProductOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductOptions.
     */
    cursor?: ProductOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductOptions.
     */
    skip?: number
    distinct?: ProductOptionScalarFieldEnum | ProductOptionScalarFieldEnum[]
  }

  /**
   * ProductOption create
   */
  export type ProductOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOption
     */
    select?: ProductOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOption
     */
    omit?: ProductOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductOption.
     */
    data: XOR<ProductOptionCreateInput, ProductOptionUncheckedCreateInput>
  }

  /**
   * ProductOption createMany
   */
  export type ProductOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductOptions.
     */
    data: ProductOptionCreateManyInput | ProductOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductOption createManyAndReturn
   */
  export type ProductOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOption
     */
    select?: ProductOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOption
     */
    omit?: ProductOptionOmit<ExtArgs> | null
    /**
     * The data used to create many ProductOptions.
     */
    data: ProductOptionCreateManyInput | ProductOptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductOption update
   */
  export type ProductOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOption
     */
    select?: ProductOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOption
     */
    omit?: ProductOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductOption.
     */
    data: XOR<ProductOptionUpdateInput, ProductOptionUncheckedUpdateInput>
    /**
     * Choose, which ProductOption to update.
     */
    where: ProductOptionWhereUniqueInput
  }

  /**
   * ProductOption updateMany
   */
  export type ProductOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductOptions.
     */
    data: XOR<ProductOptionUpdateManyMutationInput, ProductOptionUncheckedUpdateManyInput>
    /**
     * Filter which ProductOptions to update
     */
    where?: ProductOptionWhereInput
    /**
     * Limit how many ProductOptions to update.
     */
    limit?: number
  }

  /**
   * ProductOption updateManyAndReturn
   */
  export type ProductOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOption
     */
    select?: ProductOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOption
     */
    omit?: ProductOptionOmit<ExtArgs> | null
    /**
     * The data used to update ProductOptions.
     */
    data: XOR<ProductOptionUpdateManyMutationInput, ProductOptionUncheckedUpdateManyInput>
    /**
     * Filter which ProductOptions to update
     */
    where?: ProductOptionWhereInput
    /**
     * Limit how many ProductOptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductOption upsert
   */
  export type ProductOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOption
     */
    select?: ProductOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOption
     */
    omit?: ProductOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductOption to update in case it exists.
     */
    where: ProductOptionWhereUniqueInput
    /**
     * In case the ProductOption found by the `where` argument doesn't exist, create a new ProductOption with this data.
     */
    create: XOR<ProductOptionCreateInput, ProductOptionUncheckedCreateInput>
    /**
     * In case the ProductOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductOptionUpdateInput, ProductOptionUncheckedUpdateInput>
  }

  /**
   * ProductOption delete
   */
  export type ProductOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOption
     */
    select?: ProductOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOption
     */
    omit?: ProductOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionInclude<ExtArgs> | null
    /**
     * Filter which ProductOption to delete.
     */
    where: ProductOptionWhereUniqueInput
  }

  /**
   * ProductOption deleteMany
   */
  export type ProductOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductOptions to delete
     */
    where?: ProductOptionWhereInput
    /**
     * Limit how many ProductOptions to delete.
     */
    limit?: number
  }

  /**
   * ProductOption.OrderItemOption
   */
  export type ProductOption$OrderItemOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemOption
     */
    select?: OrderItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemOption
     */
    omit?: OrderItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemOptionInclude<ExtArgs> | null
    where?: OrderItemOptionWhereInput
    orderBy?: OrderItemOptionOrderByWithRelationInput | OrderItemOptionOrderByWithRelationInput[]
    cursor?: OrderItemOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemOptionScalarFieldEnum | OrderItemOptionScalarFieldEnum[]
  }

  /**
   * ProductOption.CartItemOption
   */
  export type ProductOption$CartItemOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItemOption
     */
    select?: CartItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItemOption
     */
    omit?: CartItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemOptionInclude<ExtArgs> | null
    where?: CartItemOptionWhereInput
    orderBy?: CartItemOptionOrderByWithRelationInput | CartItemOptionOrderByWithRelationInput[]
    cursor?: CartItemOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartItemOptionScalarFieldEnum | CartItemOptionScalarFieldEnum[]
  }

  /**
   * ProductOption without action
   */
  export type ProductOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOption
     */
    select?: ProductOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOption
     */
    omit?: ProductOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    basePrice: number | null
    extraCharge: number | null
    totalPrice: number | null
    paymentGraceMinutes: number | null
  }

  export type OrderSumAggregateOutputType = {
    basePrice: number | null
    extraCharge: number | null
    totalPrice: number | null
    paymentGraceMinutes: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    vendorId: string | null
    addressId: string | null
    basePrice: number | null
    extraCharge: number | null
    totalPrice: number | null
    vendorNote: string | null
    customerApproval: boolean | null
    status: $Enums.OrderStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    paymentInitiatedAt: Date | null
    paymentStartedAt: Date | null
    paidAt: Date | null
    paymentStatus: $Enums.PaymentStatus | null
    cancelledAt: Date | null
    cancellationReason: string | null
    protectedUntil: Date | null
    paymentGraceMinutes: number | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    vendorId: string | null
    addressId: string | null
    basePrice: number | null
    extraCharge: number | null
    totalPrice: number | null
    vendorNote: string | null
    customerApproval: boolean | null
    status: $Enums.OrderStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    paymentInitiatedAt: Date | null
    paymentStartedAt: Date | null
    paidAt: Date | null
    paymentStatus: $Enums.PaymentStatus | null
    cancelledAt: Date | null
    cancellationReason: string | null
    protectedUntil: Date | null
    paymentGraceMinutes: number | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    customerId: number
    vendorId: number
    addressId: number
    basePrice: number
    extraCharge: number
    totalPrice: number
    vendorNote: number
    customerApproval: number
    status: number
    createdAt: number
    updatedAt: number
    paymentInitiatedAt: number
    paymentStartedAt: number
    paidAt: number
    paymentStatus: number
    cancelledAt: number
    cancellationReason: number
    protectedUntil: number
    paymentGraceMinutes: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    basePrice?: true
    extraCharge?: true
    totalPrice?: true
    paymentGraceMinutes?: true
  }

  export type OrderSumAggregateInputType = {
    basePrice?: true
    extraCharge?: true
    totalPrice?: true
    paymentGraceMinutes?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    customerId?: true
    vendorId?: true
    addressId?: true
    basePrice?: true
    extraCharge?: true
    totalPrice?: true
    vendorNote?: true
    customerApproval?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    paymentInitiatedAt?: true
    paymentStartedAt?: true
    paidAt?: true
    paymentStatus?: true
    cancelledAt?: true
    cancellationReason?: true
    protectedUntil?: true
    paymentGraceMinutes?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    customerId?: true
    vendorId?: true
    addressId?: true
    basePrice?: true
    extraCharge?: true
    totalPrice?: true
    vendorNote?: true
    customerApproval?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    paymentInitiatedAt?: true
    paymentStartedAt?: true
    paidAt?: true
    paymentStatus?: true
    cancelledAt?: true
    cancellationReason?: true
    protectedUntil?: true
    paymentGraceMinutes?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    customerId?: true
    vendorId?: true
    addressId?: true
    basePrice?: true
    extraCharge?: true
    totalPrice?: true
    vendorNote?: true
    customerApproval?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    paymentInitiatedAt?: true
    paymentStartedAt?: true
    paidAt?: true
    paymentStatus?: true
    cancelledAt?: true
    cancellationReason?: true
    protectedUntil?: true
    paymentGraceMinutes?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    customerId: string
    vendorId: string
    addressId: string | null
    basePrice: number
    extraCharge: number
    totalPrice: number
    vendorNote: string | null
    customerApproval: boolean
    status: $Enums.OrderStatus
    createdAt: Date
    updatedAt: Date
    paymentInitiatedAt: Date | null
    paymentStartedAt: Date | null
    paidAt: Date | null
    paymentStatus: $Enums.PaymentStatus | null
    cancelledAt: Date | null
    cancellationReason: string | null
    protectedUntil: Date | null
    paymentGraceMinutes: number | null
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    vendorId?: boolean
    addressId?: boolean
    basePrice?: boolean
    extraCharge?: boolean
    totalPrice?: boolean
    vendorNote?: boolean
    customerApproval?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paymentInitiatedAt?: boolean
    paymentStartedAt?: boolean
    paidAt?: boolean
    paymentStatus?: boolean
    cancelledAt?: boolean
    cancellationReason?: boolean
    protectedUntil?: boolean
    paymentGraceMinutes?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
    vendor?: boolean | UserDefaultArgs<ExtArgs>
    address?: boolean | Order$addressArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    payments?: boolean | Order$paymentsArgs<ExtArgs>
    Product?: boolean | Order$ProductArgs<ExtArgs>
    assignments?: boolean | Order$assignmentsArgs<ExtArgs>
    earnings?: boolean | Order$earningsArgs<ExtArgs>
    Activity?: boolean | Order$ActivityArgs<ExtArgs>
    DeliveryBroadcast?: boolean | Order$DeliveryBroadcastArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    vendorId?: boolean
    addressId?: boolean
    basePrice?: boolean
    extraCharge?: boolean
    totalPrice?: boolean
    vendorNote?: boolean
    customerApproval?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paymentInitiatedAt?: boolean
    paymentStartedAt?: boolean
    paidAt?: boolean
    paymentStatus?: boolean
    cancelledAt?: boolean
    cancellationReason?: boolean
    protectedUntil?: boolean
    paymentGraceMinutes?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
    vendor?: boolean | UserDefaultArgs<ExtArgs>
    address?: boolean | Order$addressArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    vendorId?: boolean
    addressId?: boolean
    basePrice?: boolean
    extraCharge?: boolean
    totalPrice?: boolean
    vendorNote?: boolean
    customerApproval?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paymentInitiatedAt?: boolean
    paymentStartedAt?: boolean
    paidAt?: boolean
    paymentStatus?: boolean
    cancelledAt?: boolean
    cancellationReason?: boolean
    protectedUntil?: boolean
    paymentGraceMinutes?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
    vendor?: boolean | UserDefaultArgs<ExtArgs>
    address?: boolean | Order$addressArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    customerId?: boolean
    vendorId?: boolean
    addressId?: boolean
    basePrice?: boolean
    extraCharge?: boolean
    totalPrice?: boolean
    vendorNote?: boolean
    customerApproval?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paymentInitiatedAt?: boolean
    paymentStartedAt?: boolean
    paidAt?: boolean
    paymentStatus?: boolean
    cancelledAt?: boolean
    cancellationReason?: boolean
    protectedUntil?: boolean
    paymentGraceMinutes?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "vendorId" | "addressId" | "basePrice" | "extraCharge" | "totalPrice" | "vendorNote" | "customerApproval" | "status" | "createdAt" | "updatedAt" | "paymentInitiatedAt" | "paymentStartedAt" | "paidAt" | "paymentStatus" | "cancelledAt" | "cancellationReason" | "protectedUntil" | "paymentGraceMinutes", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
    vendor?: boolean | UserDefaultArgs<ExtArgs>
    address?: boolean | Order$addressArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    payments?: boolean | Order$paymentsArgs<ExtArgs>
    Product?: boolean | Order$ProductArgs<ExtArgs>
    assignments?: boolean | Order$assignmentsArgs<ExtArgs>
    earnings?: boolean | Order$earningsArgs<ExtArgs>
    Activity?: boolean | Order$ActivityArgs<ExtArgs>
    DeliveryBroadcast?: boolean | Order$DeliveryBroadcastArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
    vendor?: boolean | UserDefaultArgs<ExtArgs>
    address?: boolean | Order$addressArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
    vendor?: boolean | UserDefaultArgs<ExtArgs>
    address?: boolean | Order$addressArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      customer: Prisma.$UserPayload<ExtArgs>
      vendor: Prisma.$UserPayload<ExtArgs>
      address: Prisma.$AddressPayload<ExtArgs> | null
      items: Prisma.$OrderItemPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      Product: Prisma.$ProductPayload<ExtArgs>[]
      assignments: Prisma.$DeliveryAssignmentPayload<ExtArgs>[]
      earnings: Prisma.$DeliveryEarningPayload<ExtArgs>[]
      Activity: Prisma.$ActivityPayload<ExtArgs>[]
      DeliveryBroadcast: Prisma.$DeliveryBroadcastPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      vendorId: string
      addressId: string | null
      basePrice: number
      extraCharge: number
      totalPrice: number
      vendorNote: string | null
      customerApproval: boolean
      status: $Enums.OrderStatus
      createdAt: Date
      updatedAt: Date
      paymentInitiatedAt: Date | null
      paymentStartedAt: Date | null
      paidAt: Date | null
      paymentStatus: $Enums.PaymentStatus | null
      cancelledAt: Date | null
      cancellationReason: string | null
      protectedUntil: Date | null
      paymentGraceMinutes: number | null
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vendor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    address<T extends Order$addressArgs<ExtArgs> = {}>(args?: Subset<T, Order$addressArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends Order$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Order$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Order$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Product<T extends Order$ProductArgs<ExtArgs> = {}>(args?: Subset<T, Order$ProductArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignments<T extends Order$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Order$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    earnings<T extends Order$earningsArgs<ExtArgs> = {}>(args?: Subset<T, Order$earningsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryEarningPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Activity<T extends Order$ActivityArgs<ExtArgs> = {}>(args?: Subset<T, Order$ActivityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DeliveryBroadcast<T extends Order$DeliveryBroadcastArgs<ExtArgs> = {}>(args?: Subset<T, Order$DeliveryBroadcastArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryBroadcastPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly customerId: FieldRef<"Order", 'String'>
    readonly vendorId: FieldRef<"Order", 'String'>
    readonly addressId: FieldRef<"Order", 'String'>
    readonly basePrice: FieldRef<"Order", 'Float'>
    readonly extraCharge: FieldRef<"Order", 'Float'>
    readonly totalPrice: FieldRef<"Order", 'Float'>
    readonly vendorNote: FieldRef<"Order", 'String'>
    readonly customerApproval: FieldRef<"Order", 'Boolean'>
    readonly status: FieldRef<"Order", 'OrderStatus'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
    readonly paymentInitiatedAt: FieldRef<"Order", 'DateTime'>
    readonly paymentStartedAt: FieldRef<"Order", 'DateTime'>
    readonly paidAt: FieldRef<"Order", 'DateTime'>
    readonly paymentStatus: FieldRef<"Order", 'PaymentStatus'>
    readonly cancelledAt: FieldRef<"Order", 'DateTime'>
    readonly cancellationReason: FieldRef<"Order", 'String'>
    readonly protectedUntil: FieldRef<"Order", 'DateTime'>
    readonly paymentGraceMinutes: FieldRef<"Order", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.address
   */
  export type Order$addressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
  }

  /**
   * Order.items
   */
  export type Order$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order.payments
   */
  export type Order$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Order.Product
   */
  export type Order$ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Order.assignments
   */
  export type Order$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryAssignment
     */
    select?: DeliveryAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryAssignment
     */
    omit?: DeliveryAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryAssignmentInclude<ExtArgs> | null
    where?: DeliveryAssignmentWhereInput
    orderBy?: DeliveryAssignmentOrderByWithRelationInput | DeliveryAssignmentOrderByWithRelationInput[]
    cursor?: DeliveryAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryAssignmentScalarFieldEnum | DeliveryAssignmentScalarFieldEnum[]
  }

  /**
   * Order.earnings
   */
  export type Order$earningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEarning
     */
    select?: DeliveryEarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEarning
     */
    omit?: DeliveryEarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEarningInclude<ExtArgs> | null
    where?: DeliveryEarningWhereInput
    orderBy?: DeliveryEarningOrderByWithRelationInput | DeliveryEarningOrderByWithRelationInput[]
    cursor?: DeliveryEarningWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryEarningScalarFieldEnum | DeliveryEarningScalarFieldEnum[]
  }

  /**
   * Order.Activity
   */
  export type Order$ActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Order.DeliveryBroadcast
   */
  export type Order$DeliveryBroadcastArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBroadcast
     */
    select?: DeliveryBroadcastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryBroadcast
     */
    omit?: DeliveryBroadcastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryBroadcastInclude<ExtArgs> | null
    where?: DeliveryBroadcastWhereInput
    orderBy?: DeliveryBroadcastOrderByWithRelationInput | DeliveryBroadcastOrderByWithRelationInput[]
    cursor?: DeliveryBroadcastWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryBroadcastScalarFieldEnum | DeliveryBroadcastScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    subtotal: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    subtotal: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    productId: string | null
    quantity: number | null
    unitPrice: number | null
    subtotal: number | null
    createdAt: Date | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    productId: string | null
    quantity: number | null
    unitPrice: number | null
    subtotal: number | null
    createdAt: Date | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    productId: number
    quantity: number
    unitPrice: number
    subtotal: number
    createdAt: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    subtotal?: true
  }

  export type OrderItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    subtotal?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    subtotal?: true
    createdAt?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    subtotal?: true
    createdAt?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    subtotal?: true
    createdAt?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: string
    orderId: string
    productId: string
    quantity: number
    unitPrice: number
    subtotal: number
    createdAt: Date
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    subtotal?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    options?: boolean | OrderItem$optionsArgs<ExtArgs>
    _count?: boolean | OrderItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    subtotal?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    subtotal?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    subtotal?: boolean
    createdAt?: boolean
  }

  export type OrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "productId" | "quantity" | "unitPrice" | "subtotal" | "createdAt", ExtArgs["result"]["orderItem"]>
  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    options?: boolean | OrderItem$optionsArgs<ExtArgs>
    _count?: boolean | OrderItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      options: Prisma.$OrderItemOptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      productId: string
      quantity: number
      unitPrice: number
      subtotal: number
      createdAt: Date
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems and returns the data updated in the database.
     * @param {OrderItemUpdateManyAndReturnArgs} args - Arguments to update many OrderItems.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderItemUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    options<T extends OrderItem$optionsArgs<ExtArgs> = {}>(args?: Subset<T, OrderItem$optionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'String'>
    readonly orderId: FieldRef<"OrderItem", 'String'>
    readonly productId: FieldRef<"OrderItem", 'String'>
    readonly quantity: FieldRef<"OrderItem", 'Int'>
    readonly unitPrice: FieldRef<"OrderItem", 'Float'>
    readonly subtotal: FieldRef<"OrderItem", 'Float'>
    readonly createdAt: FieldRef<"OrderItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
  }

  /**
   * OrderItem updateManyAndReturn
   */
  export type OrderItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to delete.
     */
    limit?: number
  }

  /**
   * OrderItem.options
   */
  export type OrderItem$optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemOption
     */
    select?: OrderItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemOption
     */
    omit?: OrderItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemOptionInclude<ExtArgs> | null
    where?: OrderItemOptionWhereInput
    orderBy?: OrderItemOptionOrderByWithRelationInput | OrderItemOptionOrderByWithRelationInput[]
    cursor?: OrderItemOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemOptionScalarFieldEnum | OrderItemOptionScalarFieldEnum[]
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model OrderItemOption
   */

  export type AggregateOrderItemOption = {
    _count: OrderItemOptionCountAggregateOutputType | null
    _avg: OrderItemOptionAvgAggregateOutputType | null
    _sum: OrderItemOptionSumAggregateOutputType | null
    _min: OrderItemOptionMinAggregateOutputType | null
    _max: OrderItemOptionMaxAggregateOutputType | null
  }

  export type OrderItemOptionAvgAggregateOutputType = {
    price: number | null
  }

  export type OrderItemOptionSumAggregateOutputType = {
    price: number | null
  }

  export type OrderItemOptionMinAggregateOutputType = {
    id: string | null
    optionId: string | null
    name: string | null
    price: number | null
    orderItemId: string | null
  }

  export type OrderItemOptionMaxAggregateOutputType = {
    id: string | null
    optionId: string | null
    name: string | null
    price: number | null
    orderItemId: string | null
  }

  export type OrderItemOptionCountAggregateOutputType = {
    id: number
    optionId: number
    name: number
    price: number
    orderItemId: number
    _all: number
  }


  export type OrderItemOptionAvgAggregateInputType = {
    price?: true
  }

  export type OrderItemOptionSumAggregateInputType = {
    price?: true
  }

  export type OrderItemOptionMinAggregateInputType = {
    id?: true
    optionId?: true
    name?: true
    price?: true
    orderItemId?: true
  }

  export type OrderItemOptionMaxAggregateInputType = {
    id?: true
    optionId?: true
    name?: true
    price?: true
    orderItemId?: true
  }

  export type OrderItemOptionCountAggregateInputType = {
    id?: true
    optionId?: true
    name?: true
    price?: true
    orderItemId?: true
    _all?: true
  }

  export type OrderItemOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItemOption to aggregate.
     */
    where?: OrderItemOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItemOptions to fetch.
     */
    orderBy?: OrderItemOptionOrderByWithRelationInput | OrderItemOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItemOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItemOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItemOptions
    **/
    _count?: true | OrderItemOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemOptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemOptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemOptionMaxAggregateInputType
  }

  export type GetOrderItemOptionAggregateType<T extends OrderItemOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItemOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItemOption[P]>
      : GetScalarType<T[P], AggregateOrderItemOption[P]>
  }




  export type OrderItemOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemOptionWhereInput
    orderBy?: OrderItemOptionOrderByWithAggregationInput | OrderItemOptionOrderByWithAggregationInput[]
    by: OrderItemOptionScalarFieldEnum[] | OrderItemOptionScalarFieldEnum
    having?: OrderItemOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemOptionCountAggregateInputType | true
    _avg?: OrderItemOptionAvgAggregateInputType
    _sum?: OrderItemOptionSumAggregateInputType
    _min?: OrderItemOptionMinAggregateInputType
    _max?: OrderItemOptionMaxAggregateInputType
  }

  export type OrderItemOptionGroupByOutputType = {
    id: string
    optionId: string
    name: string
    price: number
    orderItemId: string
    _count: OrderItemOptionCountAggregateOutputType | null
    _avg: OrderItemOptionAvgAggregateOutputType | null
    _sum: OrderItemOptionSumAggregateOutputType | null
    _min: OrderItemOptionMinAggregateOutputType | null
    _max: OrderItemOptionMaxAggregateOutputType | null
  }

  type GetOrderItemOptionGroupByPayload<T extends OrderItemOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemOptionGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemOptionGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    optionId?: boolean
    name?: boolean
    price?: boolean
    orderItemId?: boolean
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    productOption?: boolean | ProductOptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItemOption"]>

  export type OrderItemOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    optionId?: boolean
    name?: boolean
    price?: boolean
    orderItemId?: boolean
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    productOption?: boolean | ProductOptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItemOption"]>

  export type OrderItemOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    optionId?: boolean
    name?: boolean
    price?: boolean
    orderItemId?: boolean
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    productOption?: boolean | ProductOptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItemOption"]>

  export type OrderItemOptionSelectScalar = {
    id?: boolean
    optionId?: boolean
    name?: boolean
    price?: boolean
    orderItemId?: boolean
  }

  export type OrderItemOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "optionId" | "name" | "price" | "orderItemId", ExtArgs["result"]["orderItemOption"]>
  export type OrderItemOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    productOption?: boolean | ProductOptionDefaultArgs<ExtArgs>
  }
  export type OrderItemOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    productOption?: boolean | ProductOptionDefaultArgs<ExtArgs>
  }
  export type OrderItemOptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    productOption?: boolean | ProductOptionDefaultArgs<ExtArgs>
  }

  export type $OrderItemOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItemOption"
    objects: {
      orderItem: Prisma.$OrderItemPayload<ExtArgs>
      productOption: Prisma.$ProductOptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      optionId: string
      name: string
      price: number
      orderItemId: string
    }, ExtArgs["result"]["orderItemOption"]>
    composites: {}
  }

  type OrderItemOptionGetPayload<S extends boolean | null | undefined | OrderItemOptionDefaultArgs> = $Result.GetResult<Prisma.$OrderItemOptionPayload, S>

  type OrderItemOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderItemOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderItemOptionCountAggregateInputType | true
    }

  export interface OrderItemOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItemOption'], meta: { name: 'OrderItemOption' } }
    /**
     * Find zero or one OrderItemOption that matches the filter.
     * @param {OrderItemOptionFindUniqueArgs} args - Arguments to find a OrderItemOption
     * @example
     * // Get one OrderItemOption
     * const orderItemOption = await prisma.orderItemOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemOptionFindUniqueArgs>(args: SelectSubset<T, OrderItemOptionFindUniqueArgs<ExtArgs>>): Prisma__OrderItemOptionClient<$Result.GetResult<Prisma.$OrderItemOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderItemOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemOptionFindUniqueOrThrowArgs} args - Arguments to find a OrderItemOption
     * @example
     * // Get one OrderItemOption
     * const orderItemOption = await prisma.orderItemOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemOptionClient<$Result.GetResult<Prisma.$OrderItemOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItemOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemOptionFindFirstArgs} args - Arguments to find a OrderItemOption
     * @example
     * // Get one OrderItemOption
     * const orderItemOption = await prisma.orderItemOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemOptionFindFirstArgs>(args?: SelectSubset<T, OrderItemOptionFindFirstArgs<ExtArgs>>): Prisma__OrderItemOptionClient<$Result.GetResult<Prisma.$OrderItemOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItemOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemOptionFindFirstOrThrowArgs} args - Arguments to find a OrderItemOption
     * @example
     * // Get one OrderItemOption
     * const orderItemOption = await prisma.orderItemOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemOptionClient<$Result.GetResult<Prisma.$OrderItemOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderItemOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItemOptions
     * const orderItemOptions = await prisma.orderItemOption.findMany()
     * 
     * // Get first 10 OrderItemOptions
     * const orderItemOptions = await prisma.orderItemOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemOptionWithIdOnly = await prisma.orderItemOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemOptionFindManyArgs>(args?: SelectSubset<T, OrderItemOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderItemOption.
     * @param {OrderItemOptionCreateArgs} args - Arguments to create a OrderItemOption.
     * @example
     * // Create one OrderItemOption
     * const OrderItemOption = await prisma.orderItemOption.create({
     *   data: {
     *     // ... data to create a OrderItemOption
     *   }
     * })
     * 
     */
    create<T extends OrderItemOptionCreateArgs>(args: SelectSubset<T, OrderItemOptionCreateArgs<ExtArgs>>): Prisma__OrderItemOptionClient<$Result.GetResult<Prisma.$OrderItemOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderItemOptions.
     * @param {OrderItemOptionCreateManyArgs} args - Arguments to create many OrderItemOptions.
     * @example
     * // Create many OrderItemOptions
     * const orderItemOption = await prisma.orderItemOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemOptionCreateManyArgs>(args?: SelectSubset<T, OrderItemOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItemOptions and returns the data saved in the database.
     * @param {OrderItemOptionCreateManyAndReturnArgs} args - Arguments to create many OrderItemOptions.
     * @example
     * // Create many OrderItemOptions
     * const orderItemOption = await prisma.orderItemOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItemOptions and only return the `id`
     * const orderItemOptionWithIdOnly = await prisma.orderItemOption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderItemOption.
     * @param {OrderItemOptionDeleteArgs} args - Arguments to delete one OrderItemOption.
     * @example
     * // Delete one OrderItemOption
     * const OrderItemOption = await prisma.orderItemOption.delete({
     *   where: {
     *     // ... filter to delete one OrderItemOption
     *   }
     * })
     * 
     */
    delete<T extends OrderItemOptionDeleteArgs>(args: SelectSubset<T, OrderItemOptionDeleteArgs<ExtArgs>>): Prisma__OrderItemOptionClient<$Result.GetResult<Prisma.$OrderItemOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderItemOption.
     * @param {OrderItemOptionUpdateArgs} args - Arguments to update one OrderItemOption.
     * @example
     * // Update one OrderItemOption
     * const orderItemOption = await prisma.orderItemOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemOptionUpdateArgs>(args: SelectSubset<T, OrderItemOptionUpdateArgs<ExtArgs>>): Prisma__OrderItemOptionClient<$Result.GetResult<Prisma.$OrderItemOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderItemOptions.
     * @param {OrderItemOptionDeleteManyArgs} args - Arguments to filter OrderItemOptions to delete.
     * @example
     * // Delete a few OrderItemOptions
     * const { count } = await prisma.orderItemOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemOptionDeleteManyArgs>(args?: SelectSubset<T, OrderItemOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItemOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItemOptions
     * const orderItemOption = await prisma.orderItemOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemOptionUpdateManyArgs>(args: SelectSubset<T, OrderItemOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItemOptions and returns the data updated in the database.
     * @param {OrderItemOptionUpdateManyAndReturnArgs} args - Arguments to update many OrderItemOptions.
     * @example
     * // Update many OrderItemOptions
     * const orderItemOption = await prisma.orderItemOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderItemOptions and only return the `id`
     * const orderItemOptionWithIdOnly = await prisma.orderItemOption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderItemOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderItemOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderItemOption.
     * @param {OrderItemOptionUpsertArgs} args - Arguments to update or create a OrderItemOption.
     * @example
     * // Update or create a OrderItemOption
     * const orderItemOption = await prisma.orderItemOption.upsert({
     *   create: {
     *     // ... data to create a OrderItemOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItemOption we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemOptionUpsertArgs>(args: SelectSubset<T, OrderItemOptionUpsertArgs<ExtArgs>>): Prisma__OrderItemOptionClient<$Result.GetResult<Prisma.$OrderItemOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderItemOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemOptionCountArgs} args - Arguments to filter OrderItemOptions to count.
     * @example
     * // Count the number of OrderItemOptions
     * const count = await prisma.orderItemOption.count({
     *   where: {
     *     // ... the filter for the OrderItemOptions we want to count
     *   }
     * })
    **/
    count<T extends OrderItemOptionCountArgs>(
      args?: Subset<T, OrderItemOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItemOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemOptionAggregateArgs>(args: Subset<T, OrderItemOptionAggregateArgs>): Prisma.PrismaPromise<GetOrderItemOptionAggregateType<T>>

    /**
     * Group by OrderItemOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemOptionGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItemOption model
   */
  readonly fields: OrderItemOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItemOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderItem<T extends OrderItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderItemDefaultArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    productOption<T extends ProductOptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductOptionDefaultArgs<ExtArgs>>): Prisma__ProductOptionClient<$Result.GetResult<Prisma.$ProductOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItemOption model
   */
  interface OrderItemOptionFieldRefs {
    readonly id: FieldRef<"OrderItemOption", 'String'>
    readonly optionId: FieldRef<"OrderItemOption", 'String'>
    readonly name: FieldRef<"OrderItemOption", 'String'>
    readonly price: FieldRef<"OrderItemOption", 'Float'>
    readonly orderItemId: FieldRef<"OrderItemOption", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OrderItemOption findUnique
   */
  export type OrderItemOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemOption
     */
    select?: OrderItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemOption
     */
    omit?: OrderItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemOptionInclude<ExtArgs> | null
    /**
     * Filter, which OrderItemOption to fetch.
     */
    where: OrderItemOptionWhereUniqueInput
  }

  /**
   * OrderItemOption findUniqueOrThrow
   */
  export type OrderItemOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemOption
     */
    select?: OrderItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemOption
     */
    omit?: OrderItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemOptionInclude<ExtArgs> | null
    /**
     * Filter, which OrderItemOption to fetch.
     */
    where: OrderItemOptionWhereUniqueInput
  }

  /**
   * OrderItemOption findFirst
   */
  export type OrderItemOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemOption
     */
    select?: OrderItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemOption
     */
    omit?: OrderItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemOptionInclude<ExtArgs> | null
    /**
     * Filter, which OrderItemOption to fetch.
     */
    where?: OrderItemOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItemOptions to fetch.
     */
    orderBy?: OrderItemOptionOrderByWithRelationInput | OrderItemOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItemOptions.
     */
    cursor?: OrderItemOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItemOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItemOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItemOptions.
     */
    distinct?: OrderItemOptionScalarFieldEnum | OrderItemOptionScalarFieldEnum[]
  }

  /**
   * OrderItemOption findFirstOrThrow
   */
  export type OrderItemOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemOption
     */
    select?: OrderItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemOption
     */
    omit?: OrderItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemOptionInclude<ExtArgs> | null
    /**
     * Filter, which OrderItemOption to fetch.
     */
    where?: OrderItemOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItemOptions to fetch.
     */
    orderBy?: OrderItemOptionOrderByWithRelationInput | OrderItemOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItemOptions.
     */
    cursor?: OrderItemOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItemOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItemOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItemOptions.
     */
    distinct?: OrderItemOptionScalarFieldEnum | OrderItemOptionScalarFieldEnum[]
  }

  /**
   * OrderItemOption findMany
   */
  export type OrderItemOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemOption
     */
    select?: OrderItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemOption
     */
    omit?: OrderItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemOptionInclude<ExtArgs> | null
    /**
     * Filter, which OrderItemOptions to fetch.
     */
    where?: OrderItemOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItemOptions to fetch.
     */
    orderBy?: OrderItemOptionOrderByWithRelationInput | OrderItemOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItemOptions.
     */
    cursor?: OrderItemOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItemOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItemOptions.
     */
    skip?: number
    distinct?: OrderItemOptionScalarFieldEnum | OrderItemOptionScalarFieldEnum[]
  }

  /**
   * OrderItemOption create
   */
  export type OrderItemOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemOption
     */
    select?: OrderItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemOption
     */
    omit?: OrderItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItemOption.
     */
    data: XOR<OrderItemOptionCreateInput, OrderItemOptionUncheckedCreateInput>
  }

  /**
   * OrderItemOption createMany
   */
  export type OrderItemOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItemOptions.
     */
    data: OrderItemOptionCreateManyInput | OrderItemOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItemOption createManyAndReturn
   */
  export type OrderItemOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemOption
     */
    select?: OrderItemOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemOption
     */
    omit?: OrderItemOptionOmit<ExtArgs> | null
    /**
     * The data used to create many OrderItemOptions.
     */
    data: OrderItemOptionCreateManyInput | OrderItemOptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemOptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItemOption update
   */
  export type OrderItemOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemOption
     */
    select?: OrderItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemOption
     */
    omit?: OrderItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItemOption.
     */
    data: XOR<OrderItemOptionUpdateInput, OrderItemOptionUncheckedUpdateInput>
    /**
     * Choose, which OrderItemOption to update.
     */
    where: OrderItemOptionWhereUniqueInput
  }

  /**
   * OrderItemOption updateMany
   */
  export type OrderItemOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItemOptions.
     */
    data: XOR<OrderItemOptionUpdateManyMutationInput, OrderItemOptionUncheckedUpdateManyInput>
    /**
     * Filter which OrderItemOptions to update
     */
    where?: OrderItemOptionWhereInput
    /**
     * Limit how many OrderItemOptions to update.
     */
    limit?: number
  }

  /**
   * OrderItemOption updateManyAndReturn
   */
  export type OrderItemOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemOption
     */
    select?: OrderItemOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemOption
     */
    omit?: OrderItemOptionOmit<ExtArgs> | null
    /**
     * The data used to update OrderItemOptions.
     */
    data: XOR<OrderItemOptionUpdateManyMutationInput, OrderItemOptionUncheckedUpdateManyInput>
    /**
     * Filter which OrderItemOptions to update
     */
    where?: OrderItemOptionWhereInput
    /**
     * Limit how many OrderItemOptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemOptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItemOption upsert
   */
  export type OrderItemOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemOption
     */
    select?: OrderItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemOption
     */
    omit?: OrderItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItemOption to update in case it exists.
     */
    where: OrderItemOptionWhereUniqueInput
    /**
     * In case the OrderItemOption found by the `where` argument doesn't exist, create a new OrderItemOption with this data.
     */
    create: XOR<OrderItemOptionCreateInput, OrderItemOptionUncheckedCreateInput>
    /**
     * In case the OrderItemOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemOptionUpdateInput, OrderItemOptionUncheckedUpdateInput>
  }

  /**
   * OrderItemOption delete
   */
  export type OrderItemOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemOption
     */
    select?: OrderItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemOption
     */
    omit?: OrderItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemOptionInclude<ExtArgs> | null
    /**
     * Filter which OrderItemOption to delete.
     */
    where: OrderItemOptionWhereUniqueInput
  }

  /**
   * OrderItemOption deleteMany
   */
  export type OrderItemOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItemOptions to delete
     */
    where?: OrderItemOptionWhereInput
    /**
     * Limit how many OrderItemOptions to delete.
     */
    limit?: number
  }

  /**
   * OrderItemOption without action
   */
  export type OrderItemOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemOption
     */
    select?: OrderItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemOption
     */
    omit?: OrderItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemOptionInclude<ExtArgs> | null
  }


  /**
   * Model ProductReview
   */

  export type AggregateProductReview = {
    _count: ProductReviewCountAggregateOutputType | null
    _avg: ProductReviewAvgAggregateOutputType | null
    _sum: ProductReviewSumAggregateOutputType | null
    _min: ProductReviewMinAggregateOutputType | null
    _max: ProductReviewMaxAggregateOutputType | null
  }

  export type ProductReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type ProductReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type ProductReviewMinAggregateOutputType = {
    id: string | null
    productId: string | null
    customerId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
    verifiedPurchase: boolean | null
  }

  export type ProductReviewMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    customerId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
    verifiedPurchase: boolean | null
  }

  export type ProductReviewCountAggregateOutputType = {
    id: number
    productId: number
    customerId: number
    rating: number
    comment: number
    images: number
    createdAt: number
    verifiedPurchase: number
    _all: number
  }


  export type ProductReviewAvgAggregateInputType = {
    rating?: true
  }

  export type ProductReviewSumAggregateInputType = {
    rating?: true
  }

  export type ProductReviewMinAggregateInputType = {
    id?: true
    productId?: true
    customerId?: true
    rating?: true
    comment?: true
    createdAt?: true
    verifiedPurchase?: true
  }

  export type ProductReviewMaxAggregateInputType = {
    id?: true
    productId?: true
    customerId?: true
    rating?: true
    comment?: true
    createdAt?: true
    verifiedPurchase?: true
  }

  export type ProductReviewCountAggregateInputType = {
    id?: true
    productId?: true
    customerId?: true
    rating?: true
    comment?: true
    images?: true
    createdAt?: true
    verifiedPurchase?: true
    _all?: true
  }

  export type ProductReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductReview to aggregate.
     */
    where?: ProductReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductReviews to fetch.
     */
    orderBy?: ProductReviewOrderByWithRelationInput | ProductReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductReviews
    **/
    _count?: true | ProductReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductReviewMaxAggregateInputType
  }

  export type GetProductReviewAggregateType<T extends ProductReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateProductReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductReview[P]>
      : GetScalarType<T[P], AggregateProductReview[P]>
  }




  export type ProductReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductReviewWhereInput
    orderBy?: ProductReviewOrderByWithAggregationInput | ProductReviewOrderByWithAggregationInput[]
    by: ProductReviewScalarFieldEnum[] | ProductReviewScalarFieldEnum
    having?: ProductReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductReviewCountAggregateInputType | true
    _avg?: ProductReviewAvgAggregateInputType
    _sum?: ProductReviewSumAggregateInputType
    _min?: ProductReviewMinAggregateInputType
    _max?: ProductReviewMaxAggregateInputType
  }

  export type ProductReviewGroupByOutputType = {
    id: string
    productId: string
    customerId: string
    rating: number
    comment: string | null
    images: string[]
    createdAt: Date
    verifiedPurchase: boolean
    _count: ProductReviewCountAggregateOutputType | null
    _avg: ProductReviewAvgAggregateOutputType | null
    _sum: ProductReviewSumAggregateOutputType | null
    _min: ProductReviewMinAggregateOutputType | null
    _max: ProductReviewMaxAggregateOutputType | null
  }

  type GetProductReviewGroupByPayload<T extends ProductReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ProductReviewGroupByOutputType[P]>
        }
      >
    >


  export type ProductReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    customerId?: boolean
    rating?: boolean
    comment?: boolean
    images?: boolean
    createdAt?: boolean
    verifiedPurchase?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    customer?: boolean | UserDefaultArgs<ExtArgs>
    reply?: boolean | ProductReview$replyArgs<ExtArgs>
    votes?: boolean | ProductReview$votesArgs<ExtArgs>
    reports?: boolean | ProductReview$reportsArgs<ExtArgs>
    _count?: boolean | ProductReviewCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productReview"]>

  export type ProductReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    customerId?: boolean
    rating?: boolean
    comment?: boolean
    images?: boolean
    createdAt?: boolean
    verifiedPurchase?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productReview"]>

  export type ProductReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    customerId?: boolean
    rating?: boolean
    comment?: boolean
    images?: boolean
    createdAt?: boolean
    verifiedPurchase?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productReview"]>

  export type ProductReviewSelectScalar = {
    id?: boolean
    productId?: boolean
    customerId?: boolean
    rating?: boolean
    comment?: boolean
    images?: boolean
    createdAt?: boolean
    verifiedPurchase?: boolean
  }

  export type ProductReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "customerId" | "rating" | "comment" | "images" | "createdAt" | "verifiedPurchase", ExtArgs["result"]["productReview"]>
  export type ProductReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    customer?: boolean | UserDefaultArgs<ExtArgs>
    reply?: boolean | ProductReview$replyArgs<ExtArgs>
    votes?: boolean | ProductReview$votesArgs<ExtArgs>
    reports?: boolean | ProductReview$reportsArgs<ExtArgs>
    _count?: boolean | ProductReviewCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProductReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProductReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductReview"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      customer: Prisma.$UserPayload<ExtArgs>
      reply: Prisma.$VendorReplyPayload<ExtArgs> | null
      votes: Prisma.$ReviewVotePayload<ExtArgs>[]
      reports: Prisma.$ReviewReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      customerId: string
      rating: number
      comment: string | null
      images: string[]
      createdAt: Date
      verifiedPurchase: boolean
    }, ExtArgs["result"]["productReview"]>
    composites: {}
  }

  type ProductReviewGetPayload<S extends boolean | null | undefined | ProductReviewDefaultArgs> = $Result.GetResult<Prisma.$ProductReviewPayload, S>

  type ProductReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductReviewCountAggregateInputType | true
    }

  export interface ProductReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductReview'], meta: { name: 'ProductReview' } }
    /**
     * Find zero or one ProductReview that matches the filter.
     * @param {ProductReviewFindUniqueArgs} args - Arguments to find a ProductReview
     * @example
     * // Get one ProductReview
     * const productReview = await prisma.productReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductReviewFindUniqueArgs>(args: SelectSubset<T, ProductReviewFindUniqueArgs<ExtArgs>>): Prisma__ProductReviewClient<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductReview that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductReviewFindUniqueOrThrowArgs} args - Arguments to find a ProductReview
     * @example
     * // Get one ProductReview
     * const productReview = await prisma.productReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductReviewClient<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewFindFirstArgs} args - Arguments to find a ProductReview
     * @example
     * // Get one ProductReview
     * const productReview = await prisma.productReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductReviewFindFirstArgs>(args?: SelectSubset<T, ProductReviewFindFirstArgs<ExtArgs>>): Prisma__ProductReviewClient<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewFindFirstOrThrowArgs} args - Arguments to find a ProductReview
     * @example
     * // Get one ProductReview
     * const productReview = await prisma.productReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductReviewClient<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductReviews
     * const productReviews = await prisma.productReview.findMany()
     * 
     * // Get first 10 ProductReviews
     * const productReviews = await prisma.productReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productReviewWithIdOnly = await prisma.productReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductReviewFindManyArgs>(args?: SelectSubset<T, ProductReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductReview.
     * @param {ProductReviewCreateArgs} args - Arguments to create a ProductReview.
     * @example
     * // Create one ProductReview
     * const ProductReview = await prisma.productReview.create({
     *   data: {
     *     // ... data to create a ProductReview
     *   }
     * })
     * 
     */
    create<T extends ProductReviewCreateArgs>(args: SelectSubset<T, ProductReviewCreateArgs<ExtArgs>>): Prisma__ProductReviewClient<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductReviews.
     * @param {ProductReviewCreateManyArgs} args - Arguments to create many ProductReviews.
     * @example
     * // Create many ProductReviews
     * const productReview = await prisma.productReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductReviewCreateManyArgs>(args?: SelectSubset<T, ProductReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductReviews and returns the data saved in the database.
     * @param {ProductReviewCreateManyAndReturnArgs} args - Arguments to create many ProductReviews.
     * @example
     * // Create many ProductReviews
     * const productReview = await prisma.productReview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductReviews and only return the `id`
     * const productReviewWithIdOnly = await prisma.productReview.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductReview.
     * @param {ProductReviewDeleteArgs} args - Arguments to delete one ProductReview.
     * @example
     * // Delete one ProductReview
     * const ProductReview = await prisma.productReview.delete({
     *   where: {
     *     // ... filter to delete one ProductReview
     *   }
     * })
     * 
     */
    delete<T extends ProductReviewDeleteArgs>(args: SelectSubset<T, ProductReviewDeleteArgs<ExtArgs>>): Prisma__ProductReviewClient<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductReview.
     * @param {ProductReviewUpdateArgs} args - Arguments to update one ProductReview.
     * @example
     * // Update one ProductReview
     * const productReview = await prisma.productReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductReviewUpdateArgs>(args: SelectSubset<T, ProductReviewUpdateArgs<ExtArgs>>): Prisma__ProductReviewClient<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductReviews.
     * @param {ProductReviewDeleteManyArgs} args - Arguments to filter ProductReviews to delete.
     * @example
     * // Delete a few ProductReviews
     * const { count } = await prisma.productReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductReviewDeleteManyArgs>(args?: SelectSubset<T, ProductReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductReviews
     * const productReview = await prisma.productReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductReviewUpdateManyArgs>(args: SelectSubset<T, ProductReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductReviews and returns the data updated in the database.
     * @param {ProductReviewUpdateManyAndReturnArgs} args - Arguments to update many ProductReviews.
     * @example
     * // Update many ProductReviews
     * const productReview = await prisma.productReview.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductReviews and only return the `id`
     * const productReviewWithIdOnly = await prisma.productReview.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductReview.
     * @param {ProductReviewUpsertArgs} args - Arguments to update or create a ProductReview.
     * @example
     * // Update or create a ProductReview
     * const productReview = await prisma.productReview.upsert({
     *   create: {
     *     // ... data to create a ProductReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductReview we want to update
     *   }
     * })
     */
    upsert<T extends ProductReviewUpsertArgs>(args: SelectSubset<T, ProductReviewUpsertArgs<ExtArgs>>): Prisma__ProductReviewClient<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewCountArgs} args - Arguments to filter ProductReviews to count.
     * @example
     * // Count the number of ProductReviews
     * const count = await prisma.productReview.count({
     *   where: {
     *     // ... the filter for the ProductReviews we want to count
     *   }
     * })
    **/
    count<T extends ProductReviewCountArgs>(
      args?: Subset<T, ProductReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductReviewAggregateArgs>(args: Subset<T, ProductReviewAggregateArgs>): Prisma.PrismaPromise<GetProductReviewAggregateType<T>>

    /**
     * Group by ProductReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductReviewGroupByArgs['orderBy'] }
        : { orderBy?: ProductReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductReview model
   */
  readonly fields: ProductReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reply<T extends ProductReview$replyArgs<ExtArgs> = {}>(args?: Subset<T, ProductReview$replyArgs<ExtArgs>>): Prisma__VendorReplyClient<$Result.GetResult<Prisma.$VendorReplyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    votes<T extends ProductReview$votesArgs<ExtArgs> = {}>(args?: Subset<T, ProductReview$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reports<T extends ProductReview$reportsArgs<ExtArgs> = {}>(args?: Subset<T, ProductReview$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductReview model
   */
  interface ProductReviewFieldRefs {
    readonly id: FieldRef<"ProductReview", 'String'>
    readonly productId: FieldRef<"ProductReview", 'String'>
    readonly customerId: FieldRef<"ProductReview", 'String'>
    readonly rating: FieldRef<"ProductReview", 'Int'>
    readonly comment: FieldRef<"ProductReview", 'String'>
    readonly images: FieldRef<"ProductReview", 'String[]'>
    readonly createdAt: FieldRef<"ProductReview", 'DateTime'>
    readonly verifiedPurchase: FieldRef<"ProductReview", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ProductReview findUnique
   */
  export type ProductReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductReview
     */
    omit?: ProductReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * Filter, which ProductReview to fetch.
     */
    where: ProductReviewWhereUniqueInput
  }

  /**
   * ProductReview findUniqueOrThrow
   */
  export type ProductReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductReview
     */
    omit?: ProductReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * Filter, which ProductReview to fetch.
     */
    where: ProductReviewWhereUniqueInput
  }

  /**
   * ProductReview findFirst
   */
  export type ProductReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductReview
     */
    omit?: ProductReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * Filter, which ProductReview to fetch.
     */
    where?: ProductReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductReviews to fetch.
     */
    orderBy?: ProductReviewOrderByWithRelationInput | ProductReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductReviews.
     */
    cursor?: ProductReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductReviews.
     */
    distinct?: ProductReviewScalarFieldEnum | ProductReviewScalarFieldEnum[]
  }

  /**
   * ProductReview findFirstOrThrow
   */
  export type ProductReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductReview
     */
    omit?: ProductReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * Filter, which ProductReview to fetch.
     */
    where?: ProductReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductReviews to fetch.
     */
    orderBy?: ProductReviewOrderByWithRelationInput | ProductReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductReviews.
     */
    cursor?: ProductReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductReviews.
     */
    distinct?: ProductReviewScalarFieldEnum | ProductReviewScalarFieldEnum[]
  }

  /**
   * ProductReview findMany
   */
  export type ProductReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductReview
     */
    omit?: ProductReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * Filter, which ProductReviews to fetch.
     */
    where?: ProductReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductReviews to fetch.
     */
    orderBy?: ProductReviewOrderByWithRelationInput | ProductReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductReviews.
     */
    cursor?: ProductReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductReviews.
     */
    skip?: number
    distinct?: ProductReviewScalarFieldEnum | ProductReviewScalarFieldEnum[]
  }

  /**
   * ProductReview create
   */
  export type ProductReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductReview
     */
    omit?: ProductReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductReview.
     */
    data: XOR<ProductReviewCreateInput, ProductReviewUncheckedCreateInput>
  }

  /**
   * ProductReview createMany
   */
  export type ProductReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductReviews.
     */
    data: ProductReviewCreateManyInput | ProductReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductReview createManyAndReturn
   */
  export type ProductReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductReview
     */
    omit?: ProductReviewOmit<ExtArgs> | null
    /**
     * The data used to create many ProductReviews.
     */
    data: ProductReviewCreateManyInput | ProductReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductReview update
   */
  export type ProductReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductReview
     */
    omit?: ProductReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductReview.
     */
    data: XOR<ProductReviewUpdateInput, ProductReviewUncheckedUpdateInput>
    /**
     * Choose, which ProductReview to update.
     */
    where: ProductReviewWhereUniqueInput
  }

  /**
   * ProductReview updateMany
   */
  export type ProductReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductReviews.
     */
    data: XOR<ProductReviewUpdateManyMutationInput, ProductReviewUncheckedUpdateManyInput>
    /**
     * Filter which ProductReviews to update
     */
    where?: ProductReviewWhereInput
    /**
     * Limit how many ProductReviews to update.
     */
    limit?: number
  }

  /**
   * ProductReview updateManyAndReturn
   */
  export type ProductReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductReview
     */
    omit?: ProductReviewOmit<ExtArgs> | null
    /**
     * The data used to update ProductReviews.
     */
    data: XOR<ProductReviewUpdateManyMutationInput, ProductReviewUncheckedUpdateManyInput>
    /**
     * Filter which ProductReviews to update
     */
    where?: ProductReviewWhereInput
    /**
     * Limit how many ProductReviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductReview upsert
   */
  export type ProductReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductReview
     */
    omit?: ProductReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductReview to update in case it exists.
     */
    where: ProductReviewWhereUniqueInput
    /**
     * In case the ProductReview found by the `where` argument doesn't exist, create a new ProductReview with this data.
     */
    create: XOR<ProductReviewCreateInput, ProductReviewUncheckedCreateInput>
    /**
     * In case the ProductReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductReviewUpdateInput, ProductReviewUncheckedUpdateInput>
  }

  /**
   * ProductReview delete
   */
  export type ProductReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductReview
     */
    omit?: ProductReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * Filter which ProductReview to delete.
     */
    where: ProductReviewWhereUniqueInput
  }

  /**
   * ProductReview deleteMany
   */
  export type ProductReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductReviews to delete
     */
    where?: ProductReviewWhereInput
    /**
     * Limit how many ProductReviews to delete.
     */
    limit?: number
  }

  /**
   * ProductReview.reply
   */
  export type ProductReview$replyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorReply
     */
    select?: VendorReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorReply
     */
    omit?: VendorReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorReplyInclude<ExtArgs> | null
    where?: VendorReplyWhereInput
  }

  /**
   * ProductReview.votes
   */
  export type ProductReview$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
    where?: ReviewVoteWhereInput
    orderBy?: ReviewVoteOrderByWithRelationInput | ReviewVoteOrderByWithRelationInput[]
    cursor?: ReviewVoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewVoteScalarFieldEnum | ReviewVoteScalarFieldEnum[]
  }

  /**
   * ProductReview.reports
   */
  export type ProductReview$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReport
     */
    select?: ReviewReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReport
     */
    omit?: ReviewReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReportInclude<ExtArgs> | null
    where?: ReviewReportWhereInput
    orderBy?: ReviewReportOrderByWithRelationInput | ReviewReportOrderByWithRelationInput[]
    cursor?: ReviewReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewReportScalarFieldEnum | ReviewReportScalarFieldEnum[]
  }

  /**
   * ProductReview without action
   */
  export type ProductReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductReview
     */
    omit?: ProductReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
  }


  /**
   * Model VendorReply
   */

  export type AggregateVendorReply = {
    _count: VendorReplyCountAggregateOutputType | null
    _min: VendorReplyMinAggregateOutputType | null
    _max: VendorReplyMaxAggregateOutputType | null
  }

  export type VendorReplyMinAggregateOutputType = {
    id: string | null
    reviewId: string | null
    vendorId: string | null
    message: string | null
    createdAt: Date | null
  }

  export type VendorReplyMaxAggregateOutputType = {
    id: string | null
    reviewId: string | null
    vendorId: string | null
    message: string | null
    createdAt: Date | null
  }

  export type VendorReplyCountAggregateOutputType = {
    id: number
    reviewId: number
    vendorId: number
    message: number
    createdAt: number
    _all: number
  }


  export type VendorReplyMinAggregateInputType = {
    id?: true
    reviewId?: true
    vendorId?: true
    message?: true
    createdAt?: true
  }

  export type VendorReplyMaxAggregateInputType = {
    id?: true
    reviewId?: true
    vendorId?: true
    message?: true
    createdAt?: true
  }

  export type VendorReplyCountAggregateInputType = {
    id?: true
    reviewId?: true
    vendorId?: true
    message?: true
    createdAt?: true
    _all?: true
  }

  export type VendorReplyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorReply to aggregate.
     */
    where?: VendorReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorReplies to fetch.
     */
    orderBy?: VendorReplyOrderByWithRelationInput | VendorReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VendorReplies
    **/
    _count?: true | VendorReplyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorReplyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorReplyMaxAggregateInputType
  }

  export type GetVendorReplyAggregateType<T extends VendorReplyAggregateArgs> = {
        [P in keyof T & keyof AggregateVendorReply]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendorReply[P]>
      : GetScalarType<T[P], AggregateVendorReply[P]>
  }




  export type VendorReplyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorReplyWhereInput
    orderBy?: VendorReplyOrderByWithAggregationInput | VendorReplyOrderByWithAggregationInput[]
    by: VendorReplyScalarFieldEnum[] | VendorReplyScalarFieldEnum
    having?: VendorReplyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorReplyCountAggregateInputType | true
    _min?: VendorReplyMinAggregateInputType
    _max?: VendorReplyMaxAggregateInputType
  }

  export type VendorReplyGroupByOutputType = {
    id: string
    reviewId: string
    vendorId: string
    message: string
    createdAt: Date
    _count: VendorReplyCountAggregateOutputType | null
    _min: VendorReplyMinAggregateOutputType | null
    _max: VendorReplyMaxAggregateOutputType | null
  }

  type GetVendorReplyGroupByPayload<T extends VendorReplyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorReplyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorReplyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorReplyGroupByOutputType[P]>
            : GetScalarType<T[P], VendorReplyGroupByOutputType[P]>
        }
      >
    >


  export type VendorReplySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    vendorId?: boolean
    message?: boolean
    createdAt?: boolean
    review?: boolean | ProductReviewDefaultArgs<ExtArgs>
    vendor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorReply"]>

  export type VendorReplySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    vendorId?: boolean
    message?: boolean
    createdAt?: boolean
    review?: boolean | ProductReviewDefaultArgs<ExtArgs>
    vendor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorReply"]>

  export type VendorReplySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    vendorId?: boolean
    message?: boolean
    createdAt?: boolean
    review?: boolean | ProductReviewDefaultArgs<ExtArgs>
    vendor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorReply"]>

  export type VendorReplySelectScalar = {
    id?: boolean
    reviewId?: boolean
    vendorId?: boolean
    message?: boolean
    createdAt?: boolean
  }

  export type VendorReplyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reviewId" | "vendorId" | "message" | "createdAt", ExtArgs["result"]["vendorReply"]>
  export type VendorReplyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ProductReviewDefaultArgs<ExtArgs>
    vendor?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VendorReplyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ProductReviewDefaultArgs<ExtArgs>
    vendor?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VendorReplyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ProductReviewDefaultArgs<ExtArgs>
    vendor?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VendorReplyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VendorReply"
    objects: {
      review: Prisma.$ProductReviewPayload<ExtArgs>
      vendor: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reviewId: string
      vendorId: string
      message: string
      createdAt: Date
    }, ExtArgs["result"]["vendorReply"]>
    composites: {}
  }

  type VendorReplyGetPayload<S extends boolean | null | undefined | VendorReplyDefaultArgs> = $Result.GetResult<Prisma.$VendorReplyPayload, S>

  type VendorReplyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorReplyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorReplyCountAggregateInputType | true
    }

  export interface VendorReplyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VendorReply'], meta: { name: 'VendorReply' } }
    /**
     * Find zero or one VendorReply that matches the filter.
     * @param {VendorReplyFindUniqueArgs} args - Arguments to find a VendorReply
     * @example
     * // Get one VendorReply
     * const vendorReply = await prisma.vendorReply.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorReplyFindUniqueArgs>(args: SelectSubset<T, VendorReplyFindUniqueArgs<ExtArgs>>): Prisma__VendorReplyClient<$Result.GetResult<Prisma.$VendorReplyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VendorReply that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorReplyFindUniqueOrThrowArgs} args - Arguments to find a VendorReply
     * @example
     * // Get one VendorReply
     * const vendorReply = await prisma.vendorReply.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorReplyFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorReplyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorReplyClient<$Result.GetResult<Prisma.$VendorReplyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorReply that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorReplyFindFirstArgs} args - Arguments to find a VendorReply
     * @example
     * // Get one VendorReply
     * const vendorReply = await prisma.vendorReply.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorReplyFindFirstArgs>(args?: SelectSubset<T, VendorReplyFindFirstArgs<ExtArgs>>): Prisma__VendorReplyClient<$Result.GetResult<Prisma.$VendorReplyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorReply that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorReplyFindFirstOrThrowArgs} args - Arguments to find a VendorReply
     * @example
     * // Get one VendorReply
     * const vendorReply = await prisma.vendorReply.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorReplyFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorReplyFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorReplyClient<$Result.GetResult<Prisma.$VendorReplyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VendorReplies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorReplyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VendorReplies
     * const vendorReplies = await prisma.vendorReply.findMany()
     * 
     * // Get first 10 VendorReplies
     * const vendorReplies = await prisma.vendorReply.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorReplyWithIdOnly = await prisma.vendorReply.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorReplyFindManyArgs>(args?: SelectSubset<T, VendorReplyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorReplyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VendorReply.
     * @param {VendorReplyCreateArgs} args - Arguments to create a VendorReply.
     * @example
     * // Create one VendorReply
     * const VendorReply = await prisma.vendorReply.create({
     *   data: {
     *     // ... data to create a VendorReply
     *   }
     * })
     * 
     */
    create<T extends VendorReplyCreateArgs>(args: SelectSubset<T, VendorReplyCreateArgs<ExtArgs>>): Prisma__VendorReplyClient<$Result.GetResult<Prisma.$VendorReplyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VendorReplies.
     * @param {VendorReplyCreateManyArgs} args - Arguments to create many VendorReplies.
     * @example
     * // Create many VendorReplies
     * const vendorReply = await prisma.vendorReply.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorReplyCreateManyArgs>(args?: SelectSubset<T, VendorReplyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VendorReplies and returns the data saved in the database.
     * @param {VendorReplyCreateManyAndReturnArgs} args - Arguments to create many VendorReplies.
     * @example
     * // Create many VendorReplies
     * const vendorReply = await prisma.vendorReply.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VendorReplies and only return the `id`
     * const vendorReplyWithIdOnly = await prisma.vendorReply.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorReplyCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorReplyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorReplyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VendorReply.
     * @param {VendorReplyDeleteArgs} args - Arguments to delete one VendorReply.
     * @example
     * // Delete one VendorReply
     * const VendorReply = await prisma.vendorReply.delete({
     *   where: {
     *     // ... filter to delete one VendorReply
     *   }
     * })
     * 
     */
    delete<T extends VendorReplyDeleteArgs>(args: SelectSubset<T, VendorReplyDeleteArgs<ExtArgs>>): Prisma__VendorReplyClient<$Result.GetResult<Prisma.$VendorReplyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VendorReply.
     * @param {VendorReplyUpdateArgs} args - Arguments to update one VendorReply.
     * @example
     * // Update one VendorReply
     * const vendorReply = await prisma.vendorReply.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorReplyUpdateArgs>(args: SelectSubset<T, VendorReplyUpdateArgs<ExtArgs>>): Prisma__VendorReplyClient<$Result.GetResult<Prisma.$VendorReplyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VendorReplies.
     * @param {VendorReplyDeleteManyArgs} args - Arguments to filter VendorReplies to delete.
     * @example
     * // Delete a few VendorReplies
     * const { count } = await prisma.vendorReply.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorReplyDeleteManyArgs>(args?: SelectSubset<T, VendorReplyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorReplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorReplyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VendorReplies
     * const vendorReply = await prisma.vendorReply.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorReplyUpdateManyArgs>(args: SelectSubset<T, VendorReplyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorReplies and returns the data updated in the database.
     * @param {VendorReplyUpdateManyAndReturnArgs} args - Arguments to update many VendorReplies.
     * @example
     * // Update many VendorReplies
     * const vendorReply = await prisma.vendorReply.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VendorReplies and only return the `id`
     * const vendorReplyWithIdOnly = await prisma.vendorReply.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VendorReplyUpdateManyAndReturnArgs>(args: SelectSubset<T, VendorReplyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorReplyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VendorReply.
     * @param {VendorReplyUpsertArgs} args - Arguments to update or create a VendorReply.
     * @example
     * // Update or create a VendorReply
     * const vendorReply = await prisma.vendorReply.upsert({
     *   create: {
     *     // ... data to create a VendorReply
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VendorReply we want to update
     *   }
     * })
     */
    upsert<T extends VendorReplyUpsertArgs>(args: SelectSubset<T, VendorReplyUpsertArgs<ExtArgs>>): Prisma__VendorReplyClient<$Result.GetResult<Prisma.$VendorReplyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VendorReplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorReplyCountArgs} args - Arguments to filter VendorReplies to count.
     * @example
     * // Count the number of VendorReplies
     * const count = await prisma.vendorReply.count({
     *   where: {
     *     // ... the filter for the VendorReplies we want to count
     *   }
     * })
    **/
    count<T extends VendorReplyCountArgs>(
      args?: Subset<T, VendorReplyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorReplyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VendorReply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorReplyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorReplyAggregateArgs>(args: Subset<T, VendorReplyAggregateArgs>): Prisma.PrismaPromise<GetVendorReplyAggregateType<T>>

    /**
     * Group by VendorReply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorReplyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorReplyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorReplyGroupByArgs['orderBy'] }
        : { orderBy?: VendorReplyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorReplyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorReplyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VendorReply model
   */
  readonly fields: VendorReplyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VendorReply.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorReplyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    review<T extends ProductReviewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductReviewDefaultArgs<ExtArgs>>): Prisma__ProductReviewClient<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vendor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VendorReply model
   */
  interface VendorReplyFieldRefs {
    readonly id: FieldRef<"VendorReply", 'String'>
    readonly reviewId: FieldRef<"VendorReply", 'String'>
    readonly vendorId: FieldRef<"VendorReply", 'String'>
    readonly message: FieldRef<"VendorReply", 'String'>
    readonly createdAt: FieldRef<"VendorReply", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VendorReply findUnique
   */
  export type VendorReplyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorReply
     */
    select?: VendorReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorReply
     */
    omit?: VendorReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorReplyInclude<ExtArgs> | null
    /**
     * Filter, which VendorReply to fetch.
     */
    where: VendorReplyWhereUniqueInput
  }

  /**
   * VendorReply findUniqueOrThrow
   */
  export type VendorReplyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorReply
     */
    select?: VendorReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorReply
     */
    omit?: VendorReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorReplyInclude<ExtArgs> | null
    /**
     * Filter, which VendorReply to fetch.
     */
    where: VendorReplyWhereUniqueInput
  }

  /**
   * VendorReply findFirst
   */
  export type VendorReplyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorReply
     */
    select?: VendorReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorReply
     */
    omit?: VendorReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorReplyInclude<ExtArgs> | null
    /**
     * Filter, which VendorReply to fetch.
     */
    where?: VendorReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorReplies to fetch.
     */
    orderBy?: VendorReplyOrderByWithRelationInput | VendorReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorReplies.
     */
    cursor?: VendorReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorReplies.
     */
    distinct?: VendorReplyScalarFieldEnum | VendorReplyScalarFieldEnum[]
  }

  /**
   * VendorReply findFirstOrThrow
   */
  export type VendorReplyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorReply
     */
    select?: VendorReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorReply
     */
    omit?: VendorReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorReplyInclude<ExtArgs> | null
    /**
     * Filter, which VendorReply to fetch.
     */
    where?: VendorReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorReplies to fetch.
     */
    orderBy?: VendorReplyOrderByWithRelationInput | VendorReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorReplies.
     */
    cursor?: VendorReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorReplies.
     */
    distinct?: VendorReplyScalarFieldEnum | VendorReplyScalarFieldEnum[]
  }

  /**
   * VendorReply findMany
   */
  export type VendorReplyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorReply
     */
    select?: VendorReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorReply
     */
    omit?: VendorReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorReplyInclude<ExtArgs> | null
    /**
     * Filter, which VendorReplies to fetch.
     */
    where?: VendorReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorReplies to fetch.
     */
    orderBy?: VendorReplyOrderByWithRelationInput | VendorReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VendorReplies.
     */
    cursor?: VendorReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorReplies.
     */
    skip?: number
    distinct?: VendorReplyScalarFieldEnum | VendorReplyScalarFieldEnum[]
  }

  /**
   * VendorReply create
   */
  export type VendorReplyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorReply
     */
    select?: VendorReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorReply
     */
    omit?: VendorReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorReplyInclude<ExtArgs> | null
    /**
     * The data needed to create a VendorReply.
     */
    data: XOR<VendorReplyCreateInput, VendorReplyUncheckedCreateInput>
  }

  /**
   * VendorReply createMany
   */
  export type VendorReplyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VendorReplies.
     */
    data: VendorReplyCreateManyInput | VendorReplyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VendorReply createManyAndReturn
   */
  export type VendorReplyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorReply
     */
    select?: VendorReplySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorReply
     */
    omit?: VendorReplyOmit<ExtArgs> | null
    /**
     * The data used to create many VendorReplies.
     */
    data: VendorReplyCreateManyInput | VendorReplyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorReplyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorReply update
   */
  export type VendorReplyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorReply
     */
    select?: VendorReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorReply
     */
    omit?: VendorReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorReplyInclude<ExtArgs> | null
    /**
     * The data needed to update a VendorReply.
     */
    data: XOR<VendorReplyUpdateInput, VendorReplyUncheckedUpdateInput>
    /**
     * Choose, which VendorReply to update.
     */
    where: VendorReplyWhereUniqueInput
  }

  /**
   * VendorReply updateMany
   */
  export type VendorReplyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VendorReplies.
     */
    data: XOR<VendorReplyUpdateManyMutationInput, VendorReplyUncheckedUpdateManyInput>
    /**
     * Filter which VendorReplies to update
     */
    where?: VendorReplyWhereInput
    /**
     * Limit how many VendorReplies to update.
     */
    limit?: number
  }

  /**
   * VendorReply updateManyAndReturn
   */
  export type VendorReplyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorReply
     */
    select?: VendorReplySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorReply
     */
    omit?: VendorReplyOmit<ExtArgs> | null
    /**
     * The data used to update VendorReplies.
     */
    data: XOR<VendorReplyUpdateManyMutationInput, VendorReplyUncheckedUpdateManyInput>
    /**
     * Filter which VendorReplies to update
     */
    where?: VendorReplyWhereInput
    /**
     * Limit how many VendorReplies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorReplyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorReply upsert
   */
  export type VendorReplyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorReply
     */
    select?: VendorReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorReply
     */
    omit?: VendorReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorReplyInclude<ExtArgs> | null
    /**
     * The filter to search for the VendorReply to update in case it exists.
     */
    where: VendorReplyWhereUniqueInput
    /**
     * In case the VendorReply found by the `where` argument doesn't exist, create a new VendorReply with this data.
     */
    create: XOR<VendorReplyCreateInput, VendorReplyUncheckedCreateInput>
    /**
     * In case the VendorReply was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorReplyUpdateInput, VendorReplyUncheckedUpdateInput>
  }

  /**
   * VendorReply delete
   */
  export type VendorReplyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorReply
     */
    select?: VendorReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorReply
     */
    omit?: VendorReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorReplyInclude<ExtArgs> | null
    /**
     * Filter which VendorReply to delete.
     */
    where: VendorReplyWhereUniqueInput
  }

  /**
   * VendorReply deleteMany
   */
  export type VendorReplyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorReplies to delete
     */
    where?: VendorReplyWhereInput
    /**
     * Limit how many VendorReplies to delete.
     */
    limit?: number
  }

  /**
   * VendorReply without action
   */
  export type VendorReplyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorReply
     */
    select?: VendorReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorReply
     */
    omit?: VendorReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorReplyInclude<ExtArgs> | null
  }


  /**
   * Model ReviewVote
   */

  export type AggregateReviewVote = {
    _count: ReviewVoteCountAggregateOutputType | null
    _min: ReviewVoteMinAggregateOutputType | null
    _max: ReviewVoteMaxAggregateOutputType | null
  }

  export type ReviewVoteMinAggregateOutputType = {
    id: string | null
    reviewId: string | null
    userId: string | null
    isHelpful: boolean | null
    createdAt: Date | null
  }

  export type ReviewVoteMaxAggregateOutputType = {
    id: string | null
    reviewId: string | null
    userId: string | null
    isHelpful: boolean | null
    createdAt: Date | null
  }

  export type ReviewVoteCountAggregateOutputType = {
    id: number
    reviewId: number
    userId: number
    isHelpful: number
    createdAt: number
    _all: number
  }


  export type ReviewVoteMinAggregateInputType = {
    id?: true
    reviewId?: true
    userId?: true
    isHelpful?: true
    createdAt?: true
  }

  export type ReviewVoteMaxAggregateInputType = {
    id?: true
    reviewId?: true
    userId?: true
    isHelpful?: true
    createdAt?: true
  }

  export type ReviewVoteCountAggregateInputType = {
    id?: true
    reviewId?: true
    userId?: true
    isHelpful?: true
    createdAt?: true
    _all?: true
  }

  export type ReviewVoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewVote to aggregate.
     */
    where?: ReviewVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewVotes to fetch.
     */
    orderBy?: ReviewVoteOrderByWithRelationInput | ReviewVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReviewVotes
    **/
    _count?: true | ReviewVoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewVoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewVoteMaxAggregateInputType
  }

  export type GetReviewVoteAggregateType<T extends ReviewVoteAggregateArgs> = {
        [P in keyof T & keyof AggregateReviewVote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviewVote[P]>
      : GetScalarType<T[P], AggregateReviewVote[P]>
  }




  export type ReviewVoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewVoteWhereInput
    orderBy?: ReviewVoteOrderByWithAggregationInput | ReviewVoteOrderByWithAggregationInput[]
    by: ReviewVoteScalarFieldEnum[] | ReviewVoteScalarFieldEnum
    having?: ReviewVoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewVoteCountAggregateInputType | true
    _min?: ReviewVoteMinAggregateInputType
    _max?: ReviewVoteMaxAggregateInputType
  }

  export type ReviewVoteGroupByOutputType = {
    id: string
    reviewId: string
    userId: string
    isHelpful: boolean
    createdAt: Date
    _count: ReviewVoteCountAggregateOutputType | null
    _min: ReviewVoteMinAggregateOutputType | null
    _max: ReviewVoteMaxAggregateOutputType | null
  }

  type GetReviewVoteGroupByPayload<T extends ReviewVoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewVoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewVoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewVoteGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewVoteGroupByOutputType[P]>
        }
      >
    >


  export type ReviewVoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    userId?: boolean
    isHelpful?: boolean
    createdAt?: boolean
    review?: boolean | ProductReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewVote"]>

  export type ReviewVoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    userId?: boolean
    isHelpful?: boolean
    createdAt?: boolean
    review?: boolean | ProductReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewVote"]>

  export type ReviewVoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    userId?: boolean
    isHelpful?: boolean
    createdAt?: boolean
    review?: boolean | ProductReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewVote"]>

  export type ReviewVoteSelectScalar = {
    id?: boolean
    reviewId?: boolean
    userId?: boolean
    isHelpful?: boolean
    createdAt?: boolean
  }

  export type ReviewVoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reviewId" | "userId" | "isHelpful" | "createdAt", ExtArgs["result"]["reviewVote"]>
  export type ReviewVoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ProductReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReviewVoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ProductReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReviewVoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ProductReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReviewVotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReviewVote"
    objects: {
      review: Prisma.$ProductReviewPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reviewId: string
      userId: string
      isHelpful: boolean
      createdAt: Date
    }, ExtArgs["result"]["reviewVote"]>
    composites: {}
  }

  type ReviewVoteGetPayload<S extends boolean | null | undefined | ReviewVoteDefaultArgs> = $Result.GetResult<Prisma.$ReviewVotePayload, S>

  type ReviewVoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewVoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewVoteCountAggregateInputType | true
    }

  export interface ReviewVoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReviewVote'], meta: { name: 'ReviewVote' } }
    /**
     * Find zero or one ReviewVote that matches the filter.
     * @param {ReviewVoteFindUniqueArgs} args - Arguments to find a ReviewVote
     * @example
     * // Get one ReviewVote
     * const reviewVote = await prisma.reviewVote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewVoteFindUniqueArgs>(args: SelectSubset<T, ReviewVoteFindUniqueArgs<ExtArgs>>): Prisma__ReviewVoteClient<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReviewVote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewVoteFindUniqueOrThrowArgs} args - Arguments to find a ReviewVote
     * @example
     * // Get one ReviewVote
     * const reviewVote = await prisma.reviewVote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewVoteFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewVoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewVoteClient<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewVote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewVoteFindFirstArgs} args - Arguments to find a ReviewVote
     * @example
     * // Get one ReviewVote
     * const reviewVote = await prisma.reviewVote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewVoteFindFirstArgs>(args?: SelectSubset<T, ReviewVoteFindFirstArgs<ExtArgs>>): Prisma__ReviewVoteClient<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewVote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewVoteFindFirstOrThrowArgs} args - Arguments to find a ReviewVote
     * @example
     * // Get one ReviewVote
     * const reviewVote = await prisma.reviewVote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewVoteFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewVoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewVoteClient<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReviewVotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewVoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReviewVotes
     * const reviewVotes = await prisma.reviewVote.findMany()
     * 
     * // Get first 10 ReviewVotes
     * const reviewVotes = await prisma.reviewVote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewVoteWithIdOnly = await prisma.reviewVote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewVoteFindManyArgs>(args?: SelectSubset<T, ReviewVoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReviewVote.
     * @param {ReviewVoteCreateArgs} args - Arguments to create a ReviewVote.
     * @example
     * // Create one ReviewVote
     * const ReviewVote = await prisma.reviewVote.create({
     *   data: {
     *     // ... data to create a ReviewVote
     *   }
     * })
     * 
     */
    create<T extends ReviewVoteCreateArgs>(args: SelectSubset<T, ReviewVoteCreateArgs<ExtArgs>>): Prisma__ReviewVoteClient<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReviewVotes.
     * @param {ReviewVoteCreateManyArgs} args - Arguments to create many ReviewVotes.
     * @example
     * // Create many ReviewVotes
     * const reviewVote = await prisma.reviewVote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewVoteCreateManyArgs>(args?: SelectSubset<T, ReviewVoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReviewVotes and returns the data saved in the database.
     * @param {ReviewVoteCreateManyAndReturnArgs} args - Arguments to create many ReviewVotes.
     * @example
     * // Create many ReviewVotes
     * const reviewVote = await prisma.reviewVote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReviewVotes and only return the `id`
     * const reviewVoteWithIdOnly = await prisma.reviewVote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewVoteCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewVoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReviewVote.
     * @param {ReviewVoteDeleteArgs} args - Arguments to delete one ReviewVote.
     * @example
     * // Delete one ReviewVote
     * const ReviewVote = await prisma.reviewVote.delete({
     *   where: {
     *     // ... filter to delete one ReviewVote
     *   }
     * })
     * 
     */
    delete<T extends ReviewVoteDeleteArgs>(args: SelectSubset<T, ReviewVoteDeleteArgs<ExtArgs>>): Prisma__ReviewVoteClient<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReviewVote.
     * @param {ReviewVoteUpdateArgs} args - Arguments to update one ReviewVote.
     * @example
     * // Update one ReviewVote
     * const reviewVote = await prisma.reviewVote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewVoteUpdateArgs>(args: SelectSubset<T, ReviewVoteUpdateArgs<ExtArgs>>): Prisma__ReviewVoteClient<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReviewVotes.
     * @param {ReviewVoteDeleteManyArgs} args - Arguments to filter ReviewVotes to delete.
     * @example
     * // Delete a few ReviewVotes
     * const { count } = await prisma.reviewVote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewVoteDeleteManyArgs>(args?: SelectSubset<T, ReviewVoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewVoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReviewVotes
     * const reviewVote = await prisma.reviewVote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewVoteUpdateManyArgs>(args: SelectSubset<T, ReviewVoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewVotes and returns the data updated in the database.
     * @param {ReviewVoteUpdateManyAndReturnArgs} args - Arguments to update many ReviewVotes.
     * @example
     * // Update many ReviewVotes
     * const reviewVote = await prisma.reviewVote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReviewVotes and only return the `id`
     * const reviewVoteWithIdOnly = await prisma.reviewVote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewVoteUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewVoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReviewVote.
     * @param {ReviewVoteUpsertArgs} args - Arguments to update or create a ReviewVote.
     * @example
     * // Update or create a ReviewVote
     * const reviewVote = await prisma.reviewVote.upsert({
     *   create: {
     *     // ... data to create a ReviewVote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReviewVote we want to update
     *   }
     * })
     */
    upsert<T extends ReviewVoteUpsertArgs>(args: SelectSubset<T, ReviewVoteUpsertArgs<ExtArgs>>): Prisma__ReviewVoteClient<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReviewVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewVoteCountArgs} args - Arguments to filter ReviewVotes to count.
     * @example
     * // Count the number of ReviewVotes
     * const count = await prisma.reviewVote.count({
     *   where: {
     *     // ... the filter for the ReviewVotes we want to count
     *   }
     * })
    **/
    count<T extends ReviewVoteCountArgs>(
      args?: Subset<T, ReviewVoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewVoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReviewVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewVoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewVoteAggregateArgs>(args: Subset<T, ReviewVoteAggregateArgs>): Prisma.PrismaPromise<GetReviewVoteAggregateType<T>>

    /**
     * Group by ReviewVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewVoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewVoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewVoteGroupByArgs['orderBy'] }
        : { orderBy?: ReviewVoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewVoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewVoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReviewVote model
   */
  readonly fields: ReviewVoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReviewVote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewVoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    review<T extends ProductReviewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductReviewDefaultArgs<ExtArgs>>): Prisma__ProductReviewClient<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReviewVote model
   */
  interface ReviewVoteFieldRefs {
    readonly id: FieldRef<"ReviewVote", 'String'>
    readonly reviewId: FieldRef<"ReviewVote", 'String'>
    readonly userId: FieldRef<"ReviewVote", 'String'>
    readonly isHelpful: FieldRef<"ReviewVote", 'Boolean'>
    readonly createdAt: FieldRef<"ReviewVote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReviewVote findUnique
   */
  export type ReviewVoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
    /**
     * Filter, which ReviewVote to fetch.
     */
    where: ReviewVoteWhereUniqueInput
  }

  /**
   * ReviewVote findUniqueOrThrow
   */
  export type ReviewVoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
    /**
     * Filter, which ReviewVote to fetch.
     */
    where: ReviewVoteWhereUniqueInput
  }

  /**
   * ReviewVote findFirst
   */
  export type ReviewVoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
    /**
     * Filter, which ReviewVote to fetch.
     */
    where?: ReviewVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewVotes to fetch.
     */
    orderBy?: ReviewVoteOrderByWithRelationInput | ReviewVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewVotes.
     */
    cursor?: ReviewVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewVotes.
     */
    distinct?: ReviewVoteScalarFieldEnum | ReviewVoteScalarFieldEnum[]
  }

  /**
   * ReviewVote findFirstOrThrow
   */
  export type ReviewVoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
    /**
     * Filter, which ReviewVote to fetch.
     */
    where?: ReviewVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewVotes to fetch.
     */
    orderBy?: ReviewVoteOrderByWithRelationInput | ReviewVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewVotes.
     */
    cursor?: ReviewVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewVotes.
     */
    distinct?: ReviewVoteScalarFieldEnum | ReviewVoteScalarFieldEnum[]
  }

  /**
   * ReviewVote findMany
   */
  export type ReviewVoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
    /**
     * Filter, which ReviewVotes to fetch.
     */
    where?: ReviewVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewVotes to fetch.
     */
    orderBy?: ReviewVoteOrderByWithRelationInput | ReviewVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReviewVotes.
     */
    cursor?: ReviewVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewVotes.
     */
    skip?: number
    distinct?: ReviewVoteScalarFieldEnum | ReviewVoteScalarFieldEnum[]
  }

  /**
   * ReviewVote create
   */
  export type ReviewVoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
    /**
     * The data needed to create a ReviewVote.
     */
    data: XOR<ReviewVoteCreateInput, ReviewVoteUncheckedCreateInput>
  }

  /**
   * ReviewVote createMany
   */
  export type ReviewVoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReviewVotes.
     */
    data: ReviewVoteCreateManyInput | ReviewVoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReviewVote createManyAndReturn
   */
  export type ReviewVoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * The data used to create many ReviewVotes.
     */
    data: ReviewVoteCreateManyInput | ReviewVoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewVote update
   */
  export type ReviewVoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
    /**
     * The data needed to update a ReviewVote.
     */
    data: XOR<ReviewVoteUpdateInput, ReviewVoteUncheckedUpdateInput>
    /**
     * Choose, which ReviewVote to update.
     */
    where: ReviewVoteWhereUniqueInput
  }

  /**
   * ReviewVote updateMany
   */
  export type ReviewVoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReviewVotes.
     */
    data: XOR<ReviewVoteUpdateManyMutationInput, ReviewVoteUncheckedUpdateManyInput>
    /**
     * Filter which ReviewVotes to update
     */
    where?: ReviewVoteWhereInput
    /**
     * Limit how many ReviewVotes to update.
     */
    limit?: number
  }

  /**
   * ReviewVote updateManyAndReturn
   */
  export type ReviewVoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * The data used to update ReviewVotes.
     */
    data: XOR<ReviewVoteUpdateManyMutationInput, ReviewVoteUncheckedUpdateManyInput>
    /**
     * Filter which ReviewVotes to update
     */
    where?: ReviewVoteWhereInput
    /**
     * Limit how many ReviewVotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewVote upsert
   */
  export type ReviewVoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
    /**
     * The filter to search for the ReviewVote to update in case it exists.
     */
    where: ReviewVoteWhereUniqueInput
    /**
     * In case the ReviewVote found by the `where` argument doesn't exist, create a new ReviewVote with this data.
     */
    create: XOR<ReviewVoteCreateInput, ReviewVoteUncheckedCreateInput>
    /**
     * In case the ReviewVote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewVoteUpdateInput, ReviewVoteUncheckedUpdateInput>
  }

  /**
   * ReviewVote delete
   */
  export type ReviewVoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
    /**
     * Filter which ReviewVote to delete.
     */
    where: ReviewVoteWhereUniqueInput
  }

  /**
   * ReviewVote deleteMany
   */
  export type ReviewVoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewVotes to delete
     */
    where?: ReviewVoteWhereInput
    /**
     * Limit how many ReviewVotes to delete.
     */
    limit?: number
  }

  /**
   * ReviewVote without action
   */
  export type ReviewVoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
  }


  /**
   * Model ReviewReport
   */

  export type AggregateReviewReport = {
    _count: ReviewReportCountAggregateOutputType | null
    _min: ReviewReportMinAggregateOutputType | null
    _max: ReviewReportMaxAggregateOutputType | null
  }

  export type ReviewReportMinAggregateOutputType = {
    id: string | null
    reviewId: string | null
    userId: string | null
    reason: string | null
    createdAt: Date | null
  }

  export type ReviewReportMaxAggregateOutputType = {
    id: string | null
    reviewId: string | null
    userId: string | null
    reason: string | null
    createdAt: Date | null
  }

  export type ReviewReportCountAggregateOutputType = {
    id: number
    reviewId: number
    userId: number
    reason: number
    createdAt: number
    _all: number
  }


  export type ReviewReportMinAggregateInputType = {
    id?: true
    reviewId?: true
    userId?: true
    reason?: true
    createdAt?: true
  }

  export type ReviewReportMaxAggregateInputType = {
    id?: true
    reviewId?: true
    userId?: true
    reason?: true
    createdAt?: true
  }

  export type ReviewReportCountAggregateInputType = {
    id?: true
    reviewId?: true
    userId?: true
    reason?: true
    createdAt?: true
    _all?: true
  }

  export type ReviewReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewReport to aggregate.
     */
    where?: ReviewReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewReports to fetch.
     */
    orderBy?: ReviewReportOrderByWithRelationInput | ReviewReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReviewReports
    **/
    _count?: true | ReviewReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewReportMaxAggregateInputType
  }

  export type GetReviewReportAggregateType<T extends ReviewReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReviewReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviewReport[P]>
      : GetScalarType<T[P], AggregateReviewReport[P]>
  }




  export type ReviewReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewReportWhereInput
    orderBy?: ReviewReportOrderByWithAggregationInput | ReviewReportOrderByWithAggregationInput[]
    by: ReviewReportScalarFieldEnum[] | ReviewReportScalarFieldEnum
    having?: ReviewReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewReportCountAggregateInputType | true
    _min?: ReviewReportMinAggregateInputType
    _max?: ReviewReportMaxAggregateInputType
  }

  export type ReviewReportGroupByOutputType = {
    id: string
    reviewId: string
    userId: string
    reason: string
    createdAt: Date
    _count: ReviewReportCountAggregateOutputType | null
    _min: ReviewReportMinAggregateOutputType | null
    _max: ReviewReportMaxAggregateOutputType | null
  }

  type GetReviewReportGroupByPayload<T extends ReviewReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewReportGroupByOutputType[P]>
        }
      >
    >


  export type ReviewReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    userId?: boolean
    reason?: boolean
    createdAt?: boolean
    review?: boolean | ProductReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewReport"]>

  export type ReviewReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    userId?: boolean
    reason?: boolean
    createdAt?: boolean
    review?: boolean | ProductReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewReport"]>

  export type ReviewReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    userId?: boolean
    reason?: boolean
    createdAt?: boolean
    review?: boolean | ProductReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewReport"]>

  export type ReviewReportSelectScalar = {
    id?: boolean
    reviewId?: boolean
    userId?: boolean
    reason?: boolean
    createdAt?: boolean
  }

  export type ReviewReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reviewId" | "userId" | "reason" | "createdAt", ExtArgs["result"]["reviewReport"]>
  export type ReviewReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ProductReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReviewReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ProductReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReviewReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ProductReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReviewReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReviewReport"
    objects: {
      review: Prisma.$ProductReviewPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reviewId: string
      userId: string
      reason: string
      createdAt: Date
    }, ExtArgs["result"]["reviewReport"]>
    composites: {}
  }

  type ReviewReportGetPayload<S extends boolean | null | undefined | ReviewReportDefaultArgs> = $Result.GetResult<Prisma.$ReviewReportPayload, S>

  type ReviewReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewReportCountAggregateInputType | true
    }

  export interface ReviewReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReviewReport'], meta: { name: 'ReviewReport' } }
    /**
     * Find zero or one ReviewReport that matches the filter.
     * @param {ReviewReportFindUniqueArgs} args - Arguments to find a ReviewReport
     * @example
     * // Get one ReviewReport
     * const reviewReport = await prisma.reviewReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewReportFindUniqueArgs>(args: SelectSubset<T, ReviewReportFindUniqueArgs<ExtArgs>>): Prisma__ReviewReportClient<$Result.GetResult<Prisma.$ReviewReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReviewReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewReportFindUniqueOrThrowArgs} args - Arguments to find a ReviewReport
     * @example
     * // Get one ReviewReport
     * const reviewReport = await prisma.reviewReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewReportClient<$Result.GetResult<Prisma.$ReviewReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewReportFindFirstArgs} args - Arguments to find a ReviewReport
     * @example
     * // Get one ReviewReport
     * const reviewReport = await prisma.reviewReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewReportFindFirstArgs>(args?: SelectSubset<T, ReviewReportFindFirstArgs<ExtArgs>>): Prisma__ReviewReportClient<$Result.GetResult<Prisma.$ReviewReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewReportFindFirstOrThrowArgs} args - Arguments to find a ReviewReport
     * @example
     * // Get one ReviewReport
     * const reviewReport = await prisma.reviewReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewReportClient<$Result.GetResult<Prisma.$ReviewReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReviewReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReviewReports
     * const reviewReports = await prisma.reviewReport.findMany()
     * 
     * // Get first 10 ReviewReports
     * const reviewReports = await prisma.reviewReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewReportWithIdOnly = await prisma.reviewReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewReportFindManyArgs>(args?: SelectSubset<T, ReviewReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReviewReport.
     * @param {ReviewReportCreateArgs} args - Arguments to create a ReviewReport.
     * @example
     * // Create one ReviewReport
     * const ReviewReport = await prisma.reviewReport.create({
     *   data: {
     *     // ... data to create a ReviewReport
     *   }
     * })
     * 
     */
    create<T extends ReviewReportCreateArgs>(args: SelectSubset<T, ReviewReportCreateArgs<ExtArgs>>): Prisma__ReviewReportClient<$Result.GetResult<Prisma.$ReviewReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReviewReports.
     * @param {ReviewReportCreateManyArgs} args - Arguments to create many ReviewReports.
     * @example
     * // Create many ReviewReports
     * const reviewReport = await prisma.reviewReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewReportCreateManyArgs>(args?: SelectSubset<T, ReviewReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReviewReports and returns the data saved in the database.
     * @param {ReviewReportCreateManyAndReturnArgs} args - Arguments to create many ReviewReports.
     * @example
     * // Create many ReviewReports
     * const reviewReport = await prisma.reviewReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReviewReports and only return the `id`
     * const reviewReportWithIdOnly = await prisma.reviewReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReviewReport.
     * @param {ReviewReportDeleteArgs} args - Arguments to delete one ReviewReport.
     * @example
     * // Delete one ReviewReport
     * const ReviewReport = await prisma.reviewReport.delete({
     *   where: {
     *     // ... filter to delete one ReviewReport
     *   }
     * })
     * 
     */
    delete<T extends ReviewReportDeleteArgs>(args: SelectSubset<T, ReviewReportDeleteArgs<ExtArgs>>): Prisma__ReviewReportClient<$Result.GetResult<Prisma.$ReviewReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReviewReport.
     * @param {ReviewReportUpdateArgs} args - Arguments to update one ReviewReport.
     * @example
     * // Update one ReviewReport
     * const reviewReport = await prisma.reviewReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewReportUpdateArgs>(args: SelectSubset<T, ReviewReportUpdateArgs<ExtArgs>>): Prisma__ReviewReportClient<$Result.GetResult<Prisma.$ReviewReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReviewReports.
     * @param {ReviewReportDeleteManyArgs} args - Arguments to filter ReviewReports to delete.
     * @example
     * // Delete a few ReviewReports
     * const { count } = await prisma.reviewReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewReportDeleteManyArgs>(args?: SelectSubset<T, ReviewReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReviewReports
     * const reviewReport = await prisma.reviewReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewReportUpdateManyArgs>(args: SelectSubset<T, ReviewReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewReports and returns the data updated in the database.
     * @param {ReviewReportUpdateManyAndReturnArgs} args - Arguments to update many ReviewReports.
     * @example
     * // Update many ReviewReports
     * const reviewReport = await prisma.reviewReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReviewReports and only return the `id`
     * const reviewReportWithIdOnly = await prisma.reviewReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewReportUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReviewReport.
     * @param {ReviewReportUpsertArgs} args - Arguments to update or create a ReviewReport.
     * @example
     * // Update or create a ReviewReport
     * const reviewReport = await prisma.reviewReport.upsert({
     *   create: {
     *     // ... data to create a ReviewReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReviewReport we want to update
     *   }
     * })
     */
    upsert<T extends ReviewReportUpsertArgs>(args: SelectSubset<T, ReviewReportUpsertArgs<ExtArgs>>): Prisma__ReviewReportClient<$Result.GetResult<Prisma.$ReviewReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReviewReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewReportCountArgs} args - Arguments to filter ReviewReports to count.
     * @example
     * // Count the number of ReviewReports
     * const count = await prisma.reviewReport.count({
     *   where: {
     *     // ... the filter for the ReviewReports we want to count
     *   }
     * })
    **/
    count<T extends ReviewReportCountArgs>(
      args?: Subset<T, ReviewReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReviewReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewReportAggregateArgs>(args: Subset<T, ReviewReportAggregateArgs>): Prisma.PrismaPromise<GetReviewReportAggregateType<T>>

    /**
     * Group by ReviewReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewReportGroupByArgs['orderBy'] }
        : { orderBy?: ReviewReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReviewReport model
   */
  readonly fields: ReviewReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReviewReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    review<T extends ProductReviewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductReviewDefaultArgs<ExtArgs>>): Prisma__ProductReviewClient<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReviewReport model
   */
  interface ReviewReportFieldRefs {
    readonly id: FieldRef<"ReviewReport", 'String'>
    readonly reviewId: FieldRef<"ReviewReport", 'String'>
    readonly userId: FieldRef<"ReviewReport", 'String'>
    readonly reason: FieldRef<"ReviewReport", 'String'>
    readonly createdAt: FieldRef<"ReviewReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReviewReport findUnique
   */
  export type ReviewReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReport
     */
    select?: ReviewReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReport
     */
    omit?: ReviewReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReportInclude<ExtArgs> | null
    /**
     * Filter, which ReviewReport to fetch.
     */
    where: ReviewReportWhereUniqueInput
  }

  /**
   * ReviewReport findUniqueOrThrow
   */
  export type ReviewReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReport
     */
    select?: ReviewReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReport
     */
    omit?: ReviewReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReportInclude<ExtArgs> | null
    /**
     * Filter, which ReviewReport to fetch.
     */
    where: ReviewReportWhereUniqueInput
  }

  /**
   * ReviewReport findFirst
   */
  export type ReviewReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReport
     */
    select?: ReviewReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReport
     */
    omit?: ReviewReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReportInclude<ExtArgs> | null
    /**
     * Filter, which ReviewReport to fetch.
     */
    where?: ReviewReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewReports to fetch.
     */
    orderBy?: ReviewReportOrderByWithRelationInput | ReviewReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewReports.
     */
    cursor?: ReviewReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewReports.
     */
    distinct?: ReviewReportScalarFieldEnum | ReviewReportScalarFieldEnum[]
  }

  /**
   * ReviewReport findFirstOrThrow
   */
  export type ReviewReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReport
     */
    select?: ReviewReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReport
     */
    omit?: ReviewReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReportInclude<ExtArgs> | null
    /**
     * Filter, which ReviewReport to fetch.
     */
    where?: ReviewReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewReports to fetch.
     */
    orderBy?: ReviewReportOrderByWithRelationInput | ReviewReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewReports.
     */
    cursor?: ReviewReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewReports.
     */
    distinct?: ReviewReportScalarFieldEnum | ReviewReportScalarFieldEnum[]
  }

  /**
   * ReviewReport findMany
   */
  export type ReviewReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReport
     */
    select?: ReviewReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReport
     */
    omit?: ReviewReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReportInclude<ExtArgs> | null
    /**
     * Filter, which ReviewReports to fetch.
     */
    where?: ReviewReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewReports to fetch.
     */
    orderBy?: ReviewReportOrderByWithRelationInput | ReviewReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReviewReports.
     */
    cursor?: ReviewReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewReports.
     */
    skip?: number
    distinct?: ReviewReportScalarFieldEnum | ReviewReportScalarFieldEnum[]
  }

  /**
   * ReviewReport create
   */
  export type ReviewReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReport
     */
    select?: ReviewReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReport
     */
    omit?: ReviewReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReportInclude<ExtArgs> | null
    /**
     * The data needed to create a ReviewReport.
     */
    data: XOR<ReviewReportCreateInput, ReviewReportUncheckedCreateInput>
  }

  /**
   * ReviewReport createMany
   */
  export type ReviewReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReviewReports.
     */
    data: ReviewReportCreateManyInput | ReviewReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReviewReport createManyAndReturn
   */
  export type ReviewReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReport
     */
    select?: ReviewReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReport
     */
    omit?: ReviewReportOmit<ExtArgs> | null
    /**
     * The data used to create many ReviewReports.
     */
    data: ReviewReportCreateManyInput | ReviewReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewReport update
   */
  export type ReviewReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReport
     */
    select?: ReviewReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReport
     */
    omit?: ReviewReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReportInclude<ExtArgs> | null
    /**
     * The data needed to update a ReviewReport.
     */
    data: XOR<ReviewReportUpdateInput, ReviewReportUncheckedUpdateInput>
    /**
     * Choose, which ReviewReport to update.
     */
    where: ReviewReportWhereUniqueInput
  }

  /**
   * ReviewReport updateMany
   */
  export type ReviewReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReviewReports.
     */
    data: XOR<ReviewReportUpdateManyMutationInput, ReviewReportUncheckedUpdateManyInput>
    /**
     * Filter which ReviewReports to update
     */
    where?: ReviewReportWhereInput
    /**
     * Limit how many ReviewReports to update.
     */
    limit?: number
  }

  /**
   * ReviewReport updateManyAndReturn
   */
  export type ReviewReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReport
     */
    select?: ReviewReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReport
     */
    omit?: ReviewReportOmit<ExtArgs> | null
    /**
     * The data used to update ReviewReports.
     */
    data: XOR<ReviewReportUpdateManyMutationInput, ReviewReportUncheckedUpdateManyInput>
    /**
     * Filter which ReviewReports to update
     */
    where?: ReviewReportWhereInput
    /**
     * Limit how many ReviewReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewReport upsert
   */
  export type ReviewReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReport
     */
    select?: ReviewReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReport
     */
    omit?: ReviewReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReportInclude<ExtArgs> | null
    /**
     * The filter to search for the ReviewReport to update in case it exists.
     */
    where: ReviewReportWhereUniqueInput
    /**
     * In case the ReviewReport found by the `where` argument doesn't exist, create a new ReviewReport with this data.
     */
    create: XOR<ReviewReportCreateInput, ReviewReportUncheckedCreateInput>
    /**
     * In case the ReviewReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewReportUpdateInput, ReviewReportUncheckedUpdateInput>
  }

  /**
   * ReviewReport delete
   */
  export type ReviewReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReport
     */
    select?: ReviewReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReport
     */
    omit?: ReviewReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReportInclude<ExtArgs> | null
    /**
     * Filter which ReviewReport to delete.
     */
    where: ReviewReportWhereUniqueInput
  }

  /**
   * ReviewReport deleteMany
   */
  export type ReviewReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewReports to delete
     */
    where?: ReviewReportWhereInput
    /**
     * Limit how many ReviewReports to delete.
     */
    limit?: number
  }

  /**
   * ReviewReport without action
   */
  export type ReviewReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReport
     */
    select?: ReviewReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReport
     */
    omit?: ReviewReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReportInclude<ExtArgs> | null
  }


  /**
   * Model VendorReview
   */

  export type AggregateVendorReview = {
    _count: VendorReviewCountAggregateOutputType | null
    _avg: VendorReviewAvgAggregateOutputType | null
    _sum: VendorReviewSumAggregateOutputType | null
    _min: VendorReviewMinAggregateOutputType | null
    _max: VendorReviewMaxAggregateOutputType | null
  }

  export type VendorReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type VendorReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type VendorReviewMinAggregateOutputType = {
    id: string | null
    vendorId: string | null
    customerId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
  }

  export type VendorReviewMaxAggregateOutputType = {
    id: string | null
    vendorId: string | null
    customerId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
  }

  export type VendorReviewCountAggregateOutputType = {
    id: number
    vendorId: number
    customerId: number
    rating: number
    comment: number
    createdAt: number
    _all: number
  }


  export type VendorReviewAvgAggregateInputType = {
    rating?: true
  }

  export type VendorReviewSumAggregateInputType = {
    rating?: true
  }

  export type VendorReviewMinAggregateInputType = {
    id?: true
    vendorId?: true
    customerId?: true
    rating?: true
    comment?: true
    createdAt?: true
  }

  export type VendorReviewMaxAggregateInputType = {
    id?: true
    vendorId?: true
    customerId?: true
    rating?: true
    comment?: true
    createdAt?: true
  }

  export type VendorReviewCountAggregateInputType = {
    id?: true
    vendorId?: true
    customerId?: true
    rating?: true
    comment?: true
    createdAt?: true
    _all?: true
  }

  export type VendorReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorReview to aggregate.
     */
    where?: VendorReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorReviews to fetch.
     */
    orderBy?: VendorReviewOrderByWithRelationInput | VendorReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VendorReviews
    **/
    _count?: true | VendorReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorReviewMaxAggregateInputType
  }

  export type GetVendorReviewAggregateType<T extends VendorReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateVendorReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendorReview[P]>
      : GetScalarType<T[P], AggregateVendorReview[P]>
  }




  export type VendorReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorReviewWhereInput
    orderBy?: VendorReviewOrderByWithAggregationInput | VendorReviewOrderByWithAggregationInput[]
    by: VendorReviewScalarFieldEnum[] | VendorReviewScalarFieldEnum
    having?: VendorReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorReviewCountAggregateInputType | true
    _avg?: VendorReviewAvgAggregateInputType
    _sum?: VendorReviewSumAggregateInputType
    _min?: VendorReviewMinAggregateInputType
    _max?: VendorReviewMaxAggregateInputType
  }

  export type VendorReviewGroupByOutputType = {
    id: string
    vendorId: string
    customerId: string
    rating: number
    comment: string | null
    createdAt: Date
    _count: VendorReviewCountAggregateOutputType | null
    _avg: VendorReviewAvgAggregateOutputType | null
    _sum: VendorReviewSumAggregateOutputType | null
    _min: VendorReviewMinAggregateOutputType | null
    _max: VendorReviewMaxAggregateOutputType | null
  }

  type GetVendorReviewGroupByPayload<T extends VendorReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorReviewGroupByOutputType[P]>
            : GetScalarType<T[P], VendorReviewGroupByOutputType[P]>
        }
      >
    >


  export type VendorReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    customerId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    vendor?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorReview"]>

  export type VendorReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    customerId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    vendor?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorReview"]>

  export type VendorReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    customerId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    vendor?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorReview"]>

  export type VendorReviewSelectScalar = {
    id?: boolean
    vendorId?: boolean
    customerId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
  }

  export type VendorReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vendorId" | "customerId" | "rating" | "comment" | "createdAt", ExtArgs["result"]["vendorReview"]>
  export type VendorReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VendorReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VendorReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VendorReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VendorReview"
    objects: {
      vendor: Prisma.$UserPayload<ExtArgs>
      customer: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendorId: string
      customerId: string
      rating: number
      comment: string | null
      createdAt: Date
    }, ExtArgs["result"]["vendorReview"]>
    composites: {}
  }

  type VendorReviewGetPayload<S extends boolean | null | undefined | VendorReviewDefaultArgs> = $Result.GetResult<Prisma.$VendorReviewPayload, S>

  type VendorReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorReviewCountAggregateInputType | true
    }

  export interface VendorReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VendorReview'], meta: { name: 'VendorReview' } }
    /**
     * Find zero or one VendorReview that matches the filter.
     * @param {VendorReviewFindUniqueArgs} args - Arguments to find a VendorReview
     * @example
     * // Get one VendorReview
     * const vendorReview = await prisma.vendorReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorReviewFindUniqueArgs>(args: SelectSubset<T, VendorReviewFindUniqueArgs<ExtArgs>>): Prisma__VendorReviewClient<$Result.GetResult<Prisma.$VendorReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VendorReview that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorReviewFindUniqueOrThrowArgs} args - Arguments to find a VendorReview
     * @example
     * // Get one VendorReview
     * const vendorReview = await prisma.vendorReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorReviewClient<$Result.GetResult<Prisma.$VendorReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorReviewFindFirstArgs} args - Arguments to find a VendorReview
     * @example
     * // Get one VendorReview
     * const vendorReview = await prisma.vendorReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorReviewFindFirstArgs>(args?: SelectSubset<T, VendorReviewFindFirstArgs<ExtArgs>>): Prisma__VendorReviewClient<$Result.GetResult<Prisma.$VendorReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorReviewFindFirstOrThrowArgs} args - Arguments to find a VendorReview
     * @example
     * // Get one VendorReview
     * const vendorReview = await prisma.vendorReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorReviewClient<$Result.GetResult<Prisma.$VendorReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VendorReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VendorReviews
     * const vendorReviews = await prisma.vendorReview.findMany()
     * 
     * // Get first 10 VendorReviews
     * const vendorReviews = await prisma.vendorReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorReviewWithIdOnly = await prisma.vendorReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorReviewFindManyArgs>(args?: SelectSubset<T, VendorReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VendorReview.
     * @param {VendorReviewCreateArgs} args - Arguments to create a VendorReview.
     * @example
     * // Create one VendorReview
     * const VendorReview = await prisma.vendorReview.create({
     *   data: {
     *     // ... data to create a VendorReview
     *   }
     * })
     * 
     */
    create<T extends VendorReviewCreateArgs>(args: SelectSubset<T, VendorReviewCreateArgs<ExtArgs>>): Prisma__VendorReviewClient<$Result.GetResult<Prisma.$VendorReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VendorReviews.
     * @param {VendorReviewCreateManyArgs} args - Arguments to create many VendorReviews.
     * @example
     * // Create many VendorReviews
     * const vendorReview = await prisma.vendorReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorReviewCreateManyArgs>(args?: SelectSubset<T, VendorReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VendorReviews and returns the data saved in the database.
     * @param {VendorReviewCreateManyAndReturnArgs} args - Arguments to create many VendorReviews.
     * @example
     * // Create many VendorReviews
     * const vendorReview = await prisma.vendorReview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VendorReviews and only return the `id`
     * const vendorReviewWithIdOnly = await prisma.vendorReview.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VendorReview.
     * @param {VendorReviewDeleteArgs} args - Arguments to delete one VendorReview.
     * @example
     * // Delete one VendorReview
     * const VendorReview = await prisma.vendorReview.delete({
     *   where: {
     *     // ... filter to delete one VendorReview
     *   }
     * })
     * 
     */
    delete<T extends VendorReviewDeleteArgs>(args: SelectSubset<T, VendorReviewDeleteArgs<ExtArgs>>): Prisma__VendorReviewClient<$Result.GetResult<Prisma.$VendorReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VendorReview.
     * @param {VendorReviewUpdateArgs} args - Arguments to update one VendorReview.
     * @example
     * // Update one VendorReview
     * const vendorReview = await prisma.vendorReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorReviewUpdateArgs>(args: SelectSubset<T, VendorReviewUpdateArgs<ExtArgs>>): Prisma__VendorReviewClient<$Result.GetResult<Prisma.$VendorReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VendorReviews.
     * @param {VendorReviewDeleteManyArgs} args - Arguments to filter VendorReviews to delete.
     * @example
     * // Delete a few VendorReviews
     * const { count } = await prisma.vendorReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorReviewDeleteManyArgs>(args?: SelectSubset<T, VendorReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VendorReviews
     * const vendorReview = await prisma.vendorReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorReviewUpdateManyArgs>(args: SelectSubset<T, VendorReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorReviews and returns the data updated in the database.
     * @param {VendorReviewUpdateManyAndReturnArgs} args - Arguments to update many VendorReviews.
     * @example
     * // Update many VendorReviews
     * const vendorReview = await prisma.vendorReview.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VendorReviews and only return the `id`
     * const vendorReviewWithIdOnly = await prisma.vendorReview.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VendorReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, VendorReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VendorReview.
     * @param {VendorReviewUpsertArgs} args - Arguments to update or create a VendorReview.
     * @example
     * // Update or create a VendorReview
     * const vendorReview = await prisma.vendorReview.upsert({
     *   create: {
     *     // ... data to create a VendorReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VendorReview we want to update
     *   }
     * })
     */
    upsert<T extends VendorReviewUpsertArgs>(args: SelectSubset<T, VendorReviewUpsertArgs<ExtArgs>>): Prisma__VendorReviewClient<$Result.GetResult<Prisma.$VendorReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VendorReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorReviewCountArgs} args - Arguments to filter VendorReviews to count.
     * @example
     * // Count the number of VendorReviews
     * const count = await prisma.vendorReview.count({
     *   where: {
     *     // ... the filter for the VendorReviews we want to count
     *   }
     * })
    **/
    count<T extends VendorReviewCountArgs>(
      args?: Subset<T, VendorReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VendorReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorReviewAggregateArgs>(args: Subset<T, VendorReviewAggregateArgs>): Prisma.PrismaPromise<GetVendorReviewAggregateType<T>>

    /**
     * Group by VendorReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorReviewGroupByArgs['orderBy'] }
        : { orderBy?: VendorReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VendorReview model
   */
  readonly fields: VendorReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VendorReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VendorReview model
   */
  interface VendorReviewFieldRefs {
    readonly id: FieldRef<"VendorReview", 'String'>
    readonly vendorId: FieldRef<"VendorReview", 'String'>
    readonly customerId: FieldRef<"VendorReview", 'String'>
    readonly rating: FieldRef<"VendorReview", 'Int'>
    readonly comment: FieldRef<"VendorReview", 'String'>
    readonly createdAt: FieldRef<"VendorReview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VendorReview findUnique
   */
  export type VendorReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorReview
     */
    select?: VendorReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorReview
     */
    omit?: VendorReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorReviewInclude<ExtArgs> | null
    /**
     * Filter, which VendorReview to fetch.
     */
    where: VendorReviewWhereUniqueInput
  }

  /**
   * VendorReview findUniqueOrThrow
   */
  export type VendorReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorReview
     */
    select?: VendorReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorReview
     */
    omit?: VendorReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorReviewInclude<ExtArgs> | null
    /**
     * Filter, which VendorReview to fetch.
     */
    where: VendorReviewWhereUniqueInput
  }

  /**
   * VendorReview findFirst
   */
  export type VendorReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorReview
     */
    select?: VendorReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorReview
     */
    omit?: VendorReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorReviewInclude<ExtArgs> | null
    /**
     * Filter, which VendorReview to fetch.
     */
    where?: VendorReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorReviews to fetch.
     */
    orderBy?: VendorReviewOrderByWithRelationInput | VendorReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorReviews.
     */
    cursor?: VendorReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorReviews.
     */
    distinct?: VendorReviewScalarFieldEnum | VendorReviewScalarFieldEnum[]
  }

  /**
   * VendorReview findFirstOrThrow
   */
  export type VendorReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorReview
     */
    select?: VendorReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorReview
     */
    omit?: VendorReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorReviewInclude<ExtArgs> | null
    /**
     * Filter, which VendorReview to fetch.
     */
    where?: VendorReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorReviews to fetch.
     */
    orderBy?: VendorReviewOrderByWithRelationInput | VendorReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorReviews.
     */
    cursor?: VendorReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorReviews.
     */
    distinct?: VendorReviewScalarFieldEnum | VendorReviewScalarFieldEnum[]
  }

  /**
   * VendorReview findMany
   */
  export type VendorReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorReview
     */
    select?: VendorReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorReview
     */
    omit?: VendorReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorReviewInclude<ExtArgs> | null
    /**
     * Filter, which VendorReviews to fetch.
     */
    where?: VendorReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorReviews to fetch.
     */
    orderBy?: VendorReviewOrderByWithRelationInput | VendorReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VendorReviews.
     */
    cursor?: VendorReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorReviews.
     */
    skip?: number
    distinct?: VendorReviewScalarFieldEnum | VendorReviewScalarFieldEnum[]
  }

  /**
   * VendorReview create
   */
  export type VendorReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorReview
     */
    select?: VendorReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorReview
     */
    omit?: VendorReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a VendorReview.
     */
    data: XOR<VendorReviewCreateInput, VendorReviewUncheckedCreateInput>
  }

  /**
   * VendorReview createMany
   */
  export type VendorReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VendorReviews.
     */
    data: VendorReviewCreateManyInput | VendorReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VendorReview createManyAndReturn
   */
  export type VendorReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorReview
     */
    select?: VendorReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorReview
     */
    omit?: VendorReviewOmit<ExtArgs> | null
    /**
     * The data used to create many VendorReviews.
     */
    data: VendorReviewCreateManyInput | VendorReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorReview update
   */
  export type VendorReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorReview
     */
    select?: VendorReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorReview
     */
    omit?: VendorReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a VendorReview.
     */
    data: XOR<VendorReviewUpdateInput, VendorReviewUncheckedUpdateInput>
    /**
     * Choose, which VendorReview to update.
     */
    where: VendorReviewWhereUniqueInput
  }

  /**
   * VendorReview updateMany
   */
  export type VendorReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VendorReviews.
     */
    data: XOR<VendorReviewUpdateManyMutationInput, VendorReviewUncheckedUpdateManyInput>
    /**
     * Filter which VendorReviews to update
     */
    where?: VendorReviewWhereInput
    /**
     * Limit how many VendorReviews to update.
     */
    limit?: number
  }

  /**
   * VendorReview updateManyAndReturn
   */
  export type VendorReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorReview
     */
    select?: VendorReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorReview
     */
    omit?: VendorReviewOmit<ExtArgs> | null
    /**
     * The data used to update VendorReviews.
     */
    data: XOR<VendorReviewUpdateManyMutationInput, VendorReviewUncheckedUpdateManyInput>
    /**
     * Filter which VendorReviews to update
     */
    where?: VendorReviewWhereInput
    /**
     * Limit how many VendorReviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorReview upsert
   */
  export type VendorReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorReview
     */
    select?: VendorReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorReview
     */
    omit?: VendorReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the VendorReview to update in case it exists.
     */
    where: VendorReviewWhereUniqueInput
    /**
     * In case the VendorReview found by the `where` argument doesn't exist, create a new VendorReview with this data.
     */
    create: XOR<VendorReviewCreateInput, VendorReviewUncheckedCreateInput>
    /**
     * In case the VendorReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorReviewUpdateInput, VendorReviewUncheckedUpdateInput>
  }

  /**
   * VendorReview delete
   */
  export type VendorReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorReview
     */
    select?: VendorReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorReview
     */
    omit?: VendorReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorReviewInclude<ExtArgs> | null
    /**
     * Filter which VendorReview to delete.
     */
    where: VendorReviewWhereUniqueInput
  }

  /**
   * VendorReview deleteMany
   */
  export type VendorReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorReviews to delete
     */
    where?: VendorReviewWhereInput
    /**
     * Limit how many VendorReviews to delete.
     */
    limit?: number
  }

  /**
   * VendorReview without action
   */
  export type VendorReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorReview
     */
    select?: VendorReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorReview
     */
    omit?: VendorReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorReviewInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    type: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    type: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    message: number
    type: number
    metadata: number
    read: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    read?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    read?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    metadata?: true
    read?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    title: string
    message: string
    type: string
    metadata: JsonValue | null
    read: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    metadata?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    metadata?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    metadata?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    metadata?: boolean
    read?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "message" | "type" | "metadata" | "read" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      message: string
      type: string
      metadata: Prisma.JsonValue | null
      read: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly metadata: FieldRef<"Notification", 'Json'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model LoginHistory
   */

  export type AggregateLoginHistory = {
    _count: LoginHistoryCountAggregateOutputType | null
    _min: LoginHistoryMinAggregateOutputType | null
    _max: LoginHistoryMaxAggregateOutputType | null
  }

  export type LoginHistoryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    method: string | null
    deviceId: string | null
    location: string | null
    ip: string | null
    userAgent: string | null
    geoCity: string | null
    geoRegion: string | null
    geoCountry: string | null
    createdAt: Date | null
  }

  export type LoginHistoryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    method: string | null
    deviceId: string | null
    location: string | null
    ip: string | null
    userAgent: string | null
    geoCity: string | null
    geoRegion: string | null
    geoCountry: string | null
    createdAt: Date | null
  }

  export type LoginHistoryCountAggregateOutputType = {
    id: number
    userId: number
    method: number
    deviceId: number
    location: number
    ip: number
    userAgent: number
    geoCity: number
    geoRegion: number
    geoCountry: number
    createdAt: number
    _all: number
  }


  export type LoginHistoryMinAggregateInputType = {
    id?: true
    userId?: true
    method?: true
    deviceId?: true
    location?: true
    ip?: true
    userAgent?: true
    geoCity?: true
    geoRegion?: true
    geoCountry?: true
    createdAt?: true
  }

  export type LoginHistoryMaxAggregateInputType = {
    id?: true
    userId?: true
    method?: true
    deviceId?: true
    location?: true
    ip?: true
    userAgent?: true
    geoCity?: true
    geoRegion?: true
    geoCountry?: true
    createdAt?: true
  }

  export type LoginHistoryCountAggregateInputType = {
    id?: true
    userId?: true
    method?: true
    deviceId?: true
    location?: true
    ip?: true
    userAgent?: true
    geoCity?: true
    geoRegion?: true
    geoCountry?: true
    createdAt?: true
    _all?: true
  }

  export type LoginHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoginHistory to aggregate.
     */
    where?: LoginHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginHistories to fetch.
     */
    orderBy?: LoginHistoryOrderByWithRelationInput | LoginHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoginHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoginHistories
    **/
    _count?: true | LoginHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoginHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoginHistoryMaxAggregateInputType
  }

  export type GetLoginHistoryAggregateType<T extends LoginHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateLoginHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoginHistory[P]>
      : GetScalarType<T[P], AggregateLoginHistory[P]>
  }




  export type LoginHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoginHistoryWhereInput
    orderBy?: LoginHistoryOrderByWithAggregationInput | LoginHistoryOrderByWithAggregationInput[]
    by: LoginHistoryScalarFieldEnum[] | LoginHistoryScalarFieldEnum
    having?: LoginHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoginHistoryCountAggregateInputType | true
    _min?: LoginHistoryMinAggregateInputType
    _max?: LoginHistoryMaxAggregateInputType
  }

  export type LoginHistoryGroupByOutputType = {
    id: string
    userId: string
    method: string
    deviceId: string | null
    location: string | null
    ip: string | null
    userAgent: string | null
    geoCity: string | null
    geoRegion: string | null
    geoCountry: string | null
    createdAt: Date
    _count: LoginHistoryCountAggregateOutputType | null
    _min: LoginHistoryMinAggregateOutputType | null
    _max: LoginHistoryMaxAggregateOutputType | null
  }

  type GetLoginHistoryGroupByPayload<T extends LoginHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoginHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoginHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoginHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], LoginHistoryGroupByOutputType[P]>
        }
      >
    >


  export type LoginHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    method?: boolean
    deviceId?: boolean
    location?: boolean
    ip?: boolean
    userAgent?: boolean
    geoCity?: boolean
    geoRegion?: boolean
    geoCountry?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loginHistory"]>

  export type LoginHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    method?: boolean
    deviceId?: boolean
    location?: boolean
    ip?: boolean
    userAgent?: boolean
    geoCity?: boolean
    geoRegion?: boolean
    geoCountry?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loginHistory"]>

  export type LoginHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    method?: boolean
    deviceId?: boolean
    location?: boolean
    ip?: boolean
    userAgent?: boolean
    geoCity?: boolean
    geoRegion?: boolean
    geoCountry?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loginHistory"]>

  export type LoginHistorySelectScalar = {
    id?: boolean
    userId?: boolean
    method?: boolean
    deviceId?: boolean
    location?: boolean
    ip?: boolean
    userAgent?: boolean
    geoCity?: boolean
    geoRegion?: boolean
    geoCountry?: boolean
    createdAt?: boolean
  }

  export type LoginHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "method" | "deviceId" | "location" | "ip" | "userAgent" | "geoCity" | "geoRegion" | "geoCountry" | "createdAt", ExtArgs["result"]["loginHistory"]>
  export type LoginHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LoginHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LoginHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LoginHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LoginHistory"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      method: string
      deviceId: string | null
      location: string | null
      ip: string | null
      userAgent: string | null
      geoCity: string | null
      geoRegion: string | null
      geoCountry: string | null
      createdAt: Date
    }, ExtArgs["result"]["loginHistory"]>
    composites: {}
  }

  type LoginHistoryGetPayload<S extends boolean | null | undefined | LoginHistoryDefaultArgs> = $Result.GetResult<Prisma.$LoginHistoryPayload, S>

  type LoginHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LoginHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LoginHistoryCountAggregateInputType | true
    }

  export interface LoginHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoginHistory'], meta: { name: 'LoginHistory' } }
    /**
     * Find zero or one LoginHistory that matches the filter.
     * @param {LoginHistoryFindUniqueArgs} args - Arguments to find a LoginHistory
     * @example
     * // Get one LoginHistory
     * const loginHistory = await prisma.loginHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoginHistoryFindUniqueArgs>(args: SelectSubset<T, LoginHistoryFindUniqueArgs<ExtArgs>>): Prisma__LoginHistoryClient<$Result.GetResult<Prisma.$LoginHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LoginHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LoginHistoryFindUniqueOrThrowArgs} args - Arguments to find a LoginHistory
     * @example
     * // Get one LoginHistory
     * const loginHistory = await prisma.loginHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoginHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, LoginHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoginHistoryClient<$Result.GetResult<Prisma.$LoginHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoginHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginHistoryFindFirstArgs} args - Arguments to find a LoginHistory
     * @example
     * // Get one LoginHistory
     * const loginHistory = await prisma.loginHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoginHistoryFindFirstArgs>(args?: SelectSubset<T, LoginHistoryFindFirstArgs<ExtArgs>>): Prisma__LoginHistoryClient<$Result.GetResult<Prisma.$LoginHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoginHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginHistoryFindFirstOrThrowArgs} args - Arguments to find a LoginHistory
     * @example
     * // Get one LoginHistory
     * const loginHistory = await prisma.loginHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoginHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, LoginHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoginHistoryClient<$Result.GetResult<Prisma.$LoginHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LoginHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoginHistories
     * const loginHistories = await prisma.loginHistory.findMany()
     * 
     * // Get first 10 LoginHistories
     * const loginHistories = await prisma.loginHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loginHistoryWithIdOnly = await prisma.loginHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoginHistoryFindManyArgs>(args?: SelectSubset<T, LoginHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoginHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LoginHistory.
     * @param {LoginHistoryCreateArgs} args - Arguments to create a LoginHistory.
     * @example
     * // Create one LoginHistory
     * const LoginHistory = await prisma.loginHistory.create({
     *   data: {
     *     // ... data to create a LoginHistory
     *   }
     * })
     * 
     */
    create<T extends LoginHistoryCreateArgs>(args: SelectSubset<T, LoginHistoryCreateArgs<ExtArgs>>): Prisma__LoginHistoryClient<$Result.GetResult<Prisma.$LoginHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LoginHistories.
     * @param {LoginHistoryCreateManyArgs} args - Arguments to create many LoginHistories.
     * @example
     * // Create many LoginHistories
     * const loginHistory = await prisma.loginHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoginHistoryCreateManyArgs>(args?: SelectSubset<T, LoginHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LoginHistories and returns the data saved in the database.
     * @param {LoginHistoryCreateManyAndReturnArgs} args - Arguments to create many LoginHistories.
     * @example
     * // Create many LoginHistories
     * const loginHistory = await prisma.loginHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LoginHistories and only return the `id`
     * const loginHistoryWithIdOnly = await prisma.loginHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoginHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, LoginHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoginHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LoginHistory.
     * @param {LoginHistoryDeleteArgs} args - Arguments to delete one LoginHistory.
     * @example
     * // Delete one LoginHistory
     * const LoginHistory = await prisma.loginHistory.delete({
     *   where: {
     *     // ... filter to delete one LoginHistory
     *   }
     * })
     * 
     */
    delete<T extends LoginHistoryDeleteArgs>(args: SelectSubset<T, LoginHistoryDeleteArgs<ExtArgs>>): Prisma__LoginHistoryClient<$Result.GetResult<Prisma.$LoginHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LoginHistory.
     * @param {LoginHistoryUpdateArgs} args - Arguments to update one LoginHistory.
     * @example
     * // Update one LoginHistory
     * const loginHistory = await prisma.loginHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoginHistoryUpdateArgs>(args: SelectSubset<T, LoginHistoryUpdateArgs<ExtArgs>>): Prisma__LoginHistoryClient<$Result.GetResult<Prisma.$LoginHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LoginHistories.
     * @param {LoginHistoryDeleteManyArgs} args - Arguments to filter LoginHistories to delete.
     * @example
     * // Delete a few LoginHistories
     * const { count } = await prisma.loginHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoginHistoryDeleteManyArgs>(args?: SelectSubset<T, LoginHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoginHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoginHistories
     * const loginHistory = await prisma.loginHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoginHistoryUpdateManyArgs>(args: SelectSubset<T, LoginHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoginHistories and returns the data updated in the database.
     * @param {LoginHistoryUpdateManyAndReturnArgs} args - Arguments to update many LoginHistories.
     * @example
     * // Update many LoginHistories
     * const loginHistory = await prisma.loginHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LoginHistories and only return the `id`
     * const loginHistoryWithIdOnly = await prisma.loginHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LoginHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, LoginHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoginHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LoginHistory.
     * @param {LoginHistoryUpsertArgs} args - Arguments to update or create a LoginHistory.
     * @example
     * // Update or create a LoginHistory
     * const loginHistory = await prisma.loginHistory.upsert({
     *   create: {
     *     // ... data to create a LoginHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoginHistory we want to update
     *   }
     * })
     */
    upsert<T extends LoginHistoryUpsertArgs>(args: SelectSubset<T, LoginHistoryUpsertArgs<ExtArgs>>): Prisma__LoginHistoryClient<$Result.GetResult<Prisma.$LoginHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LoginHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginHistoryCountArgs} args - Arguments to filter LoginHistories to count.
     * @example
     * // Count the number of LoginHistories
     * const count = await prisma.loginHistory.count({
     *   where: {
     *     // ... the filter for the LoginHistories we want to count
     *   }
     * })
    **/
    count<T extends LoginHistoryCountArgs>(
      args?: Subset<T, LoginHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoginHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoginHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoginHistoryAggregateArgs>(args: Subset<T, LoginHistoryAggregateArgs>): Prisma.PrismaPromise<GetLoginHistoryAggregateType<T>>

    /**
     * Group by LoginHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoginHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoginHistoryGroupByArgs['orderBy'] }
        : { orderBy?: LoginHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoginHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoginHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LoginHistory model
   */
  readonly fields: LoginHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LoginHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoginHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LoginHistory model
   */
  interface LoginHistoryFieldRefs {
    readonly id: FieldRef<"LoginHistory", 'String'>
    readonly userId: FieldRef<"LoginHistory", 'String'>
    readonly method: FieldRef<"LoginHistory", 'String'>
    readonly deviceId: FieldRef<"LoginHistory", 'String'>
    readonly location: FieldRef<"LoginHistory", 'String'>
    readonly ip: FieldRef<"LoginHistory", 'String'>
    readonly userAgent: FieldRef<"LoginHistory", 'String'>
    readonly geoCity: FieldRef<"LoginHistory", 'String'>
    readonly geoRegion: FieldRef<"LoginHistory", 'String'>
    readonly geoCountry: FieldRef<"LoginHistory", 'String'>
    readonly createdAt: FieldRef<"LoginHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LoginHistory findUnique
   */
  export type LoginHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginHistory
     */
    select?: LoginHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginHistory
     */
    omit?: LoginHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginHistoryInclude<ExtArgs> | null
    /**
     * Filter, which LoginHistory to fetch.
     */
    where: LoginHistoryWhereUniqueInput
  }

  /**
   * LoginHistory findUniqueOrThrow
   */
  export type LoginHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginHistory
     */
    select?: LoginHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginHistory
     */
    omit?: LoginHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginHistoryInclude<ExtArgs> | null
    /**
     * Filter, which LoginHistory to fetch.
     */
    where: LoginHistoryWhereUniqueInput
  }

  /**
   * LoginHistory findFirst
   */
  export type LoginHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginHistory
     */
    select?: LoginHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginHistory
     */
    omit?: LoginHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginHistoryInclude<ExtArgs> | null
    /**
     * Filter, which LoginHistory to fetch.
     */
    where?: LoginHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginHistories to fetch.
     */
    orderBy?: LoginHistoryOrderByWithRelationInput | LoginHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoginHistories.
     */
    cursor?: LoginHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoginHistories.
     */
    distinct?: LoginHistoryScalarFieldEnum | LoginHistoryScalarFieldEnum[]
  }

  /**
   * LoginHistory findFirstOrThrow
   */
  export type LoginHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginHistory
     */
    select?: LoginHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginHistory
     */
    omit?: LoginHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginHistoryInclude<ExtArgs> | null
    /**
     * Filter, which LoginHistory to fetch.
     */
    where?: LoginHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginHistories to fetch.
     */
    orderBy?: LoginHistoryOrderByWithRelationInput | LoginHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoginHistories.
     */
    cursor?: LoginHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoginHistories.
     */
    distinct?: LoginHistoryScalarFieldEnum | LoginHistoryScalarFieldEnum[]
  }

  /**
   * LoginHistory findMany
   */
  export type LoginHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginHistory
     */
    select?: LoginHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginHistory
     */
    omit?: LoginHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginHistoryInclude<ExtArgs> | null
    /**
     * Filter, which LoginHistories to fetch.
     */
    where?: LoginHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginHistories to fetch.
     */
    orderBy?: LoginHistoryOrderByWithRelationInput | LoginHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoginHistories.
     */
    cursor?: LoginHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginHistories.
     */
    skip?: number
    distinct?: LoginHistoryScalarFieldEnum | LoginHistoryScalarFieldEnum[]
  }

  /**
   * LoginHistory create
   */
  export type LoginHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginHistory
     */
    select?: LoginHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginHistory
     */
    omit?: LoginHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a LoginHistory.
     */
    data: XOR<LoginHistoryCreateInput, LoginHistoryUncheckedCreateInput>
  }

  /**
   * LoginHistory createMany
   */
  export type LoginHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LoginHistories.
     */
    data: LoginHistoryCreateManyInput | LoginHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LoginHistory createManyAndReturn
   */
  export type LoginHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginHistory
     */
    select?: LoginHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoginHistory
     */
    omit?: LoginHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many LoginHistories.
     */
    data: LoginHistoryCreateManyInput | LoginHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoginHistory update
   */
  export type LoginHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginHistory
     */
    select?: LoginHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginHistory
     */
    omit?: LoginHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a LoginHistory.
     */
    data: XOR<LoginHistoryUpdateInput, LoginHistoryUncheckedUpdateInput>
    /**
     * Choose, which LoginHistory to update.
     */
    where: LoginHistoryWhereUniqueInput
  }

  /**
   * LoginHistory updateMany
   */
  export type LoginHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LoginHistories.
     */
    data: XOR<LoginHistoryUpdateManyMutationInput, LoginHistoryUncheckedUpdateManyInput>
    /**
     * Filter which LoginHistories to update
     */
    where?: LoginHistoryWhereInput
    /**
     * Limit how many LoginHistories to update.
     */
    limit?: number
  }

  /**
   * LoginHistory updateManyAndReturn
   */
  export type LoginHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginHistory
     */
    select?: LoginHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoginHistory
     */
    omit?: LoginHistoryOmit<ExtArgs> | null
    /**
     * The data used to update LoginHistories.
     */
    data: XOR<LoginHistoryUpdateManyMutationInput, LoginHistoryUncheckedUpdateManyInput>
    /**
     * Filter which LoginHistories to update
     */
    where?: LoginHistoryWhereInput
    /**
     * Limit how many LoginHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoginHistory upsert
   */
  export type LoginHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginHistory
     */
    select?: LoginHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginHistory
     */
    omit?: LoginHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the LoginHistory to update in case it exists.
     */
    where: LoginHistoryWhereUniqueInput
    /**
     * In case the LoginHistory found by the `where` argument doesn't exist, create a new LoginHistory with this data.
     */
    create: XOR<LoginHistoryCreateInput, LoginHistoryUncheckedCreateInput>
    /**
     * In case the LoginHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoginHistoryUpdateInput, LoginHistoryUncheckedUpdateInput>
  }

  /**
   * LoginHistory delete
   */
  export type LoginHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginHistory
     */
    select?: LoginHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginHistory
     */
    omit?: LoginHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginHistoryInclude<ExtArgs> | null
    /**
     * Filter which LoginHistory to delete.
     */
    where: LoginHistoryWhereUniqueInput
  }

  /**
   * LoginHistory deleteMany
   */
  export type LoginHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoginHistories to delete
     */
    where?: LoginHistoryWhereInput
    /**
     * Limit how many LoginHistories to delete.
     */
    limit?: number
  }

  /**
   * LoginHistory without action
   */
  export type LoginHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginHistory
     */
    select?: LoginHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginHistory
     */
    omit?: LoginHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginHistoryInclude<ExtArgs> | null
  }


  /**
   * Model PasswordResetToken
   */

  export type AggregatePasswordResetToken = {
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  export type PasswordResetTokenMinAggregateOutputType = {
    userId: string | null
    token: string | null
    expiresAt: Date | null
  }

  export type PasswordResetTokenMaxAggregateOutputType = {
    userId: string | null
    token: string | null
    expiresAt: Date | null
  }

  export type PasswordResetTokenCountAggregateOutputType = {
    userId: number
    token: number
    expiresAt: number
    _all: number
  }


  export type PasswordResetTokenMinAggregateInputType = {
    userId?: true
    token?: true
    expiresAt?: true
  }

  export type PasswordResetTokenMaxAggregateInputType = {
    userId?: true
    token?: true
    expiresAt?: true
  }

  export type PasswordResetTokenCountAggregateInputType = {
    userId?: true
    token?: true
    expiresAt?: true
    _all?: true
  }

  export type PasswordResetTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetToken to aggregate.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResetTokens
    **/
    _count?: true | PasswordResetTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type GetPasswordResetTokenAggregateType<T extends PasswordResetTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResetToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetToken[P]>
      : GetScalarType<T[P], AggregatePasswordResetToken[P]>
  }




  export type PasswordResetTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithAggregationInput | PasswordResetTokenOrderByWithAggregationInput[]
    by: PasswordResetTokenScalarFieldEnum[] | PasswordResetTokenScalarFieldEnum
    having?: PasswordResetTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetTokenCountAggregateInputType | true
    _min?: PasswordResetTokenMinAggregateInputType
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type PasswordResetTokenGroupByOutputType = {
    userId: string
    token: string
    expiresAt: Date
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  type GetPasswordResetTokenGroupByPayload<T extends PasswordResetTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectScalar = {
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
  }

  export type PasswordResetTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "token" | "expiresAt", ExtArgs["result"]["passwordResetToken"]>
  export type PasswordResetTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordResetTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResetToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      token: string
      expiresAt: Date
    }, ExtArgs["result"]["passwordResetToken"]>
    composites: {}
  }

  type PasswordResetTokenGetPayload<S extends boolean | null | undefined | PasswordResetTokenDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetTokenPayload, S>

  type PasswordResetTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordResetTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordResetTokenCountAggregateInputType | true
    }

  export interface PasswordResetTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetToken'], meta: { name: 'PasswordResetToken' } }
    /**
     * Find zero or one PasswordResetToken that matches the filter.
     * @param {PasswordResetTokenFindUniqueArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetTokenFindUniqueArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordResetToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordResetTokenFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetTokenFindFirstArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordResetTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany()
     * 
     * // Get first 10 PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const passwordResetTokenWithUserIdOnly = await prisma.passwordResetToken.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends PasswordResetTokenFindManyArgs>(args?: SelectSubset<T, PasswordResetTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordResetToken.
     * @param {PasswordResetTokenCreateArgs} args - Arguments to create a PasswordResetToken.
     * @example
     * // Create one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.create({
     *   data: {
     *     // ... data to create a PasswordResetToken
     *   }
     * })
     * 
     */
    create<T extends PasswordResetTokenCreateArgs>(args: SelectSubset<T, PasswordResetTokenCreateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordResetTokens.
     * @param {PasswordResetTokenCreateManyArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetTokenCreateManyArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResetTokens and returns the data saved in the database.
     * @param {PasswordResetTokenCreateManyAndReturnArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResetTokens and only return the `userId`
     * const passwordResetTokenWithUserIdOnly = await prisma.passwordResetToken.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordResetToken.
     * @param {PasswordResetTokenDeleteArgs} args - Arguments to delete one PasswordResetToken.
     * @example
     * // Delete one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetToken
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetTokenDeleteArgs>(args: SelectSubset<T, PasswordResetTokenDeleteArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordResetToken.
     * @param {PasswordResetTokenUpdateArgs} args - Arguments to update one PasswordResetToken.
     * @example
     * // Update one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetTokenUpdateArgs>(args: SelectSubset<T, PasswordResetTokenUpdateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordResetTokens.
     * @param {PasswordResetTokenDeleteManyArgs} args - Arguments to filter PasswordResetTokens to delete.
     * @example
     * // Delete a few PasswordResetTokens
     * const { count } = await prisma.passwordResetToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetTokenDeleteManyArgs>(args?: SelectSubset<T, PasswordResetTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetTokenUpdateManyArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens and returns the data updated in the database.
     * @param {PasswordResetTokenUpdateManyAndReturnArgs} args - Arguments to update many PasswordResetTokens.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordResetTokens and only return the `userId`
     * const passwordResetTokenWithUserIdOnly = await prisma.passwordResetToken.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordResetTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordResetToken.
     * @param {PasswordResetTokenUpsertArgs} args - Arguments to update or create a PasswordResetToken.
     * @example
     * // Update or create a PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.upsert({
     *   create: {
     *     // ... data to create a PasswordResetToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetToken we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetTokenUpsertArgs>(args: SelectSubset<T, PasswordResetTokenUpsertArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenCountArgs} args - Arguments to filter PasswordResetTokens to count.
     * @example
     * // Count the number of PasswordResetTokens
     * const count = await prisma.passwordResetToken.count({
     *   where: {
     *     // ... the filter for the PasswordResetTokens we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetTokenCountArgs>(
      args?: Subset<T, PasswordResetTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetTokenAggregateArgs>(args: Subset<T, PasswordResetTokenAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetTokenAggregateType<T>>

    /**
     * Group by PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetTokenGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResetToken model
   */
  readonly fields: PasswordResetTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordResetToken model
   */
  interface PasswordResetTokenFieldRefs {
    readonly userId: FieldRef<"PasswordResetToken", 'String'>
    readonly token: FieldRef<"PasswordResetToken", 'String'>
    readonly expiresAt: FieldRef<"PasswordResetToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordResetToken findUnique
   */
  export type PasswordResetTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findUniqueOrThrow
   */
  export type PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findFirst
   */
  export type PasswordResetTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findFirstOrThrow
   */
  export type PasswordResetTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findMany
   */
  export type PasswordResetTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetTokens to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken create
   */
  export type PasswordResetTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
  }

  /**
   * PasswordResetToken createMany
   */
  export type PasswordResetTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken createManyAndReturn
   */
  export type PasswordResetTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordResetToken update
   */
  export type PasswordResetTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
    /**
     * Choose, which PasswordResetToken to update.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken updateMany
   */
  export type PasswordResetTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
  }

  /**
   * PasswordResetToken updateManyAndReturn
   */
  export type PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordResetToken upsert
   */
  export type PasswordResetTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordResetToken to update in case it exists.
     */
    where: PasswordResetTokenWhereUniqueInput
    /**
     * In case the PasswordResetToken found by the `where` argument doesn't exist, create a new PasswordResetToken with this data.
     */
    create: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
    /**
     * In case the PasswordResetToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
  }

  /**
   * PasswordResetToken delete
   */
  export type PasswordResetTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter which PasswordResetToken to delete.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken deleteMany
   */
  export type PasswordResetTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetTokens to delete
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to delete.
     */
    limit?: number
  }

  /**
   * PasswordResetToken without action
   */
  export type PasswordResetTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    orderId: string | null
    amount: number | null
    reference: string | null
    status: string | null
    channel: string | null
    ipAddress: string | null
    userAgent: string | null
    deviceId: string | null
    geoCity: string | null
    geoCountry: string | null
    createdAt: Date | null
    updatedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    expiresAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    orderId: string | null
    amount: number | null
    reference: string | null
    status: string | null
    channel: string | null
    ipAddress: string | null
    userAgent: string | null
    deviceId: string | null
    geoCity: string | null
    geoCountry: string | null
    createdAt: Date | null
    updatedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    expiresAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    userId: number
    orderId: number
    amount: number
    reference: number
    status: number
    paystackData: number
    channel: number
    ipAddress: number
    userAgent: number
    deviceId: number
    geoCity: number
    geoCountry: number
    createdAt: number
    updatedAt: number
    metadata: number
    startedAt: number
    completedAt: number
    expiresAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    userId?: true
    orderId?: true
    amount?: true
    reference?: true
    status?: true
    channel?: true
    ipAddress?: true
    userAgent?: true
    deviceId?: true
    geoCity?: true
    geoCountry?: true
    createdAt?: true
    updatedAt?: true
    startedAt?: true
    completedAt?: true
    expiresAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    userId?: true
    orderId?: true
    amount?: true
    reference?: true
    status?: true
    channel?: true
    ipAddress?: true
    userAgent?: true
    deviceId?: true
    geoCity?: true
    geoCountry?: true
    createdAt?: true
    updatedAt?: true
    startedAt?: true
    completedAt?: true
    expiresAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    userId?: true
    orderId?: true
    amount?: true
    reference?: true
    status?: true
    paystackData?: true
    channel?: true
    ipAddress?: true
    userAgent?: true
    deviceId?: true
    geoCity?: true
    geoCountry?: true
    createdAt?: true
    updatedAt?: true
    metadata?: true
    startedAt?: true
    completedAt?: true
    expiresAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    userId: string
    orderId: string
    amount: number
    reference: string
    status: string
    paystackData: JsonValue | null
    channel: string | null
    ipAddress: string
    userAgent: string
    deviceId: string | null
    geoCity: string | null
    geoCountry: string | null
    createdAt: Date
    updatedAt: Date
    metadata: JsonValue | null
    startedAt: Date | null
    completedAt: Date | null
    expiresAt: Date | null
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    orderId?: boolean
    amount?: boolean
    reference?: boolean
    status?: boolean
    paystackData?: boolean
    channel?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceId?: boolean
    geoCity?: boolean
    geoCountry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metadata?: boolean
    startedAt?: boolean
    completedAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    Receipt?: boolean | Payment$ReceiptArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    orderId?: boolean
    amount?: boolean
    reference?: boolean
    status?: boolean
    paystackData?: boolean
    channel?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceId?: boolean
    geoCity?: boolean
    geoCountry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metadata?: boolean
    startedAt?: boolean
    completedAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    orderId?: boolean
    amount?: boolean
    reference?: boolean
    status?: boolean
    paystackData?: boolean
    channel?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceId?: boolean
    geoCity?: boolean
    geoCountry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metadata?: boolean
    startedAt?: boolean
    completedAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    userId?: boolean
    orderId?: boolean
    amount?: boolean
    reference?: boolean
    status?: boolean
    paystackData?: boolean
    channel?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceId?: boolean
    geoCity?: boolean
    geoCountry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metadata?: boolean
    startedAt?: boolean
    completedAt?: boolean
    expiresAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "orderId" | "amount" | "reference" | "status" | "paystackData" | "channel" | "ipAddress" | "userAgent" | "deviceId" | "geoCity" | "geoCountry" | "createdAt" | "updatedAt" | "metadata" | "startedAt" | "completedAt" | "expiresAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    Receipt?: boolean | Payment$ReceiptArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs>
      Receipt: Prisma.$ReceiptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      orderId: string
      amount: number
      reference: string
      status: string
      paystackData: Prisma.JsonValue | null
      channel: string | null
      ipAddress: string
      userAgent: string
      deviceId: string | null
      geoCity: string | null
      geoCountry: string | null
      createdAt: Date
      updatedAt: Date
      metadata: Prisma.JsonValue | null
      startedAt: Date | null
      completedAt: Date | null
      expiresAt: Date | null
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Receipt<T extends Payment$ReceiptArgs<ExtArgs> = {}>(args?: Subset<T, Payment$ReceiptArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly userId: FieldRef<"Payment", 'String'>
    readonly orderId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Int'>
    readonly reference: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'String'>
    readonly paystackData: FieldRef<"Payment", 'Json'>
    readonly channel: FieldRef<"Payment", 'String'>
    readonly ipAddress: FieldRef<"Payment", 'String'>
    readonly userAgent: FieldRef<"Payment", 'String'>
    readonly deviceId: FieldRef<"Payment", 'String'>
    readonly geoCity: FieldRef<"Payment", 'String'>
    readonly geoCountry: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
    readonly metadata: FieldRef<"Payment", 'Json'>
    readonly startedAt: FieldRef<"Payment", 'DateTime'>
    readonly completedAt: FieldRef<"Payment", 'DateTime'>
    readonly expiresAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.Receipt
   */
  export type Payment$ReceiptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    where?: ReceiptWhereInput
    orderBy?: ReceiptOrderByWithRelationInput | ReceiptOrderByWithRelationInput[]
    cursor?: ReceiptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReceiptScalarFieldEnum | ReceiptScalarFieldEnum[]
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    ipAddress: string | null
    userAgent: string | null
    deviceId: string | null
    geoCity: string | null
    geoRegion: string | null
    geoCountry: string | null
    path: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    ipAddress: string | null
    userAgent: string | null
    deviceId: string | null
    geoCity: string | null
    geoRegion: string | null
    geoCountry: string | null
    path: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    ipAddress: number
    userAgent: number
    deviceId: number
    geoCity: number
    geoRegion: number
    geoCountry: number
    details: number
    path: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    ipAddress?: true
    userAgent?: true
    deviceId?: true
    geoCity?: true
    geoRegion?: true
    geoCountry?: true
    path?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    ipAddress?: true
    userAgent?: true
    deviceId?: true
    geoCity?: true
    geoRegion?: true
    geoCountry?: true
    path?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    ipAddress?: true
    userAgent?: true
    deviceId?: true
    geoCity?: true
    geoRegion?: true
    geoCountry?: true
    details?: true
    path?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string | null
    action: string
    ipAddress: string
    userAgent: string
    deviceId: string | null
    geoCity: string | null
    geoRegion: string | null
    geoCountry: string | null
    details: JsonValue | null
    path: string
    metadata: JsonValue | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceId?: boolean
    geoCity?: boolean
    geoRegion?: boolean
    geoCountry?: boolean
    details?: boolean
    path?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceId?: boolean
    geoCity?: boolean
    geoRegion?: boolean
    geoCountry?: boolean
    details?: boolean
    path?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceId?: boolean
    geoCity?: boolean
    geoRegion?: boolean
    geoCountry?: boolean
    details?: boolean
    path?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    deviceId?: boolean
    geoCity?: boolean
    geoRegion?: boolean
    geoCountry?: boolean
    details?: boolean
    path?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "ipAddress" | "userAgent" | "deviceId" | "geoCity" | "geoRegion" | "geoCountry" | "details" | "path" | "metadata" | "createdAt", ExtArgs["result"]["auditLog"]>

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      action: string
      ipAddress: string
      userAgent: string
      deviceId: string | null
      geoCity: string | null
      geoRegion: string | null
      geoCountry: string | null
      details: Prisma.JsonValue | null
      path: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly deviceId: FieldRef<"AuditLog", 'String'>
    readonly geoCity: FieldRef<"AuditLog", 'String'>
    readonly geoRegion: FieldRef<"AuditLog", 'String'>
    readonly geoCountry: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'Json'>
    readonly path: FieldRef<"AuditLog", 'String'>
    readonly metadata: FieldRef<"AuditLog", 'Json'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
  }


  /**
   * Model RefundRequest
   */

  export type AggregateRefundRequest = {
    _count: RefundRequestCountAggregateOutputType | null
    _min: RefundRequestMinAggregateOutputType | null
    _max: RefundRequestMaxAggregateOutputType | null
  }

  export type RefundRequestMinAggregateOutputType = {
    id: string | null
    userId: string | null
    paymentRef: string | null
    reason: string | null
    status: $Enums.RefundStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RefundRequestMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    paymentRef: string | null
    reason: string | null
    status: $Enums.RefundStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RefundRequestCountAggregateOutputType = {
    id: number
    userId: number
    paymentRef: number
    reason: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RefundRequestMinAggregateInputType = {
    id?: true
    userId?: true
    paymentRef?: true
    reason?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RefundRequestMaxAggregateInputType = {
    id?: true
    userId?: true
    paymentRef?: true
    reason?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RefundRequestCountAggregateInputType = {
    id?: true
    userId?: true
    paymentRef?: true
    reason?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RefundRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefundRequest to aggregate.
     */
    where?: RefundRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefundRequests to fetch.
     */
    orderBy?: RefundRequestOrderByWithRelationInput | RefundRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefundRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefundRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefundRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefundRequests
    **/
    _count?: true | RefundRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefundRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefundRequestMaxAggregateInputType
  }

  export type GetRefundRequestAggregateType<T extends RefundRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateRefundRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefundRequest[P]>
      : GetScalarType<T[P], AggregateRefundRequest[P]>
  }




  export type RefundRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefundRequestWhereInput
    orderBy?: RefundRequestOrderByWithAggregationInput | RefundRequestOrderByWithAggregationInput[]
    by: RefundRequestScalarFieldEnum[] | RefundRequestScalarFieldEnum
    having?: RefundRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefundRequestCountAggregateInputType | true
    _min?: RefundRequestMinAggregateInputType
    _max?: RefundRequestMaxAggregateInputType
  }

  export type RefundRequestGroupByOutputType = {
    id: string
    userId: string
    paymentRef: string
    reason: string
    status: $Enums.RefundStatus
    createdAt: Date
    updatedAt: Date
    _count: RefundRequestCountAggregateOutputType | null
    _min: RefundRequestMinAggregateOutputType | null
    _max: RefundRequestMaxAggregateOutputType | null
  }

  type GetRefundRequestGroupByPayload<T extends RefundRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefundRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefundRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefundRequestGroupByOutputType[P]>
            : GetScalarType<T[P], RefundRequestGroupByOutputType[P]>
        }
      >
    >


  export type RefundRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    paymentRef?: boolean
    reason?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refundRequest"]>

  export type RefundRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    paymentRef?: boolean
    reason?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refundRequest"]>

  export type RefundRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    paymentRef?: boolean
    reason?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refundRequest"]>

  export type RefundRequestSelectScalar = {
    id?: boolean
    userId?: boolean
    paymentRef?: boolean
    reason?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RefundRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "paymentRef" | "reason" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["refundRequest"]>
  export type RefundRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefundRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefundRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefundRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefundRequest"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      paymentRef: string
      reason: string
      status: $Enums.RefundStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["refundRequest"]>
    composites: {}
  }

  type RefundRequestGetPayload<S extends boolean | null | undefined | RefundRequestDefaultArgs> = $Result.GetResult<Prisma.$RefundRequestPayload, S>

  type RefundRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefundRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefundRequestCountAggregateInputType | true
    }

  export interface RefundRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefundRequest'], meta: { name: 'RefundRequest' } }
    /**
     * Find zero or one RefundRequest that matches the filter.
     * @param {RefundRequestFindUniqueArgs} args - Arguments to find a RefundRequest
     * @example
     * // Get one RefundRequest
     * const refundRequest = await prisma.refundRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefundRequestFindUniqueArgs>(args: SelectSubset<T, RefundRequestFindUniqueArgs<ExtArgs>>): Prisma__RefundRequestClient<$Result.GetResult<Prisma.$RefundRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefundRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefundRequestFindUniqueOrThrowArgs} args - Arguments to find a RefundRequest
     * @example
     * // Get one RefundRequest
     * const refundRequest = await prisma.refundRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefundRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, RefundRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefundRequestClient<$Result.GetResult<Prisma.$RefundRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefundRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundRequestFindFirstArgs} args - Arguments to find a RefundRequest
     * @example
     * // Get one RefundRequest
     * const refundRequest = await prisma.refundRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefundRequestFindFirstArgs>(args?: SelectSubset<T, RefundRequestFindFirstArgs<ExtArgs>>): Prisma__RefundRequestClient<$Result.GetResult<Prisma.$RefundRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefundRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundRequestFindFirstOrThrowArgs} args - Arguments to find a RefundRequest
     * @example
     * // Get one RefundRequest
     * const refundRequest = await prisma.refundRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefundRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, RefundRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefundRequestClient<$Result.GetResult<Prisma.$RefundRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefundRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefundRequests
     * const refundRequests = await prisma.refundRequest.findMany()
     * 
     * // Get first 10 RefundRequests
     * const refundRequests = await prisma.refundRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refundRequestWithIdOnly = await prisma.refundRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefundRequestFindManyArgs>(args?: SelectSubset<T, RefundRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefundRequest.
     * @param {RefundRequestCreateArgs} args - Arguments to create a RefundRequest.
     * @example
     * // Create one RefundRequest
     * const RefundRequest = await prisma.refundRequest.create({
     *   data: {
     *     // ... data to create a RefundRequest
     *   }
     * })
     * 
     */
    create<T extends RefundRequestCreateArgs>(args: SelectSubset<T, RefundRequestCreateArgs<ExtArgs>>): Prisma__RefundRequestClient<$Result.GetResult<Prisma.$RefundRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefundRequests.
     * @param {RefundRequestCreateManyArgs} args - Arguments to create many RefundRequests.
     * @example
     * // Create many RefundRequests
     * const refundRequest = await prisma.refundRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefundRequestCreateManyArgs>(args?: SelectSubset<T, RefundRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefundRequests and returns the data saved in the database.
     * @param {RefundRequestCreateManyAndReturnArgs} args - Arguments to create many RefundRequests.
     * @example
     * // Create many RefundRequests
     * const refundRequest = await prisma.refundRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefundRequests and only return the `id`
     * const refundRequestWithIdOnly = await prisma.refundRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefundRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, RefundRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RefundRequest.
     * @param {RefundRequestDeleteArgs} args - Arguments to delete one RefundRequest.
     * @example
     * // Delete one RefundRequest
     * const RefundRequest = await prisma.refundRequest.delete({
     *   where: {
     *     // ... filter to delete one RefundRequest
     *   }
     * })
     * 
     */
    delete<T extends RefundRequestDeleteArgs>(args: SelectSubset<T, RefundRequestDeleteArgs<ExtArgs>>): Prisma__RefundRequestClient<$Result.GetResult<Prisma.$RefundRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefundRequest.
     * @param {RefundRequestUpdateArgs} args - Arguments to update one RefundRequest.
     * @example
     * // Update one RefundRequest
     * const refundRequest = await prisma.refundRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefundRequestUpdateArgs>(args: SelectSubset<T, RefundRequestUpdateArgs<ExtArgs>>): Prisma__RefundRequestClient<$Result.GetResult<Prisma.$RefundRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefundRequests.
     * @param {RefundRequestDeleteManyArgs} args - Arguments to filter RefundRequests to delete.
     * @example
     * // Delete a few RefundRequests
     * const { count } = await prisma.refundRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefundRequestDeleteManyArgs>(args?: SelectSubset<T, RefundRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefundRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefundRequests
     * const refundRequest = await prisma.refundRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefundRequestUpdateManyArgs>(args: SelectSubset<T, RefundRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefundRequests and returns the data updated in the database.
     * @param {RefundRequestUpdateManyAndReturnArgs} args - Arguments to update many RefundRequests.
     * @example
     * // Update many RefundRequests
     * const refundRequest = await prisma.refundRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RefundRequests and only return the `id`
     * const refundRequestWithIdOnly = await prisma.refundRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefundRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, RefundRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RefundRequest.
     * @param {RefundRequestUpsertArgs} args - Arguments to update or create a RefundRequest.
     * @example
     * // Update or create a RefundRequest
     * const refundRequest = await prisma.refundRequest.upsert({
     *   create: {
     *     // ... data to create a RefundRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefundRequest we want to update
     *   }
     * })
     */
    upsert<T extends RefundRequestUpsertArgs>(args: SelectSubset<T, RefundRequestUpsertArgs<ExtArgs>>): Prisma__RefundRequestClient<$Result.GetResult<Prisma.$RefundRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefundRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundRequestCountArgs} args - Arguments to filter RefundRequests to count.
     * @example
     * // Count the number of RefundRequests
     * const count = await prisma.refundRequest.count({
     *   where: {
     *     // ... the filter for the RefundRequests we want to count
     *   }
     * })
    **/
    count<T extends RefundRequestCountArgs>(
      args?: Subset<T, RefundRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefundRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefundRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefundRequestAggregateArgs>(args: Subset<T, RefundRequestAggregateArgs>): Prisma.PrismaPromise<GetRefundRequestAggregateType<T>>

    /**
     * Group by RefundRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefundRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefundRequestGroupByArgs['orderBy'] }
        : { orderBy?: RefundRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefundRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefundRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefundRequest model
   */
  readonly fields: RefundRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefundRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefundRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefundRequest model
   */
  interface RefundRequestFieldRefs {
    readonly id: FieldRef<"RefundRequest", 'String'>
    readonly userId: FieldRef<"RefundRequest", 'String'>
    readonly paymentRef: FieldRef<"RefundRequest", 'String'>
    readonly reason: FieldRef<"RefundRequest", 'String'>
    readonly status: FieldRef<"RefundRequest", 'RefundStatus'>
    readonly createdAt: FieldRef<"RefundRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"RefundRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefundRequest findUnique
   */
  export type RefundRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequest
     */
    select?: RefundRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequest
     */
    omit?: RefundRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestInclude<ExtArgs> | null
    /**
     * Filter, which RefundRequest to fetch.
     */
    where: RefundRequestWhereUniqueInput
  }

  /**
   * RefundRequest findUniqueOrThrow
   */
  export type RefundRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequest
     */
    select?: RefundRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequest
     */
    omit?: RefundRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestInclude<ExtArgs> | null
    /**
     * Filter, which RefundRequest to fetch.
     */
    where: RefundRequestWhereUniqueInput
  }

  /**
   * RefundRequest findFirst
   */
  export type RefundRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequest
     */
    select?: RefundRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequest
     */
    omit?: RefundRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestInclude<ExtArgs> | null
    /**
     * Filter, which RefundRequest to fetch.
     */
    where?: RefundRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefundRequests to fetch.
     */
    orderBy?: RefundRequestOrderByWithRelationInput | RefundRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefundRequests.
     */
    cursor?: RefundRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefundRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefundRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefundRequests.
     */
    distinct?: RefundRequestScalarFieldEnum | RefundRequestScalarFieldEnum[]
  }

  /**
   * RefundRequest findFirstOrThrow
   */
  export type RefundRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequest
     */
    select?: RefundRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequest
     */
    omit?: RefundRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestInclude<ExtArgs> | null
    /**
     * Filter, which RefundRequest to fetch.
     */
    where?: RefundRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefundRequests to fetch.
     */
    orderBy?: RefundRequestOrderByWithRelationInput | RefundRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefundRequests.
     */
    cursor?: RefundRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefundRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefundRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefundRequests.
     */
    distinct?: RefundRequestScalarFieldEnum | RefundRequestScalarFieldEnum[]
  }

  /**
   * RefundRequest findMany
   */
  export type RefundRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequest
     */
    select?: RefundRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequest
     */
    omit?: RefundRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestInclude<ExtArgs> | null
    /**
     * Filter, which RefundRequests to fetch.
     */
    where?: RefundRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefundRequests to fetch.
     */
    orderBy?: RefundRequestOrderByWithRelationInput | RefundRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefundRequests.
     */
    cursor?: RefundRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefundRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefundRequests.
     */
    skip?: number
    distinct?: RefundRequestScalarFieldEnum | RefundRequestScalarFieldEnum[]
  }

  /**
   * RefundRequest create
   */
  export type RefundRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequest
     */
    select?: RefundRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequest
     */
    omit?: RefundRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a RefundRequest.
     */
    data: XOR<RefundRequestCreateInput, RefundRequestUncheckedCreateInput>
  }

  /**
   * RefundRequest createMany
   */
  export type RefundRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefundRequests.
     */
    data: RefundRequestCreateManyInput | RefundRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefundRequest createManyAndReturn
   */
  export type RefundRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequest
     */
    select?: RefundRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequest
     */
    omit?: RefundRequestOmit<ExtArgs> | null
    /**
     * The data used to create many RefundRequests.
     */
    data: RefundRequestCreateManyInput | RefundRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefundRequest update
   */
  export type RefundRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequest
     */
    select?: RefundRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequest
     */
    omit?: RefundRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a RefundRequest.
     */
    data: XOR<RefundRequestUpdateInput, RefundRequestUncheckedUpdateInput>
    /**
     * Choose, which RefundRequest to update.
     */
    where: RefundRequestWhereUniqueInput
  }

  /**
   * RefundRequest updateMany
   */
  export type RefundRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefundRequests.
     */
    data: XOR<RefundRequestUpdateManyMutationInput, RefundRequestUncheckedUpdateManyInput>
    /**
     * Filter which RefundRequests to update
     */
    where?: RefundRequestWhereInput
    /**
     * Limit how many RefundRequests to update.
     */
    limit?: number
  }

  /**
   * RefundRequest updateManyAndReturn
   */
  export type RefundRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequest
     */
    select?: RefundRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequest
     */
    omit?: RefundRequestOmit<ExtArgs> | null
    /**
     * The data used to update RefundRequests.
     */
    data: XOR<RefundRequestUpdateManyMutationInput, RefundRequestUncheckedUpdateManyInput>
    /**
     * Filter which RefundRequests to update
     */
    where?: RefundRequestWhereInput
    /**
     * Limit how many RefundRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefundRequest upsert
   */
  export type RefundRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequest
     */
    select?: RefundRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequest
     */
    omit?: RefundRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the RefundRequest to update in case it exists.
     */
    where: RefundRequestWhereUniqueInput
    /**
     * In case the RefundRequest found by the `where` argument doesn't exist, create a new RefundRequest with this data.
     */
    create: XOR<RefundRequestCreateInput, RefundRequestUncheckedCreateInput>
    /**
     * In case the RefundRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefundRequestUpdateInput, RefundRequestUncheckedUpdateInput>
  }

  /**
   * RefundRequest delete
   */
  export type RefundRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequest
     */
    select?: RefundRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequest
     */
    omit?: RefundRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestInclude<ExtArgs> | null
    /**
     * Filter which RefundRequest to delete.
     */
    where: RefundRequestWhereUniqueInput
  }

  /**
   * RefundRequest deleteMany
   */
  export type RefundRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefundRequests to delete
     */
    where?: RefundRequestWhereInput
    /**
     * Limit how many RefundRequests to delete.
     */
    limit?: number
  }

  /**
   * RefundRequest without action
   */
  export type RefundRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequest
     */
    select?: RefundRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequest
     */
    omit?: RefundRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestInclude<ExtArgs> | null
  }


  /**
   * Model Cart
   */

  export type AggregateCart = {
    _count: CartCountAggregateOutputType | null
    _avg: CartAvgAggregateOutputType | null
    _sum: CartSumAggregateOutputType | null
    _min: CartMinAggregateOutputType | null
    _max: CartMaxAggregateOutputType | null
  }

  export type CartAvgAggregateOutputType = {
    basePrice: number | null
    totalPrice: number | null
  }

  export type CartSumAggregateOutputType = {
    basePrice: number | null
    totalPrice: number | null
  }

  export type CartMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    basePrice: number | null
    totalPrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    basePrice: number | null
    totalPrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartCountAggregateOutputType = {
    id: number
    customerId: number
    basePrice: number
    totalPrice: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CartAvgAggregateInputType = {
    basePrice?: true
    totalPrice?: true
  }

  export type CartSumAggregateInputType = {
    basePrice?: true
    totalPrice?: true
  }

  export type CartMinAggregateInputType = {
    id?: true
    customerId?: true
    basePrice?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartMaxAggregateInputType = {
    id?: true
    customerId?: true
    basePrice?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartCountAggregateInputType = {
    id?: true
    customerId?: true
    basePrice?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cart to aggregate.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Carts
    **/
    _count?: true | CartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartMaxAggregateInputType
  }

  export type GetCartAggregateType<T extends CartAggregateArgs> = {
        [P in keyof T & keyof AggregateCart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCart[P]>
      : GetScalarType<T[P], AggregateCart[P]>
  }




  export type CartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartWhereInput
    orderBy?: CartOrderByWithAggregationInput | CartOrderByWithAggregationInput[]
    by: CartScalarFieldEnum[] | CartScalarFieldEnum
    having?: CartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartCountAggregateInputType | true
    _avg?: CartAvgAggregateInputType
    _sum?: CartSumAggregateInputType
    _min?: CartMinAggregateInputType
    _max?: CartMaxAggregateInputType
  }

  export type CartGroupByOutputType = {
    id: string
    customerId: string
    basePrice: number
    totalPrice: number
    createdAt: Date
    updatedAt: Date
    _count: CartCountAggregateOutputType | null
    _avg: CartAvgAggregateOutputType | null
    _sum: CartSumAggregateOutputType | null
    _min: CartMinAggregateOutputType | null
    _max: CartMaxAggregateOutputType | null
  }

  type GetCartGroupByPayload<T extends CartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartGroupByOutputType[P]>
            : GetScalarType<T[P], CartGroupByOutputType[P]>
        }
      >
    >


  export type CartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    basePrice?: boolean
    totalPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Cart$itemsArgs<ExtArgs>
    _count?: boolean | CartCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type CartSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    basePrice?: boolean
    totalPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type CartSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    basePrice?: boolean
    totalPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type CartSelectScalar = {
    id?: boolean
    customerId?: boolean
    basePrice?: boolean
    totalPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CartOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "basePrice" | "totalPrice" | "createdAt" | "updatedAt", ExtArgs["result"]["cart"]>
  export type CartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Cart$itemsArgs<ExtArgs>
    _count?: boolean | CartCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CartIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CartIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cart"
    objects: {
      customer: Prisma.$UserPayload<ExtArgs>
      items: Prisma.$CartItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      basePrice: number
      totalPrice: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cart"]>
    composites: {}
  }

  type CartGetPayload<S extends boolean | null | undefined | CartDefaultArgs> = $Result.GetResult<Prisma.$CartPayload, S>

  type CartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CartFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CartCountAggregateInputType | true
    }

  export interface CartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cart'], meta: { name: 'Cart' } }
    /**
     * Find zero or one Cart that matches the filter.
     * @param {CartFindUniqueArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CartFindUniqueArgs>(args: SelectSubset<T, CartFindUniqueArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cart that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CartFindUniqueOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CartFindUniqueOrThrowArgs>(args: SelectSubset<T, CartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindFirstArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CartFindFirstArgs>(args?: SelectSubset<T, CartFindFirstArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindFirstOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CartFindFirstOrThrowArgs>(args?: SelectSubset<T, CartFindFirstOrThrowArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Carts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carts
     * const carts = await prisma.cart.findMany()
     * 
     * // Get first 10 Carts
     * const carts = await prisma.cart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cartWithIdOnly = await prisma.cart.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CartFindManyArgs>(args?: SelectSubset<T, CartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cart.
     * @param {CartCreateArgs} args - Arguments to create a Cart.
     * @example
     * // Create one Cart
     * const Cart = await prisma.cart.create({
     *   data: {
     *     // ... data to create a Cart
     *   }
     * })
     * 
     */
    create<T extends CartCreateArgs>(args: SelectSubset<T, CartCreateArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Carts.
     * @param {CartCreateManyArgs} args - Arguments to create many Carts.
     * @example
     * // Create many Carts
     * const cart = await prisma.cart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CartCreateManyArgs>(args?: SelectSubset<T, CartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Carts and returns the data saved in the database.
     * @param {CartCreateManyAndReturnArgs} args - Arguments to create many Carts.
     * @example
     * // Create many Carts
     * const cart = await prisma.cart.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Carts and only return the `id`
     * const cartWithIdOnly = await prisma.cart.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CartCreateManyAndReturnArgs>(args?: SelectSubset<T, CartCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cart.
     * @param {CartDeleteArgs} args - Arguments to delete one Cart.
     * @example
     * // Delete one Cart
     * const Cart = await prisma.cart.delete({
     *   where: {
     *     // ... filter to delete one Cart
     *   }
     * })
     * 
     */
    delete<T extends CartDeleteArgs>(args: SelectSubset<T, CartDeleteArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cart.
     * @param {CartUpdateArgs} args - Arguments to update one Cart.
     * @example
     * // Update one Cart
     * const cart = await prisma.cart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CartUpdateArgs>(args: SelectSubset<T, CartUpdateArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Carts.
     * @param {CartDeleteManyArgs} args - Arguments to filter Carts to delete.
     * @example
     * // Delete a few Carts
     * const { count } = await prisma.cart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CartDeleteManyArgs>(args?: SelectSubset<T, CartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carts
     * const cart = await prisma.cart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CartUpdateManyArgs>(args: SelectSubset<T, CartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carts and returns the data updated in the database.
     * @param {CartUpdateManyAndReturnArgs} args - Arguments to update many Carts.
     * @example
     * // Update many Carts
     * const cart = await prisma.cart.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Carts and only return the `id`
     * const cartWithIdOnly = await prisma.cart.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CartUpdateManyAndReturnArgs>(args: SelectSubset<T, CartUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cart.
     * @param {CartUpsertArgs} args - Arguments to update or create a Cart.
     * @example
     * // Update or create a Cart
     * const cart = await prisma.cart.upsert({
     *   create: {
     *     // ... data to create a Cart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cart we want to update
     *   }
     * })
     */
    upsert<T extends CartUpsertArgs>(args: SelectSubset<T, CartUpsertArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartCountArgs} args - Arguments to filter Carts to count.
     * @example
     * // Count the number of Carts
     * const count = await prisma.cart.count({
     *   where: {
     *     // ... the filter for the Carts we want to count
     *   }
     * })
    **/
    count<T extends CartCountArgs>(
      args?: Subset<T, CartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartAggregateArgs>(args: Subset<T, CartAggregateArgs>): Prisma.PrismaPromise<GetCartAggregateType<T>>

    /**
     * Group by Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartGroupByArgs['orderBy'] }
        : { orderBy?: CartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cart model
   */
  readonly fields: CartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends Cart$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Cart$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cart model
   */
  interface CartFieldRefs {
    readonly id: FieldRef<"Cart", 'String'>
    readonly customerId: FieldRef<"Cart", 'String'>
    readonly basePrice: FieldRef<"Cart", 'Float'>
    readonly totalPrice: FieldRef<"Cart", 'Float'>
    readonly createdAt: FieldRef<"Cart", 'DateTime'>
    readonly updatedAt: FieldRef<"Cart", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Cart findUnique
   */
  export type CartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart findUniqueOrThrow
   */
  export type CartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart findFirst
   */
  export type CartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart findFirstOrThrow
   */
  export type CartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart findMany
   */
  export type CartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Carts to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart create
   */
  export type CartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The data needed to create a Cart.
     */
    data: XOR<CartCreateInput, CartUncheckedCreateInput>
  }

  /**
   * Cart createMany
   */
  export type CartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Carts.
     */
    data: CartCreateManyInput | CartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cart createManyAndReturn
   */
  export type CartCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * The data used to create many Carts.
     */
    data: CartCreateManyInput | CartCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cart update
   */
  export type CartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The data needed to update a Cart.
     */
    data: XOR<CartUpdateInput, CartUncheckedUpdateInput>
    /**
     * Choose, which Cart to update.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart updateMany
   */
  export type CartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Carts.
     */
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyInput>
    /**
     * Filter which Carts to update
     */
    where?: CartWhereInput
    /**
     * Limit how many Carts to update.
     */
    limit?: number
  }

  /**
   * Cart updateManyAndReturn
   */
  export type CartUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * The data used to update Carts.
     */
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyInput>
    /**
     * Filter which Carts to update
     */
    where?: CartWhereInput
    /**
     * Limit how many Carts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cart upsert
   */
  export type CartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The filter to search for the Cart to update in case it exists.
     */
    where: CartWhereUniqueInput
    /**
     * In case the Cart found by the `where` argument doesn't exist, create a new Cart with this data.
     */
    create: XOR<CartCreateInput, CartUncheckedCreateInput>
    /**
     * In case the Cart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartUpdateInput, CartUncheckedUpdateInput>
  }

  /**
   * Cart delete
   */
  export type CartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter which Cart to delete.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart deleteMany
   */
  export type CartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Carts to delete
     */
    where?: CartWhereInput
    /**
     * Limit how many Carts to delete.
     */
    limit?: number
  }

  /**
   * Cart.items
   */
  export type Cart$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    cursor?: CartItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * Cart without action
   */
  export type CartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
  }


  /**
   * Model CartItem
   */

  export type AggregateCartItem = {
    _count: CartItemCountAggregateOutputType | null
    _avg: CartItemAvgAggregateOutputType | null
    _sum: CartItemSumAggregateOutputType | null
    _min: CartItemMinAggregateOutputType | null
    _max: CartItemMaxAggregateOutputType | null
  }

  export type CartItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    subtotal: number | null
  }

  export type CartItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    subtotal: number | null
  }

  export type CartItemMinAggregateOutputType = {
    id: string | null
    cartId: string | null
    productId: string | null
    quantity: number | null
    unitPrice: number | null
    subtotal: number | null
    specialRequest: string | null
  }

  export type CartItemMaxAggregateOutputType = {
    id: string | null
    cartId: string | null
    productId: string | null
    quantity: number | null
    unitPrice: number | null
    subtotal: number | null
    specialRequest: string | null
  }

  export type CartItemCountAggregateOutputType = {
    id: number
    cartId: number
    productId: number
    quantity: number
    unitPrice: number
    subtotal: number
    specialRequest: number
    _all: number
  }


  export type CartItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    subtotal?: true
  }

  export type CartItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    subtotal?: true
  }

  export type CartItemMinAggregateInputType = {
    id?: true
    cartId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    subtotal?: true
    specialRequest?: true
  }

  export type CartItemMaxAggregateInputType = {
    id?: true
    cartId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    subtotal?: true
    specialRequest?: true
  }

  export type CartItemCountAggregateInputType = {
    id?: true
    cartId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    subtotal?: true
    specialRequest?: true
    _all?: true
  }

  export type CartItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CartItem to aggregate.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CartItems
    **/
    _count?: true | CartItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CartItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CartItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartItemMaxAggregateInputType
  }

  export type GetCartItemAggregateType<T extends CartItemAggregateArgs> = {
        [P in keyof T & keyof AggregateCartItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCartItem[P]>
      : GetScalarType<T[P], AggregateCartItem[P]>
  }




  export type CartItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithAggregationInput | CartItemOrderByWithAggregationInput[]
    by: CartItemScalarFieldEnum[] | CartItemScalarFieldEnum
    having?: CartItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartItemCountAggregateInputType | true
    _avg?: CartItemAvgAggregateInputType
    _sum?: CartItemSumAggregateInputType
    _min?: CartItemMinAggregateInputType
    _max?: CartItemMaxAggregateInputType
  }

  export type CartItemGroupByOutputType = {
    id: string
    cartId: string
    productId: string
    quantity: number
    unitPrice: number
    subtotal: number
    specialRequest: string | null
    _count: CartItemCountAggregateOutputType | null
    _avg: CartItemAvgAggregateOutputType | null
    _sum: CartItemSumAggregateOutputType | null
    _min: CartItemMinAggregateOutputType | null
    _max: CartItemMaxAggregateOutputType | null
  }

  type GetCartItemGroupByPayload<T extends CartItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartItemGroupByOutputType[P]>
            : GetScalarType<T[P], CartItemGroupByOutputType[P]>
        }
      >
    >


  export type CartItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cartId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    subtotal?: boolean
    specialRequest?: boolean
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    options?: boolean | CartItem$optionsArgs<ExtArgs>
    _count?: boolean | CartItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartItem"]>

  export type CartItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cartId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    subtotal?: boolean
    specialRequest?: boolean
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartItem"]>

  export type CartItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cartId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    subtotal?: boolean
    specialRequest?: boolean
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartItem"]>

  export type CartItemSelectScalar = {
    id?: boolean
    cartId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    subtotal?: boolean
    specialRequest?: boolean
  }

  export type CartItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cartId" | "productId" | "quantity" | "unitPrice" | "subtotal" | "specialRequest", ExtArgs["result"]["cartItem"]>
  export type CartItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    options?: boolean | CartItem$optionsArgs<ExtArgs>
    _count?: boolean | CartItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CartItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type CartItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $CartItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CartItem"
    objects: {
      cart: Prisma.$CartPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      options: Prisma.$CartItemOptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cartId: string
      productId: string
      quantity: number
      unitPrice: number
      subtotal: number
      specialRequest: string | null
    }, ExtArgs["result"]["cartItem"]>
    composites: {}
  }

  type CartItemGetPayload<S extends boolean | null | undefined | CartItemDefaultArgs> = $Result.GetResult<Prisma.$CartItemPayload, S>

  type CartItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CartItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CartItemCountAggregateInputType | true
    }

  export interface CartItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CartItem'], meta: { name: 'CartItem' } }
    /**
     * Find zero or one CartItem that matches the filter.
     * @param {CartItemFindUniqueArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CartItemFindUniqueArgs>(args: SelectSubset<T, CartItemFindUniqueArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CartItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CartItemFindUniqueOrThrowArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CartItemFindUniqueOrThrowArgs>(args: SelectSubset<T, CartItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CartItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindFirstArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CartItemFindFirstArgs>(args?: SelectSubset<T, CartItemFindFirstArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CartItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindFirstOrThrowArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CartItemFindFirstOrThrowArgs>(args?: SelectSubset<T, CartItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CartItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CartItems
     * const cartItems = await prisma.cartItem.findMany()
     * 
     * // Get first 10 CartItems
     * const cartItems = await prisma.cartItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cartItemWithIdOnly = await prisma.cartItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CartItemFindManyArgs>(args?: SelectSubset<T, CartItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CartItem.
     * @param {CartItemCreateArgs} args - Arguments to create a CartItem.
     * @example
     * // Create one CartItem
     * const CartItem = await prisma.cartItem.create({
     *   data: {
     *     // ... data to create a CartItem
     *   }
     * })
     * 
     */
    create<T extends CartItemCreateArgs>(args: SelectSubset<T, CartItemCreateArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CartItems.
     * @param {CartItemCreateManyArgs} args - Arguments to create many CartItems.
     * @example
     * // Create many CartItems
     * const cartItem = await prisma.cartItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CartItemCreateManyArgs>(args?: SelectSubset<T, CartItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CartItems and returns the data saved in the database.
     * @param {CartItemCreateManyAndReturnArgs} args - Arguments to create many CartItems.
     * @example
     * // Create many CartItems
     * const cartItem = await prisma.cartItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CartItems and only return the `id`
     * const cartItemWithIdOnly = await prisma.cartItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CartItemCreateManyAndReturnArgs>(args?: SelectSubset<T, CartItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CartItem.
     * @param {CartItemDeleteArgs} args - Arguments to delete one CartItem.
     * @example
     * // Delete one CartItem
     * const CartItem = await prisma.cartItem.delete({
     *   where: {
     *     // ... filter to delete one CartItem
     *   }
     * })
     * 
     */
    delete<T extends CartItemDeleteArgs>(args: SelectSubset<T, CartItemDeleteArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CartItem.
     * @param {CartItemUpdateArgs} args - Arguments to update one CartItem.
     * @example
     * // Update one CartItem
     * const cartItem = await prisma.cartItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CartItemUpdateArgs>(args: SelectSubset<T, CartItemUpdateArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CartItems.
     * @param {CartItemDeleteManyArgs} args - Arguments to filter CartItems to delete.
     * @example
     * // Delete a few CartItems
     * const { count } = await prisma.cartItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CartItemDeleteManyArgs>(args?: SelectSubset<T, CartItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CartItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CartItems
     * const cartItem = await prisma.cartItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CartItemUpdateManyArgs>(args: SelectSubset<T, CartItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CartItems and returns the data updated in the database.
     * @param {CartItemUpdateManyAndReturnArgs} args - Arguments to update many CartItems.
     * @example
     * // Update many CartItems
     * const cartItem = await prisma.cartItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CartItems and only return the `id`
     * const cartItemWithIdOnly = await prisma.cartItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CartItemUpdateManyAndReturnArgs>(args: SelectSubset<T, CartItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CartItem.
     * @param {CartItemUpsertArgs} args - Arguments to update or create a CartItem.
     * @example
     * // Update or create a CartItem
     * const cartItem = await prisma.cartItem.upsert({
     *   create: {
     *     // ... data to create a CartItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CartItem we want to update
     *   }
     * })
     */
    upsert<T extends CartItemUpsertArgs>(args: SelectSubset<T, CartItemUpsertArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CartItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemCountArgs} args - Arguments to filter CartItems to count.
     * @example
     * // Count the number of CartItems
     * const count = await prisma.cartItem.count({
     *   where: {
     *     // ... the filter for the CartItems we want to count
     *   }
     * })
    **/
    count<T extends CartItemCountArgs>(
      args?: Subset<T, CartItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CartItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartItemAggregateArgs>(args: Subset<T, CartItemAggregateArgs>): Prisma.PrismaPromise<GetCartItemAggregateType<T>>

    /**
     * Group by CartItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CartItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartItemGroupByArgs['orderBy'] }
        : { orderBy?: CartItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CartItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CartItem model
   */
  readonly fields: CartItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CartItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CartItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cart<T extends CartDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CartDefaultArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    options<T extends CartItem$optionsArgs<ExtArgs> = {}>(args?: Subset<T, CartItem$optionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CartItem model
   */
  interface CartItemFieldRefs {
    readonly id: FieldRef<"CartItem", 'String'>
    readonly cartId: FieldRef<"CartItem", 'String'>
    readonly productId: FieldRef<"CartItem", 'String'>
    readonly quantity: FieldRef<"CartItem", 'Int'>
    readonly unitPrice: FieldRef<"CartItem", 'Float'>
    readonly subtotal: FieldRef<"CartItem", 'Float'>
    readonly specialRequest: FieldRef<"CartItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CartItem findUnique
   */
  export type CartItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem findUniqueOrThrow
   */
  export type CartItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem findFirst
   */
  export type CartItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CartItems.
     */
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem findFirstOrThrow
   */
  export type CartItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CartItems.
     */
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem findMany
   */
  export type CartItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItems to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem create
   */
  export type CartItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The data needed to create a CartItem.
     */
    data: XOR<CartItemCreateInput, CartItemUncheckedCreateInput>
  }

  /**
   * CartItem createMany
   */
  export type CartItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CartItems.
     */
    data: CartItemCreateManyInput | CartItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CartItem createManyAndReturn
   */
  export type CartItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * The data used to create many CartItems.
     */
    data: CartItemCreateManyInput | CartItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CartItem update
   */
  export type CartItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The data needed to update a CartItem.
     */
    data: XOR<CartItemUpdateInput, CartItemUncheckedUpdateInput>
    /**
     * Choose, which CartItem to update.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem updateMany
   */
  export type CartItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CartItems.
     */
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyInput>
    /**
     * Filter which CartItems to update
     */
    where?: CartItemWhereInput
    /**
     * Limit how many CartItems to update.
     */
    limit?: number
  }

  /**
   * CartItem updateManyAndReturn
   */
  export type CartItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * The data used to update CartItems.
     */
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyInput>
    /**
     * Filter which CartItems to update
     */
    where?: CartItemWhereInput
    /**
     * Limit how many CartItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CartItem upsert
   */
  export type CartItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The filter to search for the CartItem to update in case it exists.
     */
    where: CartItemWhereUniqueInput
    /**
     * In case the CartItem found by the `where` argument doesn't exist, create a new CartItem with this data.
     */
    create: XOR<CartItemCreateInput, CartItemUncheckedCreateInput>
    /**
     * In case the CartItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartItemUpdateInput, CartItemUncheckedUpdateInput>
  }

  /**
   * CartItem delete
   */
  export type CartItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter which CartItem to delete.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem deleteMany
   */
  export type CartItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CartItems to delete
     */
    where?: CartItemWhereInput
    /**
     * Limit how many CartItems to delete.
     */
    limit?: number
  }

  /**
   * CartItem.options
   */
  export type CartItem$optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItemOption
     */
    select?: CartItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItemOption
     */
    omit?: CartItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemOptionInclude<ExtArgs> | null
    where?: CartItemOptionWhereInput
    orderBy?: CartItemOptionOrderByWithRelationInput | CartItemOptionOrderByWithRelationInput[]
    cursor?: CartItemOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartItemOptionScalarFieldEnum | CartItemOptionScalarFieldEnum[]
  }

  /**
   * CartItem without action
   */
  export type CartItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
  }


  /**
   * Model CartItemOption
   */

  export type AggregateCartItemOption = {
    _count: CartItemOptionCountAggregateOutputType | null
    _avg: CartItemOptionAvgAggregateOutputType | null
    _sum: CartItemOptionSumAggregateOutputType | null
    _min: CartItemOptionMinAggregateOutputType | null
    _max: CartItemOptionMaxAggregateOutputType | null
  }

  export type CartItemOptionAvgAggregateOutputType = {
    price: number | null
  }

  export type CartItemOptionSumAggregateOutputType = {
    price: number | null
  }

  export type CartItemOptionMinAggregateOutputType = {
    id: string | null
    cartItemId: string | null
    productOptionId: string | null
    name: string | null
    price: number | null
  }

  export type CartItemOptionMaxAggregateOutputType = {
    id: string | null
    cartItemId: string | null
    productOptionId: string | null
    name: string | null
    price: number | null
  }

  export type CartItemOptionCountAggregateOutputType = {
    id: number
    cartItemId: number
    productOptionId: number
    name: number
    price: number
    _all: number
  }


  export type CartItemOptionAvgAggregateInputType = {
    price?: true
  }

  export type CartItemOptionSumAggregateInputType = {
    price?: true
  }

  export type CartItemOptionMinAggregateInputType = {
    id?: true
    cartItemId?: true
    productOptionId?: true
    name?: true
    price?: true
  }

  export type CartItemOptionMaxAggregateInputType = {
    id?: true
    cartItemId?: true
    productOptionId?: true
    name?: true
    price?: true
  }

  export type CartItemOptionCountAggregateInputType = {
    id?: true
    cartItemId?: true
    productOptionId?: true
    name?: true
    price?: true
    _all?: true
  }

  export type CartItemOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CartItemOption to aggregate.
     */
    where?: CartItemOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItemOptions to fetch.
     */
    orderBy?: CartItemOptionOrderByWithRelationInput | CartItemOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CartItemOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItemOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItemOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CartItemOptions
    **/
    _count?: true | CartItemOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CartItemOptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CartItemOptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartItemOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartItemOptionMaxAggregateInputType
  }

  export type GetCartItemOptionAggregateType<T extends CartItemOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateCartItemOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCartItemOption[P]>
      : GetScalarType<T[P], AggregateCartItemOption[P]>
  }




  export type CartItemOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemOptionWhereInput
    orderBy?: CartItemOptionOrderByWithAggregationInput | CartItemOptionOrderByWithAggregationInput[]
    by: CartItemOptionScalarFieldEnum[] | CartItemOptionScalarFieldEnum
    having?: CartItemOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartItemOptionCountAggregateInputType | true
    _avg?: CartItemOptionAvgAggregateInputType
    _sum?: CartItemOptionSumAggregateInputType
    _min?: CartItemOptionMinAggregateInputType
    _max?: CartItemOptionMaxAggregateInputType
  }

  export type CartItemOptionGroupByOutputType = {
    id: string
    cartItemId: string
    productOptionId: string
    name: string
    price: number
    _count: CartItemOptionCountAggregateOutputType | null
    _avg: CartItemOptionAvgAggregateOutputType | null
    _sum: CartItemOptionSumAggregateOutputType | null
    _min: CartItemOptionMinAggregateOutputType | null
    _max: CartItemOptionMaxAggregateOutputType | null
  }

  type GetCartItemOptionGroupByPayload<T extends CartItemOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartItemOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartItemOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartItemOptionGroupByOutputType[P]>
            : GetScalarType<T[P], CartItemOptionGroupByOutputType[P]>
        }
      >
    >


  export type CartItemOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cartItemId?: boolean
    productOptionId?: boolean
    name?: boolean
    price?: boolean
    cartItem?: boolean | CartItemDefaultArgs<ExtArgs>
    productOption?: boolean | ProductOptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartItemOption"]>

  export type CartItemOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cartItemId?: boolean
    productOptionId?: boolean
    name?: boolean
    price?: boolean
    cartItem?: boolean | CartItemDefaultArgs<ExtArgs>
    productOption?: boolean | ProductOptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartItemOption"]>

  export type CartItemOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cartItemId?: boolean
    productOptionId?: boolean
    name?: boolean
    price?: boolean
    cartItem?: boolean | CartItemDefaultArgs<ExtArgs>
    productOption?: boolean | ProductOptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartItemOption"]>

  export type CartItemOptionSelectScalar = {
    id?: boolean
    cartItemId?: boolean
    productOptionId?: boolean
    name?: boolean
    price?: boolean
  }

  export type CartItemOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cartItemId" | "productOptionId" | "name" | "price", ExtArgs["result"]["cartItemOption"]>
  export type CartItemOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cartItem?: boolean | CartItemDefaultArgs<ExtArgs>
    productOption?: boolean | ProductOptionDefaultArgs<ExtArgs>
  }
  export type CartItemOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cartItem?: boolean | CartItemDefaultArgs<ExtArgs>
    productOption?: boolean | ProductOptionDefaultArgs<ExtArgs>
  }
  export type CartItemOptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cartItem?: boolean | CartItemDefaultArgs<ExtArgs>
    productOption?: boolean | ProductOptionDefaultArgs<ExtArgs>
  }

  export type $CartItemOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CartItemOption"
    objects: {
      cartItem: Prisma.$CartItemPayload<ExtArgs>
      productOption: Prisma.$ProductOptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cartItemId: string
      productOptionId: string
      name: string
      price: number
    }, ExtArgs["result"]["cartItemOption"]>
    composites: {}
  }

  type CartItemOptionGetPayload<S extends boolean | null | undefined | CartItemOptionDefaultArgs> = $Result.GetResult<Prisma.$CartItemOptionPayload, S>

  type CartItemOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CartItemOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CartItemOptionCountAggregateInputType | true
    }

  export interface CartItemOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CartItemOption'], meta: { name: 'CartItemOption' } }
    /**
     * Find zero or one CartItemOption that matches the filter.
     * @param {CartItemOptionFindUniqueArgs} args - Arguments to find a CartItemOption
     * @example
     * // Get one CartItemOption
     * const cartItemOption = await prisma.cartItemOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CartItemOptionFindUniqueArgs>(args: SelectSubset<T, CartItemOptionFindUniqueArgs<ExtArgs>>): Prisma__CartItemOptionClient<$Result.GetResult<Prisma.$CartItemOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CartItemOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CartItemOptionFindUniqueOrThrowArgs} args - Arguments to find a CartItemOption
     * @example
     * // Get one CartItemOption
     * const cartItemOption = await prisma.cartItemOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CartItemOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, CartItemOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CartItemOptionClient<$Result.GetResult<Prisma.$CartItemOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CartItemOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemOptionFindFirstArgs} args - Arguments to find a CartItemOption
     * @example
     * // Get one CartItemOption
     * const cartItemOption = await prisma.cartItemOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CartItemOptionFindFirstArgs>(args?: SelectSubset<T, CartItemOptionFindFirstArgs<ExtArgs>>): Prisma__CartItemOptionClient<$Result.GetResult<Prisma.$CartItemOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CartItemOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemOptionFindFirstOrThrowArgs} args - Arguments to find a CartItemOption
     * @example
     * // Get one CartItemOption
     * const cartItemOption = await prisma.cartItemOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CartItemOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, CartItemOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CartItemOptionClient<$Result.GetResult<Prisma.$CartItemOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CartItemOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CartItemOptions
     * const cartItemOptions = await prisma.cartItemOption.findMany()
     * 
     * // Get first 10 CartItemOptions
     * const cartItemOptions = await prisma.cartItemOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cartItemOptionWithIdOnly = await prisma.cartItemOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CartItemOptionFindManyArgs>(args?: SelectSubset<T, CartItemOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CartItemOption.
     * @param {CartItemOptionCreateArgs} args - Arguments to create a CartItemOption.
     * @example
     * // Create one CartItemOption
     * const CartItemOption = await prisma.cartItemOption.create({
     *   data: {
     *     // ... data to create a CartItemOption
     *   }
     * })
     * 
     */
    create<T extends CartItemOptionCreateArgs>(args: SelectSubset<T, CartItemOptionCreateArgs<ExtArgs>>): Prisma__CartItemOptionClient<$Result.GetResult<Prisma.$CartItemOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CartItemOptions.
     * @param {CartItemOptionCreateManyArgs} args - Arguments to create many CartItemOptions.
     * @example
     * // Create many CartItemOptions
     * const cartItemOption = await prisma.cartItemOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CartItemOptionCreateManyArgs>(args?: SelectSubset<T, CartItemOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CartItemOptions and returns the data saved in the database.
     * @param {CartItemOptionCreateManyAndReturnArgs} args - Arguments to create many CartItemOptions.
     * @example
     * // Create many CartItemOptions
     * const cartItemOption = await prisma.cartItemOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CartItemOptions and only return the `id`
     * const cartItemOptionWithIdOnly = await prisma.cartItemOption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CartItemOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, CartItemOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CartItemOption.
     * @param {CartItemOptionDeleteArgs} args - Arguments to delete one CartItemOption.
     * @example
     * // Delete one CartItemOption
     * const CartItemOption = await prisma.cartItemOption.delete({
     *   where: {
     *     // ... filter to delete one CartItemOption
     *   }
     * })
     * 
     */
    delete<T extends CartItemOptionDeleteArgs>(args: SelectSubset<T, CartItemOptionDeleteArgs<ExtArgs>>): Prisma__CartItemOptionClient<$Result.GetResult<Prisma.$CartItemOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CartItemOption.
     * @param {CartItemOptionUpdateArgs} args - Arguments to update one CartItemOption.
     * @example
     * // Update one CartItemOption
     * const cartItemOption = await prisma.cartItemOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CartItemOptionUpdateArgs>(args: SelectSubset<T, CartItemOptionUpdateArgs<ExtArgs>>): Prisma__CartItemOptionClient<$Result.GetResult<Prisma.$CartItemOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CartItemOptions.
     * @param {CartItemOptionDeleteManyArgs} args - Arguments to filter CartItemOptions to delete.
     * @example
     * // Delete a few CartItemOptions
     * const { count } = await prisma.cartItemOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CartItemOptionDeleteManyArgs>(args?: SelectSubset<T, CartItemOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CartItemOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CartItemOptions
     * const cartItemOption = await prisma.cartItemOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CartItemOptionUpdateManyArgs>(args: SelectSubset<T, CartItemOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CartItemOptions and returns the data updated in the database.
     * @param {CartItemOptionUpdateManyAndReturnArgs} args - Arguments to update many CartItemOptions.
     * @example
     * // Update many CartItemOptions
     * const cartItemOption = await prisma.cartItemOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CartItemOptions and only return the `id`
     * const cartItemOptionWithIdOnly = await prisma.cartItemOption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CartItemOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, CartItemOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CartItemOption.
     * @param {CartItemOptionUpsertArgs} args - Arguments to update or create a CartItemOption.
     * @example
     * // Update or create a CartItemOption
     * const cartItemOption = await prisma.cartItemOption.upsert({
     *   create: {
     *     // ... data to create a CartItemOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CartItemOption we want to update
     *   }
     * })
     */
    upsert<T extends CartItemOptionUpsertArgs>(args: SelectSubset<T, CartItemOptionUpsertArgs<ExtArgs>>): Prisma__CartItemOptionClient<$Result.GetResult<Prisma.$CartItemOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CartItemOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemOptionCountArgs} args - Arguments to filter CartItemOptions to count.
     * @example
     * // Count the number of CartItemOptions
     * const count = await prisma.cartItemOption.count({
     *   where: {
     *     // ... the filter for the CartItemOptions we want to count
     *   }
     * })
    **/
    count<T extends CartItemOptionCountArgs>(
      args?: Subset<T, CartItemOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartItemOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CartItemOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartItemOptionAggregateArgs>(args: Subset<T, CartItemOptionAggregateArgs>): Prisma.PrismaPromise<GetCartItemOptionAggregateType<T>>

    /**
     * Group by CartItemOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CartItemOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartItemOptionGroupByArgs['orderBy'] }
        : { orderBy?: CartItemOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CartItemOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartItemOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CartItemOption model
   */
  readonly fields: CartItemOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CartItemOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CartItemOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cartItem<T extends CartItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CartItemDefaultArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    productOption<T extends ProductOptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductOptionDefaultArgs<ExtArgs>>): Prisma__ProductOptionClient<$Result.GetResult<Prisma.$ProductOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CartItemOption model
   */
  interface CartItemOptionFieldRefs {
    readonly id: FieldRef<"CartItemOption", 'String'>
    readonly cartItemId: FieldRef<"CartItemOption", 'String'>
    readonly productOptionId: FieldRef<"CartItemOption", 'String'>
    readonly name: FieldRef<"CartItemOption", 'String'>
    readonly price: FieldRef<"CartItemOption", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * CartItemOption findUnique
   */
  export type CartItemOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItemOption
     */
    select?: CartItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItemOption
     */
    omit?: CartItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemOptionInclude<ExtArgs> | null
    /**
     * Filter, which CartItemOption to fetch.
     */
    where: CartItemOptionWhereUniqueInput
  }

  /**
   * CartItemOption findUniqueOrThrow
   */
  export type CartItemOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItemOption
     */
    select?: CartItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItemOption
     */
    omit?: CartItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemOptionInclude<ExtArgs> | null
    /**
     * Filter, which CartItemOption to fetch.
     */
    where: CartItemOptionWhereUniqueInput
  }

  /**
   * CartItemOption findFirst
   */
  export type CartItemOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItemOption
     */
    select?: CartItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItemOption
     */
    omit?: CartItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemOptionInclude<ExtArgs> | null
    /**
     * Filter, which CartItemOption to fetch.
     */
    where?: CartItemOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItemOptions to fetch.
     */
    orderBy?: CartItemOptionOrderByWithRelationInput | CartItemOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CartItemOptions.
     */
    cursor?: CartItemOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItemOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItemOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CartItemOptions.
     */
    distinct?: CartItemOptionScalarFieldEnum | CartItemOptionScalarFieldEnum[]
  }

  /**
   * CartItemOption findFirstOrThrow
   */
  export type CartItemOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItemOption
     */
    select?: CartItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItemOption
     */
    omit?: CartItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemOptionInclude<ExtArgs> | null
    /**
     * Filter, which CartItemOption to fetch.
     */
    where?: CartItemOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItemOptions to fetch.
     */
    orderBy?: CartItemOptionOrderByWithRelationInput | CartItemOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CartItemOptions.
     */
    cursor?: CartItemOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItemOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItemOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CartItemOptions.
     */
    distinct?: CartItemOptionScalarFieldEnum | CartItemOptionScalarFieldEnum[]
  }

  /**
   * CartItemOption findMany
   */
  export type CartItemOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItemOption
     */
    select?: CartItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItemOption
     */
    omit?: CartItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemOptionInclude<ExtArgs> | null
    /**
     * Filter, which CartItemOptions to fetch.
     */
    where?: CartItemOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItemOptions to fetch.
     */
    orderBy?: CartItemOptionOrderByWithRelationInput | CartItemOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CartItemOptions.
     */
    cursor?: CartItemOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItemOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItemOptions.
     */
    skip?: number
    distinct?: CartItemOptionScalarFieldEnum | CartItemOptionScalarFieldEnum[]
  }

  /**
   * CartItemOption create
   */
  export type CartItemOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItemOption
     */
    select?: CartItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItemOption
     */
    omit?: CartItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a CartItemOption.
     */
    data: XOR<CartItemOptionCreateInput, CartItemOptionUncheckedCreateInput>
  }

  /**
   * CartItemOption createMany
   */
  export type CartItemOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CartItemOptions.
     */
    data: CartItemOptionCreateManyInput | CartItemOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CartItemOption createManyAndReturn
   */
  export type CartItemOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItemOption
     */
    select?: CartItemOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CartItemOption
     */
    omit?: CartItemOptionOmit<ExtArgs> | null
    /**
     * The data used to create many CartItemOptions.
     */
    data: CartItemOptionCreateManyInput | CartItemOptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemOptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CartItemOption update
   */
  export type CartItemOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItemOption
     */
    select?: CartItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItemOption
     */
    omit?: CartItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a CartItemOption.
     */
    data: XOR<CartItemOptionUpdateInput, CartItemOptionUncheckedUpdateInput>
    /**
     * Choose, which CartItemOption to update.
     */
    where: CartItemOptionWhereUniqueInput
  }

  /**
   * CartItemOption updateMany
   */
  export type CartItemOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CartItemOptions.
     */
    data: XOR<CartItemOptionUpdateManyMutationInput, CartItemOptionUncheckedUpdateManyInput>
    /**
     * Filter which CartItemOptions to update
     */
    where?: CartItemOptionWhereInput
    /**
     * Limit how many CartItemOptions to update.
     */
    limit?: number
  }

  /**
   * CartItemOption updateManyAndReturn
   */
  export type CartItemOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItemOption
     */
    select?: CartItemOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CartItemOption
     */
    omit?: CartItemOptionOmit<ExtArgs> | null
    /**
     * The data used to update CartItemOptions.
     */
    data: XOR<CartItemOptionUpdateManyMutationInput, CartItemOptionUncheckedUpdateManyInput>
    /**
     * Filter which CartItemOptions to update
     */
    where?: CartItemOptionWhereInput
    /**
     * Limit how many CartItemOptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemOptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CartItemOption upsert
   */
  export type CartItemOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItemOption
     */
    select?: CartItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItemOption
     */
    omit?: CartItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the CartItemOption to update in case it exists.
     */
    where: CartItemOptionWhereUniqueInput
    /**
     * In case the CartItemOption found by the `where` argument doesn't exist, create a new CartItemOption with this data.
     */
    create: XOR<CartItemOptionCreateInput, CartItemOptionUncheckedCreateInput>
    /**
     * In case the CartItemOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartItemOptionUpdateInput, CartItemOptionUncheckedUpdateInput>
  }

  /**
   * CartItemOption delete
   */
  export type CartItemOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItemOption
     */
    select?: CartItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItemOption
     */
    omit?: CartItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemOptionInclude<ExtArgs> | null
    /**
     * Filter which CartItemOption to delete.
     */
    where: CartItemOptionWhereUniqueInput
  }

  /**
   * CartItemOption deleteMany
   */
  export type CartItemOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CartItemOptions to delete
     */
    where?: CartItemOptionWhereInput
    /**
     * Limit how many CartItemOptions to delete.
     */
    limit?: number
  }

  /**
   * CartItemOption without action
   */
  export type CartItemOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItemOption
     */
    select?: CartItemOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItemOption
     */
    omit?: CartItemOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemOptionInclude<ExtArgs> | null
  }


  /**
   * Model UserPaymentMethod
   */

  export type AggregateUserPaymentMethod = {
    _count: UserPaymentMethodCountAggregateOutputType | null
    _min: UserPaymentMethodMinAggregateOutputType | null
    _max: UserPaymentMethodMaxAggregateOutputType | null
  }

  export type UserPaymentMethodMinAggregateOutputType = {
    id: string | null
    userId: string | null
    cardToken: string | null
    last4: string | null
    brand: string | null
    isDefault: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPaymentMethodMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    cardToken: string | null
    last4: string | null
    brand: string | null
    isDefault: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPaymentMethodCountAggregateOutputType = {
    id: number
    userId: number
    cardToken: number
    last4: number
    brand: number
    isDefault: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserPaymentMethodMinAggregateInputType = {
    id?: true
    userId?: true
    cardToken?: true
    last4?: true
    brand?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPaymentMethodMaxAggregateInputType = {
    id?: true
    userId?: true
    cardToken?: true
    last4?: true
    brand?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPaymentMethodCountAggregateInputType = {
    id?: true
    userId?: true
    cardToken?: true
    last4?: true
    brand?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserPaymentMethodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPaymentMethod to aggregate.
     */
    where?: UserPaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPaymentMethods to fetch.
     */
    orderBy?: UserPaymentMethodOrderByWithRelationInput | UserPaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPaymentMethods
    **/
    _count?: true | UserPaymentMethodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPaymentMethodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPaymentMethodMaxAggregateInputType
  }

  export type GetUserPaymentMethodAggregateType<T extends UserPaymentMethodAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPaymentMethod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPaymentMethod[P]>
      : GetScalarType<T[P], AggregateUserPaymentMethod[P]>
  }




  export type UserPaymentMethodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPaymentMethodWhereInput
    orderBy?: UserPaymentMethodOrderByWithAggregationInput | UserPaymentMethodOrderByWithAggregationInput[]
    by: UserPaymentMethodScalarFieldEnum[] | UserPaymentMethodScalarFieldEnum
    having?: UserPaymentMethodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPaymentMethodCountAggregateInputType | true
    _min?: UserPaymentMethodMinAggregateInputType
    _max?: UserPaymentMethodMaxAggregateInputType
  }

  export type UserPaymentMethodGroupByOutputType = {
    id: string
    userId: string
    cardToken: string
    last4: string
    brand: string
    isDefault: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserPaymentMethodCountAggregateOutputType | null
    _min: UserPaymentMethodMinAggregateOutputType | null
    _max: UserPaymentMethodMaxAggregateOutputType | null
  }

  type GetUserPaymentMethodGroupByPayload<T extends UserPaymentMethodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPaymentMethodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPaymentMethodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPaymentMethodGroupByOutputType[P]>
            : GetScalarType<T[P], UserPaymentMethodGroupByOutputType[P]>
        }
      >
    >


  export type UserPaymentMethodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    cardToken?: boolean
    last4?: boolean
    brand?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPaymentMethod"]>

  export type UserPaymentMethodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    cardToken?: boolean
    last4?: boolean
    brand?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPaymentMethod"]>

  export type UserPaymentMethodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    cardToken?: boolean
    last4?: boolean
    brand?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPaymentMethod"]>

  export type UserPaymentMethodSelectScalar = {
    id?: boolean
    userId?: boolean
    cardToken?: boolean
    last4?: boolean
    brand?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserPaymentMethodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "cardToken" | "last4" | "brand" | "isDefault" | "createdAt" | "updatedAt", ExtArgs["result"]["userPaymentMethod"]>
  export type UserPaymentMethodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPaymentMethodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPaymentMethodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserPaymentMethodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPaymentMethod"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      cardToken: string
      last4: string
      brand: string
      isDefault: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userPaymentMethod"]>
    composites: {}
  }

  type UserPaymentMethodGetPayload<S extends boolean | null | undefined | UserPaymentMethodDefaultArgs> = $Result.GetResult<Prisma.$UserPaymentMethodPayload, S>

  type UserPaymentMethodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPaymentMethodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPaymentMethodCountAggregateInputType | true
    }

  export interface UserPaymentMethodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPaymentMethod'], meta: { name: 'UserPaymentMethod' } }
    /**
     * Find zero or one UserPaymentMethod that matches the filter.
     * @param {UserPaymentMethodFindUniqueArgs} args - Arguments to find a UserPaymentMethod
     * @example
     * // Get one UserPaymentMethod
     * const userPaymentMethod = await prisma.userPaymentMethod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPaymentMethodFindUniqueArgs>(args: SelectSubset<T, UserPaymentMethodFindUniqueArgs<ExtArgs>>): Prisma__UserPaymentMethodClient<$Result.GetResult<Prisma.$UserPaymentMethodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPaymentMethod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPaymentMethodFindUniqueOrThrowArgs} args - Arguments to find a UserPaymentMethod
     * @example
     * // Get one UserPaymentMethod
     * const userPaymentMethod = await prisma.userPaymentMethod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPaymentMethodFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPaymentMethodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPaymentMethodClient<$Result.GetResult<Prisma.$UserPaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPaymentMethod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPaymentMethodFindFirstArgs} args - Arguments to find a UserPaymentMethod
     * @example
     * // Get one UserPaymentMethod
     * const userPaymentMethod = await prisma.userPaymentMethod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPaymentMethodFindFirstArgs>(args?: SelectSubset<T, UserPaymentMethodFindFirstArgs<ExtArgs>>): Prisma__UserPaymentMethodClient<$Result.GetResult<Prisma.$UserPaymentMethodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPaymentMethod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPaymentMethodFindFirstOrThrowArgs} args - Arguments to find a UserPaymentMethod
     * @example
     * // Get one UserPaymentMethod
     * const userPaymentMethod = await prisma.userPaymentMethod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPaymentMethodFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPaymentMethodFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPaymentMethodClient<$Result.GetResult<Prisma.$UserPaymentMethodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPaymentMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPaymentMethodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPaymentMethods
     * const userPaymentMethods = await prisma.userPaymentMethod.findMany()
     * 
     * // Get first 10 UserPaymentMethods
     * const userPaymentMethods = await prisma.userPaymentMethod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPaymentMethodWithIdOnly = await prisma.userPaymentMethod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPaymentMethodFindManyArgs>(args?: SelectSubset<T, UserPaymentMethodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPaymentMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPaymentMethod.
     * @param {UserPaymentMethodCreateArgs} args - Arguments to create a UserPaymentMethod.
     * @example
     * // Create one UserPaymentMethod
     * const UserPaymentMethod = await prisma.userPaymentMethod.create({
     *   data: {
     *     // ... data to create a UserPaymentMethod
     *   }
     * })
     * 
     */
    create<T extends UserPaymentMethodCreateArgs>(args: SelectSubset<T, UserPaymentMethodCreateArgs<ExtArgs>>): Prisma__UserPaymentMethodClient<$Result.GetResult<Prisma.$UserPaymentMethodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPaymentMethods.
     * @param {UserPaymentMethodCreateManyArgs} args - Arguments to create many UserPaymentMethods.
     * @example
     * // Create many UserPaymentMethods
     * const userPaymentMethod = await prisma.userPaymentMethod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPaymentMethodCreateManyArgs>(args?: SelectSubset<T, UserPaymentMethodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPaymentMethods and returns the data saved in the database.
     * @param {UserPaymentMethodCreateManyAndReturnArgs} args - Arguments to create many UserPaymentMethods.
     * @example
     * // Create many UserPaymentMethods
     * const userPaymentMethod = await prisma.userPaymentMethod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPaymentMethods and only return the `id`
     * const userPaymentMethodWithIdOnly = await prisma.userPaymentMethod.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPaymentMethodCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPaymentMethodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPaymentMethodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPaymentMethod.
     * @param {UserPaymentMethodDeleteArgs} args - Arguments to delete one UserPaymentMethod.
     * @example
     * // Delete one UserPaymentMethod
     * const UserPaymentMethod = await prisma.userPaymentMethod.delete({
     *   where: {
     *     // ... filter to delete one UserPaymentMethod
     *   }
     * })
     * 
     */
    delete<T extends UserPaymentMethodDeleteArgs>(args: SelectSubset<T, UserPaymentMethodDeleteArgs<ExtArgs>>): Prisma__UserPaymentMethodClient<$Result.GetResult<Prisma.$UserPaymentMethodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPaymentMethod.
     * @param {UserPaymentMethodUpdateArgs} args - Arguments to update one UserPaymentMethod.
     * @example
     * // Update one UserPaymentMethod
     * const userPaymentMethod = await prisma.userPaymentMethod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPaymentMethodUpdateArgs>(args: SelectSubset<T, UserPaymentMethodUpdateArgs<ExtArgs>>): Prisma__UserPaymentMethodClient<$Result.GetResult<Prisma.$UserPaymentMethodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPaymentMethods.
     * @param {UserPaymentMethodDeleteManyArgs} args - Arguments to filter UserPaymentMethods to delete.
     * @example
     * // Delete a few UserPaymentMethods
     * const { count } = await prisma.userPaymentMethod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPaymentMethodDeleteManyArgs>(args?: SelectSubset<T, UserPaymentMethodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPaymentMethodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPaymentMethods
     * const userPaymentMethod = await prisma.userPaymentMethod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPaymentMethodUpdateManyArgs>(args: SelectSubset<T, UserPaymentMethodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPaymentMethods and returns the data updated in the database.
     * @param {UserPaymentMethodUpdateManyAndReturnArgs} args - Arguments to update many UserPaymentMethods.
     * @example
     * // Update many UserPaymentMethods
     * const userPaymentMethod = await prisma.userPaymentMethod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPaymentMethods and only return the `id`
     * const userPaymentMethodWithIdOnly = await prisma.userPaymentMethod.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPaymentMethodUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPaymentMethodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPaymentMethodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPaymentMethod.
     * @param {UserPaymentMethodUpsertArgs} args - Arguments to update or create a UserPaymentMethod.
     * @example
     * // Update or create a UserPaymentMethod
     * const userPaymentMethod = await prisma.userPaymentMethod.upsert({
     *   create: {
     *     // ... data to create a UserPaymentMethod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPaymentMethod we want to update
     *   }
     * })
     */
    upsert<T extends UserPaymentMethodUpsertArgs>(args: SelectSubset<T, UserPaymentMethodUpsertArgs<ExtArgs>>): Prisma__UserPaymentMethodClient<$Result.GetResult<Prisma.$UserPaymentMethodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPaymentMethodCountArgs} args - Arguments to filter UserPaymentMethods to count.
     * @example
     * // Count the number of UserPaymentMethods
     * const count = await prisma.userPaymentMethod.count({
     *   where: {
     *     // ... the filter for the UserPaymentMethods we want to count
     *   }
     * })
    **/
    count<T extends UserPaymentMethodCountArgs>(
      args?: Subset<T, UserPaymentMethodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPaymentMethodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPaymentMethodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPaymentMethodAggregateArgs>(args: Subset<T, UserPaymentMethodAggregateArgs>): Prisma.PrismaPromise<GetUserPaymentMethodAggregateType<T>>

    /**
     * Group by UserPaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPaymentMethodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPaymentMethodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPaymentMethodGroupByArgs['orderBy'] }
        : { orderBy?: UserPaymentMethodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPaymentMethodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPaymentMethodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPaymentMethod model
   */
  readonly fields: UserPaymentMethodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPaymentMethod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPaymentMethodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPaymentMethod model
   */
  interface UserPaymentMethodFieldRefs {
    readonly id: FieldRef<"UserPaymentMethod", 'String'>
    readonly userId: FieldRef<"UserPaymentMethod", 'String'>
    readonly cardToken: FieldRef<"UserPaymentMethod", 'String'>
    readonly last4: FieldRef<"UserPaymentMethod", 'String'>
    readonly brand: FieldRef<"UserPaymentMethod", 'String'>
    readonly isDefault: FieldRef<"UserPaymentMethod", 'Boolean'>
    readonly createdAt: FieldRef<"UserPaymentMethod", 'DateTime'>
    readonly updatedAt: FieldRef<"UserPaymentMethod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserPaymentMethod findUnique
   */
  export type UserPaymentMethodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPaymentMethod
     */
    select?: UserPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPaymentMethod
     */
    omit?: UserPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which UserPaymentMethod to fetch.
     */
    where: UserPaymentMethodWhereUniqueInput
  }

  /**
   * UserPaymentMethod findUniqueOrThrow
   */
  export type UserPaymentMethodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPaymentMethod
     */
    select?: UserPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPaymentMethod
     */
    omit?: UserPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which UserPaymentMethod to fetch.
     */
    where: UserPaymentMethodWhereUniqueInput
  }

  /**
   * UserPaymentMethod findFirst
   */
  export type UserPaymentMethodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPaymentMethod
     */
    select?: UserPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPaymentMethod
     */
    omit?: UserPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which UserPaymentMethod to fetch.
     */
    where?: UserPaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPaymentMethods to fetch.
     */
    orderBy?: UserPaymentMethodOrderByWithRelationInput | UserPaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPaymentMethods.
     */
    cursor?: UserPaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPaymentMethods.
     */
    distinct?: UserPaymentMethodScalarFieldEnum | UserPaymentMethodScalarFieldEnum[]
  }

  /**
   * UserPaymentMethod findFirstOrThrow
   */
  export type UserPaymentMethodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPaymentMethod
     */
    select?: UserPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPaymentMethod
     */
    omit?: UserPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which UserPaymentMethod to fetch.
     */
    where?: UserPaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPaymentMethods to fetch.
     */
    orderBy?: UserPaymentMethodOrderByWithRelationInput | UserPaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPaymentMethods.
     */
    cursor?: UserPaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPaymentMethods.
     */
    distinct?: UserPaymentMethodScalarFieldEnum | UserPaymentMethodScalarFieldEnum[]
  }

  /**
   * UserPaymentMethod findMany
   */
  export type UserPaymentMethodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPaymentMethod
     */
    select?: UserPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPaymentMethod
     */
    omit?: UserPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which UserPaymentMethods to fetch.
     */
    where?: UserPaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPaymentMethods to fetch.
     */
    orderBy?: UserPaymentMethodOrderByWithRelationInput | UserPaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPaymentMethods.
     */
    cursor?: UserPaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPaymentMethods.
     */
    skip?: number
    distinct?: UserPaymentMethodScalarFieldEnum | UserPaymentMethodScalarFieldEnum[]
  }

  /**
   * UserPaymentMethod create
   */
  export type UserPaymentMethodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPaymentMethod
     */
    select?: UserPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPaymentMethod
     */
    omit?: UserPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPaymentMethod.
     */
    data: XOR<UserPaymentMethodCreateInput, UserPaymentMethodUncheckedCreateInput>
  }

  /**
   * UserPaymentMethod createMany
   */
  export type UserPaymentMethodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPaymentMethods.
     */
    data: UserPaymentMethodCreateManyInput | UserPaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPaymentMethod createManyAndReturn
   */
  export type UserPaymentMethodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPaymentMethod
     */
    select?: UserPaymentMethodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPaymentMethod
     */
    omit?: UserPaymentMethodOmit<ExtArgs> | null
    /**
     * The data used to create many UserPaymentMethods.
     */
    data: UserPaymentMethodCreateManyInput | UserPaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaymentMethodIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPaymentMethod update
   */
  export type UserPaymentMethodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPaymentMethod
     */
    select?: UserPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPaymentMethod
     */
    omit?: UserPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPaymentMethod.
     */
    data: XOR<UserPaymentMethodUpdateInput, UserPaymentMethodUncheckedUpdateInput>
    /**
     * Choose, which UserPaymentMethod to update.
     */
    where: UserPaymentMethodWhereUniqueInput
  }

  /**
   * UserPaymentMethod updateMany
   */
  export type UserPaymentMethodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPaymentMethods.
     */
    data: XOR<UserPaymentMethodUpdateManyMutationInput, UserPaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which UserPaymentMethods to update
     */
    where?: UserPaymentMethodWhereInput
    /**
     * Limit how many UserPaymentMethods to update.
     */
    limit?: number
  }

  /**
   * UserPaymentMethod updateManyAndReturn
   */
  export type UserPaymentMethodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPaymentMethod
     */
    select?: UserPaymentMethodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPaymentMethod
     */
    omit?: UserPaymentMethodOmit<ExtArgs> | null
    /**
     * The data used to update UserPaymentMethods.
     */
    data: XOR<UserPaymentMethodUpdateManyMutationInput, UserPaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which UserPaymentMethods to update
     */
    where?: UserPaymentMethodWhereInput
    /**
     * Limit how many UserPaymentMethods to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaymentMethodIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPaymentMethod upsert
   */
  export type UserPaymentMethodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPaymentMethod
     */
    select?: UserPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPaymentMethod
     */
    omit?: UserPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaymentMethodInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPaymentMethod to update in case it exists.
     */
    where: UserPaymentMethodWhereUniqueInput
    /**
     * In case the UserPaymentMethod found by the `where` argument doesn't exist, create a new UserPaymentMethod with this data.
     */
    create: XOR<UserPaymentMethodCreateInput, UserPaymentMethodUncheckedCreateInput>
    /**
     * In case the UserPaymentMethod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPaymentMethodUpdateInput, UserPaymentMethodUncheckedUpdateInput>
  }

  /**
   * UserPaymentMethod delete
   */
  export type UserPaymentMethodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPaymentMethod
     */
    select?: UserPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPaymentMethod
     */
    omit?: UserPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaymentMethodInclude<ExtArgs> | null
    /**
     * Filter which UserPaymentMethod to delete.
     */
    where: UserPaymentMethodWhereUniqueInput
  }

  /**
   * UserPaymentMethod deleteMany
   */
  export type UserPaymentMethodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPaymentMethods to delete
     */
    where?: UserPaymentMethodWhereInput
    /**
     * Limit how many UserPaymentMethods to delete.
     */
    limit?: number
  }

  /**
   * UserPaymentMethod without action
   */
  export type UserPaymentMethodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPaymentMethod
     */
    select?: UserPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPaymentMethod
     */
    omit?: UserPaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaymentMethodInclude<ExtArgs> | null
  }


  /**
   * Model DeliveryPerson
   */

  export type AggregateDeliveryPerson = {
    _count: DeliveryPersonCountAggregateOutputType | null
    _avg: DeliveryPersonAvgAggregateOutputType | null
    _sum: DeliveryPersonSumAggregateOutputType | null
    _min: DeliveryPersonMinAggregateOutputType | null
    _max: DeliveryPersonMaxAggregateOutputType | null
  }

  export type DeliveryPersonAvgAggregateOutputType = {
    rating: number | null
    totalDeliveries: number | null
    latitude: number | null
    longitude: number | null
    walletBalance: number | null
  }

  export type DeliveryPersonSumAggregateOutputType = {
    rating: number | null
    totalDeliveries: number | null
    latitude: number | null
    longitude: number | null
    walletBalance: number | null
  }

  export type DeliveryPersonMinAggregateOutputType = {
    id: string | null
    userId: string | null
    vehicleType: string | null
    licensePlate: string | null
    status: string | null
    rating: number | null
    totalDeliveries: number | null
    isOnline: boolean | null
    latitude: number | null
    longitude: number | null
    lastSeenAt: Date | null
    walletBalance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeliveryPersonMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    vehicleType: string | null
    licensePlate: string | null
    status: string | null
    rating: number | null
    totalDeliveries: number | null
    isOnline: boolean | null
    latitude: number | null
    longitude: number | null
    lastSeenAt: Date | null
    walletBalance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeliveryPersonCountAggregateOutputType = {
    id: number
    userId: number
    vehicleType: number
    licensePlate: number
    status: number
    rating: number
    totalDeliveries: number
    isOnline: number
    latitude: number
    longitude: number
    lastSeenAt: number
    walletBalance: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeliveryPersonAvgAggregateInputType = {
    rating?: true
    totalDeliveries?: true
    latitude?: true
    longitude?: true
    walletBalance?: true
  }

  export type DeliveryPersonSumAggregateInputType = {
    rating?: true
    totalDeliveries?: true
    latitude?: true
    longitude?: true
    walletBalance?: true
  }

  export type DeliveryPersonMinAggregateInputType = {
    id?: true
    userId?: true
    vehicleType?: true
    licensePlate?: true
    status?: true
    rating?: true
    totalDeliveries?: true
    isOnline?: true
    latitude?: true
    longitude?: true
    lastSeenAt?: true
    walletBalance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeliveryPersonMaxAggregateInputType = {
    id?: true
    userId?: true
    vehicleType?: true
    licensePlate?: true
    status?: true
    rating?: true
    totalDeliveries?: true
    isOnline?: true
    latitude?: true
    longitude?: true
    lastSeenAt?: true
    walletBalance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeliveryPersonCountAggregateInputType = {
    id?: true
    userId?: true
    vehicleType?: true
    licensePlate?: true
    status?: true
    rating?: true
    totalDeliveries?: true
    isOnline?: true
    latitude?: true
    longitude?: true
    lastSeenAt?: true
    walletBalance?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeliveryPersonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryPerson to aggregate.
     */
    where?: DeliveryPersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryPeople to fetch.
     */
    orderBy?: DeliveryPersonOrderByWithRelationInput | DeliveryPersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryPersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryPeople from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryPeople.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryPeople
    **/
    _count?: true | DeliveryPersonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryPersonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliveryPersonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryPersonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryPersonMaxAggregateInputType
  }

  export type GetDeliveryPersonAggregateType<T extends DeliveryPersonAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryPerson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryPerson[P]>
      : GetScalarType<T[P], AggregateDeliveryPerson[P]>
  }




  export type DeliveryPersonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryPersonWhereInput
    orderBy?: DeliveryPersonOrderByWithAggregationInput | DeliveryPersonOrderByWithAggregationInput[]
    by: DeliveryPersonScalarFieldEnum[] | DeliveryPersonScalarFieldEnum
    having?: DeliveryPersonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryPersonCountAggregateInputType | true
    _avg?: DeliveryPersonAvgAggregateInputType
    _sum?: DeliveryPersonSumAggregateInputType
    _min?: DeliveryPersonMinAggregateInputType
    _max?: DeliveryPersonMaxAggregateInputType
  }

  export type DeliveryPersonGroupByOutputType = {
    id: string
    userId: string
    vehicleType: string | null
    licensePlate: string | null
    status: string
    rating: number
    totalDeliveries: number
    isOnline: boolean
    latitude: number | null
    longitude: number | null
    lastSeenAt: Date | null
    walletBalance: number
    createdAt: Date
    updatedAt: Date
    _count: DeliveryPersonCountAggregateOutputType | null
    _avg: DeliveryPersonAvgAggregateOutputType | null
    _sum: DeliveryPersonSumAggregateOutputType | null
    _min: DeliveryPersonMinAggregateOutputType | null
    _max: DeliveryPersonMaxAggregateOutputType | null
  }

  type GetDeliveryPersonGroupByPayload<T extends DeliveryPersonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryPersonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryPersonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryPersonGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryPersonGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryPersonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    vehicleType?: boolean
    licensePlate?: boolean
    status?: boolean
    rating?: boolean
    totalDeliveries?: boolean
    isOnline?: boolean
    latitude?: boolean
    longitude?: boolean
    lastSeenAt?: boolean
    walletBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    assignedOrders?: boolean | DeliveryPerson$assignedOrdersArgs<ExtArgs>
    earnings?: boolean | DeliveryPerson$earningsArgs<ExtArgs>
    DriverLocationLog?: boolean | DeliveryPerson$DriverLocationLogArgs<ExtArgs>
    Activity?: boolean | DeliveryPerson$ActivityArgs<ExtArgs>
    _count?: boolean | DeliveryPersonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryPerson"]>

  export type DeliveryPersonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    vehicleType?: boolean
    licensePlate?: boolean
    status?: boolean
    rating?: boolean
    totalDeliveries?: boolean
    isOnline?: boolean
    latitude?: boolean
    longitude?: boolean
    lastSeenAt?: boolean
    walletBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryPerson"]>

  export type DeliveryPersonSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    vehicleType?: boolean
    licensePlate?: boolean
    status?: boolean
    rating?: boolean
    totalDeliveries?: boolean
    isOnline?: boolean
    latitude?: boolean
    longitude?: boolean
    lastSeenAt?: boolean
    walletBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryPerson"]>

  export type DeliveryPersonSelectScalar = {
    id?: boolean
    userId?: boolean
    vehicleType?: boolean
    licensePlate?: boolean
    status?: boolean
    rating?: boolean
    totalDeliveries?: boolean
    isOnline?: boolean
    latitude?: boolean
    longitude?: boolean
    lastSeenAt?: boolean
    walletBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DeliveryPersonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "vehicleType" | "licensePlate" | "status" | "rating" | "totalDeliveries" | "isOnline" | "latitude" | "longitude" | "lastSeenAt" | "walletBalance" | "createdAt" | "updatedAt", ExtArgs["result"]["deliveryPerson"]>
  export type DeliveryPersonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    assignedOrders?: boolean | DeliveryPerson$assignedOrdersArgs<ExtArgs>
    earnings?: boolean | DeliveryPerson$earningsArgs<ExtArgs>
    DriverLocationLog?: boolean | DeliveryPerson$DriverLocationLogArgs<ExtArgs>
    Activity?: boolean | DeliveryPerson$ActivityArgs<ExtArgs>
    _count?: boolean | DeliveryPersonCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeliveryPersonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DeliveryPersonIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DeliveryPersonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliveryPerson"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      assignedOrders: Prisma.$DeliveryAssignmentPayload<ExtArgs>[]
      earnings: Prisma.$DeliveryEarningPayload<ExtArgs>[]
      DriverLocationLog: Prisma.$DriverLocationLogPayload<ExtArgs>[]
      Activity: Prisma.$ActivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      vehicleType: string | null
      licensePlate: string | null
      status: string
      rating: number
      totalDeliveries: number
      isOnline: boolean
      latitude: number | null
      longitude: number | null
      lastSeenAt: Date | null
      walletBalance: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deliveryPerson"]>
    composites: {}
  }

  type DeliveryPersonGetPayload<S extends boolean | null | undefined | DeliveryPersonDefaultArgs> = $Result.GetResult<Prisma.$DeliveryPersonPayload, S>

  type DeliveryPersonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeliveryPersonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeliveryPersonCountAggregateInputType | true
    }

  export interface DeliveryPersonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryPerson'], meta: { name: 'DeliveryPerson' } }
    /**
     * Find zero or one DeliveryPerson that matches the filter.
     * @param {DeliveryPersonFindUniqueArgs} args - Arguments to find a DeliveryPerson
     * @example
     * // Get one DeliveryPerson
     * const deliveryPerson = await prisma.deliveryPerson.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryPersonFindUniqueArgs>(args: SelectSubset<T, DeliveryPersonFindUniqueArgs<ExtArgs>>): Prisma__DeliveryPersonClient<$Result.GetResult<Prisma.$DeliveryPersonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeliveryPerson that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeliveryPersonFindUniqueOrThrowArgs} args - Arguments to find a DeliveryPerson
     * @example
     * // Get one DeliveryPerson
     * const deliveryPerson = await prisma.deliveryPerson.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryPersonFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryPersonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryPersonClient<$Result.GetResult<Prisma.$DeliveryPersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryPerson that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryPersonFindFirstArgs} args - Arguments to find a DeliveryPerson
     * @example
     * // Get one DeliveryPerson
     * const deliveryPerson = await prisma.deliveryPerson.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryPersonFindFirstArgs>(args?: SelectSubset<T, DeliveryPersonFindFirstArgs<ExtArgs>>): Prisma__DeliveryPersonClient<$Result.GetResult<Prisma.$DeliveryPersonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryPerson that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryPersonFindFirstOrThrowArgs} args - Arguments to find a DeliveryPerson
     * @example
     * // Get one DeliveryPerson
     * const deliveryPerson = await prisma.deliveryPerson.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryPersonFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryPersonFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryPersonClient<$Result.GetResult<Prisma.$DeliveryPersonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeliveryPeople that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryPersonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryPeople
     * const deliveryPeople = await prisma.deliveryPerson.findMany()
     * 
     * // Get first 10 DeliveryPeople
     * const deliveryPeople = await prisma.deliveryPerson.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryPersonWithIdOnly = await prisma.deliveryPerson.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryPersonFindManyArgs>(args?: SelectSubset<T, DeliveryPersonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPersonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeliveryPerson.
     * @param {DeliveryPersonCreateArgs} args - Arguments to create a DeliveryPerson.
     * @example
     * // Create one DeliveryPerson
     * const DeliveryPerson = await prisma.deliveryPerson.create({
     *   data: {
     *     // ... data to create a DeliveryPerson
     *   }
     * })
     * 
     */
    create<T extends DeliveryPersonCreateArgs>(args: SelectSubset<T, DeliveryPersonCreateArgs<ExtArgs>>): Prisma__DeliveryPersonClient<$Result.GetResult<Prisma.$DeliveryPersonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeliveryPeople.
     * @param {DeliveryPersonCreateManyArgs} args - Arguments to create many DeliveryPeople.
     * @example
     * // Create many DeliveryPeople
     * const deliveryPerson = await prisma.deliveryPerson.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryPersonCreateManyArgs>(args?: SelectSubset<T, DeliveryPersonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeliveryPeople and returns the data saved in the database.
     * @param {DeliveryPersonCreateManyAndReturnArgs} args - Arguments to create many DeliveryPeople.
     * @example
     * // Create many DeliveryPeople
     * const deliveryPerson = await prisma.deliveryPerson.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeliveryPeople and only return the `id`
     * const deliveryPersonWithIdOnly = await prisma.deliveryPerson.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryPersonCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryPersonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPersonPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeliveryPerson.
     * @param {DeliveryPersonDeleteArgs} args - Arguments to delete one DeliveryPerson.
     * @example
     * // Delete one DeliveryPerson
     * const DeliveryPerson = await prisma.deliveryPerson.delete({
     *   where: {
     *     // ... filter to delete one DeliveryPerson
     *   }
     * })
     * 
     */
    delete<T extends DeliveryPersonDeleteArgs>(args: SelectSubset<T, DeliveryPersonDeleteArgs<ExtArgs>>): Prisma__DeliveryPersonClient<$Result.GetResult<Prisma.$DeliveryPersonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeliveryPerson.
     * @param {DeliveryPersonUpdateArgs} args - Arguments to update one DeliveryPerson.
     * @example
     * // Update one DeliveryPerson
     * const deliveryPerson = await prisma.deliveryPerson.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryPersonUpdateArgs>(args: SelectSubset<T, DeliveryPersonUpdateArgs<ExtArgs>>): Prisma__DeliveryPersonClient<$Result.GetResult<Prisma.$DeliveryPersonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeliveryPeople.
     * @param {DeliveryPersonDeleteManyArgs} args - Arguments to filter DeliveryPeople to delete.
     * @example
     * // Delete a few DeliveryPeople
     * const { count } = await prisma.deliveryPerson.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryPersonDeleteManyArgs>(args?: SelectSubset<T, DeliveryPersonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryPeople.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryPersonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryPeople
     * const deliveryPerson = await prisma.deliveryPerson.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryPersonUpdateManyArgs>(args: SelectSubset<T, DeliveryPersonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryPeople and returns the data updated in the database.
     * @param {DeliveryPersonUpdateManyAndReturnArgs} args - Arguments to update many DeliveryPeople.
     * @example
     * // Update many DeliveryPeople
     * const deliveryPerson = await prisma.deliveryPerson.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeliveryPeople and only return the `id`
     * const deliveryPersonWithIdOnly = await prisma.deliveryPerson.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeliveryPersonUpdateManyAndReturnArgs>(args: SelectSubset<T, DeliveryPersonUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPersonPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeliveryPerson.
     * @param {DeliveryPersonUpsertArgs} args - Arguments to update or create a DeliveryPerson.
     * @example
     * // Update or create a DeliveryPerson
     * const deliveryPerson = await prisma.deliveryPerson.upsert({
     *   create: {
     *     // ... data to create a DeliveryPerson
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryPerson we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryPersonUpsertArgs>(args: SelectSubset<T, DeliveryPersonUpsertArgs<ExtArgs>>): Prisma__DeliveryPersonClient<$Result.GetResult<Prisma.$DeliveryPersonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeliveryPeople.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryPersonCountArgs} args - Arguments to filter DeliveryPeople to count.
     * @example
     * // Count the number of DeliveryPeople
     * const count = await prisma.deliveryPerson.count({
     *   where: {
     *     // ... the filter for the DeliveryPeople we want to count
     *   }
     * })
    **/
    count<T extends DeliveryPersonCountArgs>(
      args?: Subset<T, DeliveryPersonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryPersonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryPerson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryPersonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryPersonAggregateArgs>(args: Subset<T, DeliveryPersonAggregateArgs>): Prisma.PrismaPromise<GetDeliveryPersonAggregateType<T>>

    /**
     * Group by DeliveryPerson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryPersonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryPersonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryPersonGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryPersonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryPersonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryPersonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryPerson model
   */
  readonly fields: DeliveryPersonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryPerson.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryPersonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignedOrders<T extends DeliveryPerson$assignedOrdersArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryPerson$assignedOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    earnings<T extends DeliveryPerson$earningsArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryPerson$earningsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryEarningPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DriverLocationLog<T extends DeliveryPerson$DriverLocationLogArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryPerson$DriverLocationLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverLocationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Activity<T extends DeliveryPerson$ActivityArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryPerson$ActivityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliveryPerson model
   */
  interface DeliveryPersonFieldRefs {
    readonly id: FieldRef<"DeliveryPerson", 'String'>
    readonly userId: FieldRef<"DeliveryPerson", 'String'>
    readonly vehicleType: FieldRef<"DeliveryPerson", 'String'>
    readonly licensePlate: FieldRef<"DeliveryPerson", 'String'>
    readonly status: FieldRef<"DeliveryPerson", 'String'>
    readonly rating: FieldRef<"DeliveryPerson", 'Float'>
    readonly totalDeliveries: FieldRef<"DeliveryPerson", 'Int'>
    readonly isOnline: FieldRef<"DeliveryPerson", 'Boolean'>
    readonly latitude: FieldRef<"DeliveryPerson", 'Float'>
    readonly longitude: FieldRef<"DeliveryPerson", 'Float'>
    readonly lastSeenAt: FieldRef<"DeliveryPerson", 'DateTime'>
    readonly walletBalance: FieldRef<"DeliveryPerson", 'Float'>
    readonly createdAt: FieldRef<"DeliveryPerson", 'DateTime'>
    readonly updatedAt: FieldRef<"DeliveryPerson", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeliveryPerson findUnique
   */
  export type DeliveryPersonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPerson
     */
    select?: DeliveryPersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPerson
     */
    omit?: DeliveryPersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPersonInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryPerson to fetch.
     */
    where: DeliveryPersonWhereUniqueInput
  }

  /**
   * DeliveryPerson findUniqueOrThrow
   */
  export type DeliveryPersonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPerson
     */
    select?: DeliveryPersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPerson
     */
    omit?: DeliveryPersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPersonInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryPerson to fetch.
     */
    where: DeliveryPersonWhereUniqueInput
  }

  /**
   * DeliveryPerson findFirst
   */
  export type DeliveryPersonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPerson
     */
    select?: DeliveryPersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPerson
     */
    omit?: DeliveryPersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPersonInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryPerson to fetch.
     */
    where?: DeliveryPersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryPeople to fetch.
     */
    orderBy?: DeliveryPersonOrderByWithRelationInput | DeliveryPersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryPeople.
     */
    cursor?: DeliveryPersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryPeople from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryPeople.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryPeople.
     */
    distinct?: DeliveryPersonScalarFieldEnum | DeliveryPersonScalarFieldEnum[]
  }

  /**
   * DeliveryPerson findFirstOrThrow
   */
  export type DeliveryPersonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPerson
     */
    select?: DeliveryPersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPerson
     */
    omit?: DeliveryPersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPersonInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryPerson to fetch.
     */
    where?: DeliveryPersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryPeople to fetch.
     */
    orderBy?: DeliveryPersonOrderByWithRelationInput | DeliveryPersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryPeople.
     */
    cursor?: DeliveryPersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryPeople from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryPeople.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryPeople.
     */
    distinct?: DeliveryPersonScalarFieldEnum | DeliveryPersonScalarFieldEnum[]
  }

  /**
   * DeliveryPerson findMany
   */
  export type DeliveryPersonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPerson
     */
    select?: DeliveryPersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPerson
     */
    omit?: DeliveryPersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPersonInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryPeople to fetch.
     */
    where?: DeliveryPersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryPeople to fetch.
     */
    orderBy?: DeliveryPersonOrderByWithRelationInput | DeliveryPersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryPeople.
     */
    cursor?: DeliveryPersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryPeople from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryPeople.
     */
    skip?: number
    distinct?: DeliveryPersonScalarFieldEnum | DeliveryPersonScalarFieldEnum[]
  }

  /**
   * DeliveryPerson create
   */
  export type DeliveryPersonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPerson
     */
    select?: DeliveryPersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPerson
     */
    omit?: DeliveryPersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPersonInclude<ExtArgs> | null
    /**
     * The data needed to create a DeliveryPerson.
     */
    data: XOR<DeliveryPersonCreateInput, DeliveryPersonUncheckedCreateInput>
  }

  /**
   * DeliveryPerson createMany
   */
  export type DeliveryPersonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryPeople.
     */
    data: DeliveryPersonCreateManyInput | DeliveryPersonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryPerson createManyAndReturn
   */
  export type DeliveryPersonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPerson
     */
    select?: DeliveryPersonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPerson
     */
    omit?: DeliveryPersonOmit<ExtArgs> | null
    /**
     * The data used to create many DeliveryPeople.
     */
    data: DeliveryPersonCreateManyInput | DeliveryPersonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPersonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryPerson update
   */
  export type DeliveryPersonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPerson
     */
    select?: DeliveryPersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPerson
     */
    omit?: DeliveryPersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPersonInclude<ExtArgs> | null
    /**
     * The data needed to update a DeliveryPerson.
     */
    data: XOR<DeliveryPersonUpdateInput, DeliveryPersonUncheckedUpdateInput>
    /**
     * Choose, which DeliveryPerson to update.
     */
    where: DeliveryPersonWhereUniqueInput
  }

  /**
   * DeliveryPerson updateMany
   */
  export type DeliveryPersonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryPeople.
     */
    data: XOR<DeliveryPersonUpdateManyMutationInput, DeliveryPersonUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryPeople to update
     */
    where?: DeliveryPersonWhereInput
    /**
     * Limit how many DeliveryPeople to update.
     */
    limit?: number
  }

  /**
   * DeliveryPerson updateManyAndReturn
   */
  export type DeliveryPersonUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPerson
     */
    select?: DeliveryPersonSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPerson
     */
    omit?: DeliveryPersonOmit<ExtArgs> | null
    /**
     * The data used to update DeliveryPeople.
     */
    data: XOR<DeliveryPersonUpdateManyMutationInput, DeliveryPersonUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryPeople to update
     */
    where?: DeliveryPersonWhereInput
    /**
     * Limit how many DeliveryPeople to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPersonIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryPerson upsert
   */
  export type DeliveryPersonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPerson
     */
    select?: DeliveryPersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPerson
     */
    omit?: DeliveryPersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPersonInclude<ExtArgs> | null
    /**
     * The filter to search for the DeliveryPerson to update in case it exists.
     */
    where: DeliveryPersonWhereUniqueInput
    /**
     * In case the DeliveryPerson found by the `where` argument doesn't exist, create a new DeliveryPerson with this data.
     */
    create: XOR<DeliveryPersonCreateInput, DeliveryPersonUncheckedCreateInput>
    /**
     * In case the DeliveryPerson was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryPersonUpdateInput, DeliveryPersonUncheckedUpdateInput>
  }

  /**
   * DeliveryPerson delete
   */
  export type DeliveryPersonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPerson
     */
    select?: DeliveryPersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPerson
     */
    omit?: DeliveryPersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPersonInclude<ExtArgs> | null
    /**
     * Filter which DeliveryPerson to delete.
     */
    where: DeliveryPersonWhereUniqueInput
  }

  /**
   * DeliveryPerson deleteMany
   */
  export type DeliveryPersonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryPeople to delete
     */
    where?: DeliveryPersonWhereInput
    /**
     * Limit how many DeliveryPeople to delete.
     */
    limit?: number
  }

  /**
   * DeliveryPerson.assignedOrders
   */
  export type DeliveryPerson$assignedOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryAssignment
     */
    select?: DeliveryAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryAssignment
     */
    omit?: DeliveryAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryAssignmentInclude<ExtArgs> | null
    where?: DeliveryAssignmentWhereInput
    orderBy?: DeliveryAssignmentOrderByWithRelationInput | DeliveryAssignmentOrderByWithRelationInput[]
    cursor?: DeliveryAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryAssignmentScalarFieldEnum | DeliveryAssignmentScalarFieldEnum[]
  }

  /**
   * DeliveryPerson.earnings
   */
  export type DeliveryPerson$earningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEarning
     */
    select?: DeliveryEarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEarning
     */
    omit?: DeliveryEarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEarningInclude<ExtArgs> | null
    where?: DeliveryEarningWhereInput
    orderBy?: DeliveryEarningOrderByWithRelationInput | DeliveryEarningOrderByWithRelationInput[]
    cursor?: DeliveryEarningWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryEarningScalarFieldEnum | DeliveryEarningScalarFieldEnum[]
  }

  /**
   * DeliveryPerson.DriverLocationLog
   */
  export type DeliveryPerson$DriverLocationLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverLocationLog
     */
    select?: DriverLocationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverLocationLog
     */
    omit?: DriverLocationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverLocationLogInclude<ExtArgs> | null
    where?: DriverLocationLogWhereInput
    orderBy?: DriverLocationLogOrderByWithRelationInput | DriverLocationLogOrderByWithRelationInput[]
    cursor?: DriverLocationLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DriverLocationLogScalarFieldEnum | DriverLocationLogScalarFieldEnum[]
  }

  /**
   * DeliveryPerson.Activity
   */
  export type DeliveryPerson$ActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * DeliveryPerson without action
   */
  export type DeliveryPersonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPerson
     */
    select?: DeliveryPersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPerson
     */
    omit?: DeliveryPersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPersonInclude<ExtArgs> | null
  }


  /**
   * Model DeliveryAssignment
   */

  export type AggregateDeliveryAssignment = {
    _count: DeliveryAssignmentCountAggregateOutputType | null
    _avg: DeliveryAssignmentAvgAggregateOutputType | null
    _sum: DeliveryAssignmentSumAggregateOutputType | null
    _min: DeliveryAssignmentMinAggregateOutputType | null
    _max: DeliveryAssignmentMaxAggregateOutputType | null
  }

  export type DeliveryAssignmentAvgAggregateOutputType = {
    timeoutSeconds: number | null
    attempts: number | null
  }

  export type DeliveryAssignmentSumAggregateOutputType = {
    timeoutSeconds: number | null
    attempts: number | null
  }

  export type DeliveryAssignmentMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    deliveryPersonId: string | null
    status: $Enums.DeliveryStatus | null
    assignedAt: Date | null
    acceptedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    declinedAt: Date | null
    timeoutSeconds: number | null
    attempts: number | null
    batchId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeliveryAssignmentMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    deliveryPersonId: string | null
    status: $Enums.DeliveryStatus | null
    assignedAt: Date | null
    acceptedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    declinedAt: Date | null
    timeoutSeconds: number | null
    attempts: number | null
    batchId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeliveryAssignmentCountAggregateOutputType = {
    id: number
    orderId: number
    deliveryPersonId: number
    status: number
    assignedAt: number
    acceptedAt: number
    startedAt: number
    completedAt: number
    declinedAt: number
    timeoutSeconds: number
    attempts: number
    batchId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeliveryAssignmentAvgAggregateInputType = {
    timeoutSeconds?: true
    attempts?: true
  }

  export type DeliveryAssignmentSumAggregateInputType = {
    timeoutSeconds?: true
    attempts?: true
  }

  export type DeliveryAssignmentMinAggregateInputType = {
    id?: true
    orderId?: true
    deliveryPersonId?: true
    status?: true
    assignedAt?: true
    acceptedAt?: true
    startedAt?: true
    completedAt?: true
    declinedAt?: true
    timeoutSeconds?: true
    attempts?: true
    batchId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeliveryAssignmentMaxAggregateInputType = {
    id?: true
    orderId?: true
    deliveryPersonId?: true
    status?: true
    assignedAt?: true
    acceptedAt?: true
    startedAt?: true
    completedAt?: true
    declinedAt?: true
    timeoutSeconds?: true
    attempts?: true
    batchId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeliveryAssignmentCountAggregateInputType = {
    id?: true
    orderId?: true
    deliveryPersonId?: true
    status?: true
    assignedAt?: true
    acceptedAt?: true
    startedAt?: true
    completedAt?: true
    declinedAt?: true
    timeoutSeconds?: true
    attempts?: true
    batchId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeliveryAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryAssignment to aggregate.
     */
    where?: DeliveryAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryAssignments to fetch.
     */
    orderBy?: DeliveryAssignmentOrderByWithRelationInput | DeliveryAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryAssignments
    **/
    _count?: true | DeliveryAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryAssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliveryAssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryAssignmentMaxAggregateInputType
  }

  export type GetDeliveryAssignmentAggregateType<T extends DeliveryAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryAssignment[P]>
      : GetScalarType<T[P], AggregateDeliveryAssignment[P]>
  }




  export type DeliveryAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryAssignmentWhereInput
    orderBy?: DeliveryAssignmentOrderByWithAggregationInput | DeliveryAssignmentOrderByWithAggregationInput[]
    by: DeliveryAssignmentScalarFieldEnum[] | DeliveryAssignmentScalarFieldEnum
    having?: DeliveryAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryAssignmentCountAggregateInputType | true
    _avg?: DeliveryAssignmentAvgAggregateInputType
    _sum?: DeliveryAssignmentSumAggregateInputType
    _min?: DeliveryAssignmentMinAggregateInputType
    _max?: DeliveryAssignmentMaxAggregateInputType
  }

  export type DeliveryAssignmentGroupByOutputType = {
    id: string
    orderId: string
    deliveryPersonId: string
    status: $Enums.DeliveryStatus
    assignedAt: Date
    acceptedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    declinedAt: Date | null
    timeoutSeconds: number
    attempts: number
    batchId: string | null
    createdAt: Date
    updatedAt: Date
    _count: DeliveryAssignmentCountAggregateOutputType | null
    _avg: DeliveryAssignmentAvgAggregateOutputType | null
    _sum: DeliveryAssignmentSumAggregateOutputType | null
    _min: DeliveryAssignmentMinAggregateOutputType | null
    _max: DeliveryAssignmentMaxAggregateOutputType | null
  }

  type GetDeliveryAssignmentGroupByPayload<T extends DeliveryAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    deliveryPersonId?: boolean
    status?: boolean
    assignedAt?: boolean
    acceptedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    declinedAt?: boolean
    timeoutSeconds?: boolean
    attempts?: boolean
    batchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    deliveryPerson?: boolean | DeliveryPersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryAssignment"]>

  export type DeliveryAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    deliveryPersonId?: boolean
    status?: boolean
    assignedAt?: boolean
    acceptedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    declinedAt?: boolean
    timeoutSeconds?: boolean
    attempts?: boolean
    batchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    deliveryPerson?: boolean | DeliveryPersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryAssignment"]>

  export type DeliveryAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    deliveryPersonId?: boolean
    status?: boolean
    assignedAt?: boolean
    acceptedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    declinedAt?: boolean
    timeoutSeconds?: boolean
    attempts?: boolean
    batchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    deliveryPerson?: boolean | DeliveryPersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryAssignment"]>

  export type DeliveryAssignmentSelectScalar = {
    id?: boolean
    orderId?: boolean
    deliveryPersonId?: boolean
    status?: boolean
    assignedAt?: boolean
    acceptedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    declinedAt?: boolean
    timeoutSeconds?: boolean
    attempts?: boolean
    batchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DeliveryAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "deliveryPersonId" | "status" | "assignedAt" | "acceptedAt" | "startedAt" | "completedAt" | "declinedAt" | "timeoutSeconds" | "attempts" | "batchId" | "createdAt" | "updatedAt", ExtArgs["result"]["deliveryAssignment"]>
  export type DeliveryAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    deliveryPerson?: boolean | DeliveryPersonDefaultArgs<ExtArgs>
  }
  export type DeliveryAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    deliveryPerson?: boolean | DeliveryPersonDefaultArgs<ExtArgs>
  }
  export type DeliveryAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    deliveryPerson?: boolean | DeliveryPersonDefaultArgs<ExtArgs>
  }

  export type $DeliveryAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliveryAssignment"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      deliveryPerson: Prisma.$DeliveryPersonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      deliveryPersonId: string
      status: $Enums.DeliveryStatus
      assignedAt: Date
      acceptedAt: Date | null
      startedAt: Date | null
      completedAt: Date | null
      declinedAt: Date | null
      timeoutSeconds: number
      attempts: number
      batchId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deliveryAssignment"]>
    composites: {}
  }

  type DeliveryAssignmentGetPayload<S extends boolean | null | undefined | DeliveryAssignmentDefaultArgs> = $Result.GetResult<Prisma.$DeliveryAssignmentPayload, S>

  type DeliveryAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeliveryAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeliveryAssignmentCountAggregateInputType | true
    }

  export interface DeliveryAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryAssignment'], meta: { name: 'DeliveryAssignment' } }
    /**
     * Find zero or one DeliveryAssignment that matches the filter.
     * @param {DeliveryAssignmentFindUniqueArgs} args - Arguments to find a DeliveryAssignment
     * @example
     * // Get one DeliveryAssignment
     * const deliveryAssignment = await prisma.deliveryAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryAssignmentFindUniqueArgs>(args: SelectSubset<T, DeliveryAssignmentFindUniqueArgs<ExtArgs>>): Prisma__DeliveryAssignmentClient<$Result.GetResult<Prisma.$DeliveryAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeliveryAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeliveryAssignmentFindUniqueOrThrowArgs} args - Arguments to find a DeliveryAssignment
     * @example
     * // Get one DeliveryAssignment
     * const deliveryAssignment = await prisma.deliveryAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryAssignmentClient<$Result.GetResult<Prisma.$DeliveryAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryAssignmentFindFirstArgs} args - Arguments to find a DeliveryAssignment
     * @example
     * // Get one DeliveryAssignment
     * const deliveryAssignment = await prisma.deliveryAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryAssignmentFindFirstArgs>(args?: SelectSubset<T, DeliveryAssignmentFindFirstArgs<ExtArgs>>): Prisma__DeliveryAssignmentClient<$Result.GetResult<Prisma.$DeliveryAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryAssignmentFindFirstOrThrowArgs} args - Arguments to find a DeliveryAssignment
     * @example
     * // Get one DeliveryAssignment
     * const deliveryAssignment = await prisma.deliveryAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryAssignmentClient<$Result.GetResult<Prisma.$DeliveryAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeliveryAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryAssignments
     * const deliveryAssignments = await prisma.deliveryAssignment.findMany()
     * 
     * // Get first 10 DeliveryAssignments
     * const deliveryAssignments = await prisma.deliveryAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryAssignmentWithIdOnly = await prisma.deliveryAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryAssignmentFindManyArgs>(args?: SelectSubset<T, DeliveryAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeliveryAssignment.
     * @param {DeliveryAssignmentCreateArgs} args - Arguments to create a DeliveryAssignment.
     * @example
     * // Create one DeliveryAssignment
     * const DeliveryAssignment = await prisma.deliveryAssignment.create({
     *   data: {
     *     // ... data to create a DeliveryAssignment
     *   }
     * })
     * 
     */
    create<T extends DeliveryAssignmentCreateArgs>(args: SelectSubset<T, DeliveryAssignmentCreateArgs<ExtArgs>>): Prisma__DeliveryAssignmentClient<$Result.GetResult<Prisma.$DeliveryAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeliveryAssignments.
     * @param {DeliveryAssignmentCreateManyArgs} args - Arguments to create many DeliveryAssignments.
     * @example
     * // Create many DeliveryAssignments
     * const deliveryAssignment = await prisma.deliveryAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryAssignmentCreateManyArgs>(args?: SelectSubset<T, DeliveryAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeliveryAssignments and returns the data saved in the database.
     * @param {DeliveryAssignmentCreateManyAndReturnArgs} args - Arguments to create many DeliveryAssignments.
     * @example
     * // Create many DeliveryAssignments
     * const deliveryAssignment = await prisma.deliveryAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeliveryAssignments and only return the `id`
     * const deliveryAssignmentWithIdOnly = await prisma.deliveryAssignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryAssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeliveryAssignment.
     * @param {DeliveryAssignmentDeleteArgs} args - Arguments to delete one DeliveryAssignment.
     * @example
     * // Delete one DeliveryAssignment
     * const DeliveryAssignment = await prisma.deliveryAssignment.delete({
     *   where: {
     *     // ... filter to delete one DeliveryAssignment
     *   }
     * })
     * 
     */
    delete<T extends DeliveryAssignmentDeleteArgs>(args: SelectSubset<T, DeliveryAssignmentDeleteArgs<ExtArgs>>): Prisma__DeliveryAssignmentClient<$Result.GetResult<Prisma.$DeliveryAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeliveryAssignment.
     * @param {DeliveryAssignmentUpdateArgs} args - Arguments to update one DeliveryAssignment.
     * @example
     * // Update one DeliveryAssignment
     * const deliveryAssignment = await prisma.deliveryAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryAssignmentUpdateArgs>(args: SelectSubset<T, DeliveryAssignmentUpdateArgs<ExtArgs>>): Prisma__DeliveryAssignmentClient<$Result.GetResult<Prisma.$DeliveryAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeliveryAssignments.
     * @param {DeliveryAssignmentDeleteManyArgs} args - Arguments to filter DeliveryAssignments to delete.
     * @example
     * // Delete a few DeliveryAssignments
     * const { count } = await prisma.deliveryAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryAssignmentDeleteManyArgs>(args?: SelectSubset<T, DeliveryAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryAssignments
     * const deliveryAssignment = await prisma.deliveryAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryAssignmentUpdateManyArgs>(args: SelectSubset<T, DeliveryAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryAssignments and returns the data updated in the database.
     * @param {DeliveryAssignmentUpdateManyAndReturnArgs} args - Arguments to update many DeliveryAssignments.
     * @example
     * // Update many DeliveryAssignments
     * const deliveryAssignment = await prisma.deliveryAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeliveryAssignments and only return the `id`
     * const deliveryAssignmentWithIdOnly = await prisma.deliveryAssignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeliveryAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, DeliveryAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeliveryAssignment.
     * @param {DeliveryAssignmentUpsertArgs} args - Arguments to update or create a DeliveryAssignment.
     * @example
     * // Update or create a DeliveryAssignment
     * const deliveryAssignment = await prisma.deliveryAssignment.upsert({
     *   create: {
     *     // ... data to create a DeliveryAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryAssignment we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryAssignmentUpsertArgs>(args: SelectSubset<T, DeliveryAssignmentUpsertArgs<ExtArgs>>): Prisma__DeliveryAssignmentClient<$Result.GetResult<Prisma.$DeliveryAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeliveryAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryAssignmentCountArgs} args - Arguments to filter DeliveryAssignments to count.
     * @example
     * // Count the number of DeliveryAssignments
     * const count = await prisma.deliveryAssignment.count({
     *   where: {
     *     // ... the filter for the DeliveryAssignments we want to count
     *   }
     * })
    **/
    count<T extends DeliveryAssignmentCountArgs>(
      args?: Subset<T, DeliveryAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryAssignmentAggregateArgs>(args: Subset<T, DeliveryAssignmentAggregateArgs>): Prisma.PrismaPromise<GetDeliveryAssignmentAggregateType<T>>

    /**
     * Group by DeliveryAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryAssignment model
   */
  readonly fields: DeliveryAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    deliveryPerson<T extends DeliveryPersonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryPersonDefaultArgs<ExtArgs>>): Prisma__DeliveryPersonClient<$Result.GetResult<Prisma.$DeliveryPersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliveryAssignment model
   */
  interface DeliveryAssignmentFieldRefs {
    readonly id: FieldRef<"DeliveryAssignment", 'String'>
    readonly orderId: FieldRef<"DeliveryAssignment", 'String'>
    readonly deliveryPersonId: FieldRef<"DeliveryAssignment", 'String'>
    readonly status: FieldRef<"DeliveryAssignment", 'DeliveryStatus'>
    readonly assignedAt: FieldRef<"DeliveryAssignment", 'DateTime'>
    readonly acceptedAt: FieldRef<"DeliveryAssignment", 'DateTime'>
    readonly startedAt: FieldRef<"DeliveryAssignment", 'DateTime'>
    readonly completedAt: FieldRef<"DeliveryAssignment", 'DateTime'>
    readonly declinedAt: FieldRef<"DeliveryAssignment", 'DateTime'>
    readonly timeoutSeconds: FieldRef<"DeliveryAssignment", 'Int'>
    readonly attempts: FieldRef<"DeliveryAssignment", 'Int'>
    readonly batchId: FieldRef<"DeliveryAssignment", 'String'>
    readonly createdAt: FieldRef<"DeliveryAssignment", 'DateTime'>
    readonly updatedAt: FieldRef<"DeliveryAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeliveryAssignment findUnique
   */
  export type DeliveryAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryAssignment
     */
    select?: DeliveryAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryAssignment
     */
    omit?: DeliveryAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryAssignment to fetch.
     */
    where: DeliveryAssignmentWhereUniqueInput
  }

  /**
   * DeliveryAssignment findUniqueOrThrow
   */
  export type DeliveryAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryAssignment
     */
    select?: DeliveryAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryAssignment
     */
    omit?: DeliveryAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryAssignment to fetch.
     */
    where: DeliveryAssignmentWhereUniqueInput
  }

  /**
   * DeliveryAssignment findFirst
   */
  export type DeliveryAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryAssignment
     */
    select?: DeliveryAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryAssignment
     */
    omit?: DeliveryAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryAssignment to fetch.
     */
    where?: DeliveryAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryAssignments to fetch.
     */
    orderBy?: DeliveryAssignmentOrderByWithRelationInput | DeliveryAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryAssignments.
     */
    cursor?: DeliveryAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryAssignments.
     */
    distinct?: DeliveryAssignmentScalarFieldEnum | DeliveryAssignmentScalarFieldEnum[]
  }

  /**
   * DeliveryAssignment findFirstOrThrow
   */
  export type DeliveryAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryAssignment
     */
    select?: DeliveryAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryAssignment
     */
    omit?: DeliveryAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryAssignment to fetch.
     */
    where?: DeliveryAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryAssignments to fetch.
     */
    orderBy?: DeliveryAssignmentOrderByWithRelationInput | DeliveryAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryAssignments.
     */
    cursor?: DeliveryAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryAssignments.
     */
    distinct?: DeliveryAssignmentScalarFieldEnum | DeliveryAssignmentScalarFieldEnum[]
  }

  /**
   * DeliveryAssignment findMany
   */
  export type DeliveryAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryAssignment
     */
    select?: DeliveryAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryAssignment
     */
    omit?: DeliveryAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryAssignments to fetch.
     */
    where?: DeliveryAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryAssignments to fetch.
     */
    orderBy?: DeliveryAssignmentOrderByWithRelationInput | DeliveryAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryAssignments.
     */
    cursor?: DeliveryAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryAssignments.
     */
    skip?: number
    distinct?: DeliveryAssignmentScalarFieldEnum | DeliveryAssignmentScalarFieldEnum[]
  }

  /**
   * DeliveryAssignment create
   */
  export type DeliveryAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryAssignment
     */
    select?: DeliveryAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryAssignment
     */
    omit?: DeliveryAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a DeliveryAssignment.
     */
    data: XOR<DeliveryAssignmentCreateInput, DeliveryAssignmentUncheckedCreateInput>
  }

  /**
   * DeliveryAssignment createMany
   */
  export type DeliveryAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryAssignments.
     */
    data: DeliveryAssignmentCreateManyInput | DeliveryAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryAssignment createManyAndReturn
   */
  export type DeliveryAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryAssignment
     */
    select?: DeliveryAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryAssignment
     */
    omit?: DeliveryAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many DeliveryAssignments.
     */
    data: DeliveryAssignmentCreateManyInput | DeliveryAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryAssignment update
   */
  export type DeliveryAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryAssignment
     */
    select?: DeliveryAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryAssignment
     */
    omit?: DeliveryAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a DeliveryAssignment.
     */
    data: XOR<DeliveryAssignmentUpdateInput, DeliveryAssignmentUncheckedUpdateInput>
    /**
     * Choose, which DeliveryAssignment to update.
     */
    where: DeliveryAssignmentWhereUniqueInput
  }

  /**
   * DeliveryAssignment updateMany
   */
  export type DeliveryAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryAssignments.
     */
    data: XOR<DeliveryAssignmentUpdateManyMutationInput, DeliveryAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryAssignments to update
     */
    where?: DeliveryAssignmentWhereInput
    /**
     * Limit how many DeliveryAssignments to update.
     */
    limit?: number
  }

  /**
   * DeliveryAssignment updateManyAndReturn
   */
  export type DeliveryAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryAssignment
     */
    select?: DeliveryAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryAssignment
     */
    omit?: DeliveryAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update DeliveryAssignments.
     */
    data: XOR<DeliveryAssignmentUpdateManyMutationInput, DeliveryAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryAssignments to update
     */
    where?: DeliveryAssignmentWhereInput
    /**
     * Limit how many DeliveryAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryAssignment upsert
   */
  export type DeliveryAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryAssignment
     */
    select?: DeliveryAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryAssignment
     */
    omit?: DeliveryAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the DeliveryAssignment to update in case it exists.
     */
    where: DeliveryAssignmentWhereUniqueInput
    /**
     * In case the DeliveryAssignment found by the `where` argument doesn't exist, create a new DeliveryAssignment with this data.
     */
    create: XOR<DeliveryAssignmentCreateInput, DeliveryAssignmentUncheckedCreateInput>
    /**
     * In case the DeliveryAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryAssignmentUpdateInput, DeliveryAssignmentUncheckedUpdateInput>
  }

  /**
   * DeliveryAssignment delete
   */
  export type DeliveryAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryAssignment
     */
    select?: DeliveryAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryAssignment
     */
    omit?: DeliveryAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryAssignmentInclude<ExtArgs> | null
    /**
     * Filter which DeliveryAssignment to delete.
     */
    where: DeliveryAssignmentWhereUniqueInput
  }

  /**
   * DeliveryAssignment deleteMany
   */
  export type DeliveryAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryAssignments to delete
     */
    where?: DeliveryAssignmentWhereInput
    /**
     * Limit how many DeliveryAssignments to delete.
     */
    limit?: number
  }

  /**
   * DeliveryAssignment without action
   */
  export type DeliveryAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryAssignment
     */
    select?: DeliveryAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryAssignment
     */
    omit?: DeliveryAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model DeliveryEarning
   */

  export type AggregateDeliveryEarning = {
    _count: DeliveryEarningCountAggregateOutputType | null
    _avg: DeliveryEarningAvgAggregateOutputType | null
    _sum: DeliveryEarningSumAggregateOutputType | null
    _min: DeliveryEarningMinAggregateOutputType | null
    _max: DeliveryEarningMaxAggregateOutputType | null
  }

  export type DeliveryEarningAvgAggregateOutputType = {
    baseFee: number | null
    distanceFee: number | null
    tip: number | null
    deductions: number | null
    totalEarned: number | null
  }

  export type DeliveryEarningSumAggregateOutputType = {
    baseFee: number | null
    distanceFee: number | null
    tip: number | null
    deductions: number | null
    totalEarned: number | null
  }

  export type DeliveryEarningMinAggregateOutputType = {
    id: string | null
    deliveryPersonId: string | null
    orderId: string | null
    baseFee: number | null
    distanceFee: number | null
    tip: number | null
    deductions: number | null
    totalEarned: number | null
    createdAt: Date | null
  }

  export type DeliveryEarningMaxAggregateOutputType = {
    id: string | null
    deliveryPersonId: string | null
    orderId: string | null
    baseFee: number | null
    distanceFee: number | null
    tip: number | null
    deductions: number | null
    totalEarned: number | null
    createdAt: Date | null
  }

  export type DeliveryEarningCountAggregateOutputType = {
    id: number
    deliveryPersonId: number
    orderId: number
    baseFee: number
    distanceFee: number
    tip: number
    deductions: number
    totalEarned: number
    createdAt: number
    _all: number
  }


  export type DeliveryEarningAvgAggregateInputType = {
    baseFee?: true
    distanceFee?: true
    tip?: true
    deductions?: true
    totalEarned?: true
  }

  export type DeliveryEarningSumAggregateInputType = {
    baseFee?: true
    distanceFee?: true
    tip?: true
    deductions?: true
    totalEarned?: true
  }

  export type DeliveryEarningMinAggregateInputType = {
    id?: true
    deliveryPersonId?: true
    orderId?: true
    baseFee?: true
    distanceFee?: true
    tip?: true
    deductions?: true
    totalEarned?: true
    createdAt?: true
  }

  export type DeliveryEarningMaxAggregateInputType = {
    id?: true
    deliveryPersonId?: true
    orderId?: true
    baseFee?: true
    distanceFee?: true
    tip?: true
    deductions?: true
    totalEarned?: true
    createdAt?: true
  }

  export type DeliveryEarningCountAggregateInputType = {
    id?: true
    deliveryPersonId?: true
    orderId?: true
    baseFee?: true
    distanceFee?: true
    tip?: true
    deductions?: true
    totalEarned?: true
    createdAt?: true
    _all?: true
  }

  export type DeliveryEarningAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryEarning to aggregate.
     */
    where?: DeliveryEarningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryEarnings to fetch.
     */
    orderBy?: DeliveryEarningOrderByWithRelationInput | DeliveryEarningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryEarningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryEarnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryEarnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryEarnings
    **/
    _count?: true | DeliveryEarningCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryEarningAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliveryEarningSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryEarningMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryEarningMaxAggregateInputType
  }

  export type GetDeliveryEarningAggregateType<T extends DeliveryEarningAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryEarning]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryEarning[P]>
      : GetScalarType<T[P], AggregateDeliveryEarning[P]>
  }




  export type DeliveryEarningGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryEarningWhereInput
    orderBy?: DeliveryEarningOrderByWithAggregationInput | DeliveryEarningOrderByWithAggregationInput[]
    by: DeliveryEarningScalarFieldEnum[] | DeliveryEarningScalarFieldEnum
    having?: DeliveryEarningScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryEarningCountAggregateInputType | true
    _avg?: DeliveryEarningAvgAggregateInputType
    _sum?: DeliveryEarningSumAggregateInputType
    _min?: DeliveryEarningMinAggregateInputType
    _max?: DeliveryEarningMaxAggregateInputType
  }

  export type DeliveryEarningGroupByOutputType = {
    id: string
    deliveryPersonId: string
    orderId: string
    baseFee: number
    distanceFee: number
    tip: number
    deductions: number
    totalEarned: number
    createdAt: Date
    _count: DeliveryEarningCountAggregateOutputType | null
    _avg: DeliveryEarningAvgAggregateOutputType | null
    _sum: DeliveryEarningSumAggregateOutputType | null
    _min: DeliveryEarningMinAggregateOutputType | null
    _max: DeliveryEarningMaxAggregateOutputType | null
  }

  type GetDeliveryEarningGroupByPayload<T extends DeliveryEarningGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryEarningGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryEarningGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryEarningGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryEarningGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryEarningSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deliveryPersonId?: boolean
    orderId?: boolean
    baseFee?: boolean
    distanceFee?: boolean
    tip?: boolean
    deductions?: boolean
    totalEarned?: boolean
    createdAt?: boolean
    deliveryPerson?: boolean | DeliveryPersonDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryEarning"]>

  export type DeliveryEarningSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deliveryPersonId?: boolean
    orderId?: boolean
    baseFee?: boolean
    distanceFee?: boolean
    tip?: boolean
    deductions?: boolean
    totalEarned?: boolean
    createdAt?: boolean
    deliveryPerson?: boolean | DeliveryPersonDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryEarning"]>

  export type DeliveryEarningSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deliveryPersonId?: boolean
    orderId?: boolean
    baseFee?: boolean
    distanceFee?: boolean
    tip?: boolean
    deductions?: boolean
    totalEarned?: boolean
    createdAt?: boolean
    deliveryPerson?: boolean | DeliveryPersonDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryEarning"]>

  export type DeliveryEarningSelectScalar = {
    id?: boolean
    deliveryPersonId?: boolean
    orderId?: boolean
    baseFee?: boolean
    distanceFee?: boolean
    tip?: boolean
    deductions?: boolean
    totalEarned?: boolean
    createdAt?: boolean
  }

  export type DeliveryEarningOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "deliveryPersonId" | "orderId" | "baseFee" | "distanceFee" | "tip" | "deductions" | "totalEarned" | "createdAt", ExtArgs["result"]["deliveryEarning"]>
  export type DeliveryEarningInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deliveryPerson?: boolean | DeliveryPersonDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type DeliveryEarningIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deliveryPerson?: boolean | DeliveryPersonDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type DeliveryEarningIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deliveryPerson?: boolean | DeliveryPersonDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $DeliveryEarningPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliveryEarning"
    objects: {
      deliveryPerson: Prisma.$DeliveryPersonPayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      deliveryPersonId: string
      orderId: string
      baseFee: number
      distanceFee: number
      tip: number
      deductions: number
      totalEarned: number
      createdAt: Date
    }, ExtArgs["result"]["deliveryEarning"]>
    composites: {}
  }

  type DeliveryEarningGetPayload<S extends boolean | null | undefined | DeliveryEarningDefaultArgs> = $Result.GetResult<Prisma.$DeliveryEarningPayload, S>

  type DeliveryEarningCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeliveryEarningFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeliveryEarningCountAggregateInputType | true
    }

  export interface DeliveryEarningDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryEarning'], meta: { name: 'DeliveryEarning' } }
    /**
     * Find zero or one DeliveryEarning that matches the filter.
     * @param {DeliveryEarningFindUniqueArgs} args - Arguments to find a DeliveryEarning
     * @example
     * // Get one DeliveryEarning
     * const deliveryEarning = await prisma.deliveryEarning.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryEarningFindUniqueArgs>(args: SelectSubset<T, DeliveryEarningFindUniqueArgs<ExtArgs>>): Prisma__DeliveryEarningClient<$Result.GetResult<Prisma.$DeliveryEarningPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeliveryEarning that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeliveryEarningFindUniqueOrThrowArgs} args - Arguments to find a DeliveryEarning
     * @example
     * // Get one DeliveryEarning
     * const deliveryEarning = await prisma.deliveryEarning.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryEarningFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryEarningFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryEarningClient<$Result.GetResult<Prisma.$DeliveryEarningPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryEarning that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryEarningFindFirstArgs} args - Arguments to find a DeliveryEarning
     * @example
     * // Get one DeliveryEarning
     * const deliveryEarning = await prisma.deliveryEarning.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryEarningFindFirstArgs>(args?: SelectSubset<T, DeliveryEarningFindFirstArgs<ExtArgs>>): Prisma__DeliveryEarningClient<$Result.GetResult<Prisma.$DeliveryEarningPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryEarning that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryEarningFindFirstOrThrowArgs} args - Arguments to find a DeliveryEarning
     * @example
     * // Get one DeliveryEarning
     * const deliveryEarning = await prisma.deliveryEarning.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryEarningFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryEarningFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryEarningClient<$Result.GetResult<Prisma.$DeliveryEarningPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeliveryEarnings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryEarningFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryEarnings
     * const deliveryEarnings = await prisma.deliveryEarning.findMany()
     * 
     * // Get first 10 DeliveryEarnings
     * const deliveryEarnings = await prisma.deliveryEarning.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryEarningWithIdOnly = await prisma.deliveryEarning.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryEarningFindManyArgs>(args?: SelectSubset<T, DeliveryEarningFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryEarningPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeliveryEarning.
     * @param {DeliveryEarningCreateArgs} args - Arguments to create a DeliveryEarning.
     * @example
     * // Create one DeliveryEarning
     * const DeliveryEarning = await prisma.deliveryEarning.create({
     *   data: {
     *     // ... data to create a DeliveryEarning
     *   }
     * })
     * 
     */
    create<T extends DeliveryEarningCreateArgs>(args: SelectSubset<T, DeliveryEarningCreateArgs<ExtArgs>>): Prisma__DeliveryEarningClient<$Result.GetResult<Prisma.$DeliveryEarningPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeliveryEarnings.
     * @param {DeliveryEarningCreateManyArgs} args - Arguments to create many DeliveryEarnings.
     * @example
     * // Create many DeliveryEarnings
     * const deliveryEarning = await prisma.deliveryEarning.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryEarningCreateManyArgs>(args?: SelectSubset<T, DeliveryEarningCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeliveryEarnings and returns the data saved in the database.
     * @param {DeliveryEarningCreateManyAndReturnArgs} args - Arguments to create many DeliveryEarnings.
     * @example
     * // Create many DeliveryEarnings
     * const deliveryEarning = await prisma.deliveryEarning.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeliveryEarnings and only return the `id`
     * const deliveryEarningWithIdOnly = await prisma.deliveryEarning.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryEarningCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryEarningCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryEarningPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeliveryEarning.
     * @param {DeliveryEarningDeleteArgs} args - Arguments to delete one DeliveryEarning.
     * @example
     * // Delete one DeliveryEarning
     * const DeliveryEarning = await prisma.deliveryEarning.delete({
     *   where: {
     *     // ... filter to delete one DeliveryEarning
     *   }
     * })
     * 
     */
    delete<T extends DeliveryEarningDeleteArgs>(args: SelectSubset<T, DeliveryEarningDeleteArgs<ExtArgs>>): Prisma__DeliveryEarningClient<$Result.GetResult<Prisma.$DeliveryEarningPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeliveryEarning.
     * @param {DeliveryEarningUpdateArgs} args - Arguments to update one DeliveryEarning.
     * @example
     * // Update one DeliveryEarning
     * const deliveryEarning = await prisma.deliveryEarning.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryEarningUpdateArgs>(args: SelectSubset<T, DeliveryEarningUpdateArgs<ExtArgs>>): Prisma__DeliveryEarningClient<$Result.GetResult<Prisma.$DeliveryEarningPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeliveryEarnings.
     * @param {DeliveryEarningDeleteManyArgs} args - Arguments to filter DeliveryEarnings to delete.
     * @example
     * // Delete a few DeliveryEarnings
     * const { count } = await prisma.deliveryEarning.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryEarningDeleteManyArgs>(args?: SelectSubset<T, DeliveryEarningDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryEarnings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryEarningUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryEarnings
     * const deliveryEarning = await prisma.deliveryEarning.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryEarningUpdateManyArgs>(args: SelectSubset<T, DeliveryEarningUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryEarnings and returns the data updated in the database.
     * @param {DeliveryEarningUpdateManyAndReturnArgs} args - Arguments to update many DeliveryEarnings.
     * @example
     * // Update many DeliveryEarnings
     * const deliveryEarning = await prisma.deliveryEarning.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeliveryEarnings and only return the `id`
     * const deliveryEarningWithIdOnly = await prisma.deliveryEarning.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeliveryEarningUpdateManyAndReturnArgs>(args: SelectSubset<T, DeliveryEarningUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryEarningPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeliveryEarning.
     * @param {DeliveryEarningUpsertArgs} args - Arguments to update or create a DeliveryEarning.
     * @example
     * // Update or create a DeliveryEarning
     * const deliveryEarning = await prisma.deliveryEarning.upsert({
     *   create: {
     *     // ... data to create a DeliveryEarning
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryEarning we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryEarningUpsertArgs>(args: SelectSubset<T, DeliveryEarningUpsertArgs<ExtArgs>>): Prisma__DeliveryEarningClient<$Result.GetResult<Prisma.$DeliveryEarningPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeliveryEarnings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryEarningCountArgs} args - Arguments to filter DeliveryEarnings to count.
     * @example
     * // Count the number of DeliveryEarnings
     * const count = await prisma.deliveryEarning.count({
     *   where: {
     *     // ... the filter for the DeliveryEarnings we want to count
     *   }
     * })
    **/
    count<T extends DeliveryEarningCountArgs>(
      args?: Subset<T, DeliveryEarningCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryEarningCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryEarning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryEarningAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryEarningAggregateArgs>(args: Subset<T, DeliveryEarningAggregateArgs>): Prisma.PrismaPromise<GetDeliveryEarningAggregateType<T>>

    /**
     * Group by DeliveryEarning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryEarningGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryEarningGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryEarningGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryEarningGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryEarningGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryEarningGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryEarning model
   */
  readonly fields: DeliveryEarningFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryEarning.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryEarningClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    deliveryPerson<T extends DeliveryPersonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryPersonDefaultArgs<ExtArgs>>): Prisma__DeliveryPersonClient<$Result.GetResult<Prisma.$DeliveryPersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliveryEarning model
   */
  interface DeliveryEarningFieldRefs {
    readonly id: FieldRef<"DeliveryEarning", 'String'>
    readonly deliveryPersonId: FieldRef<"DeliveryEarning", 'String'>
    readonly orderId: FieldRef<"DeliveryEarning", 'String'>
    readonly baseFee: FieldRef<"DeliveryEarning", 'Float'>
    readonly distanceFee: FieldRef<"DeliveryEarning", 'Float'>
    readonly tip: FieldRef<"DeliveryEarning", 'Float'>
    readonly deductions: FieldRef<"DeliveryEarning", 'Float'>
    readonly totalEarned: FieldRef<"DeliveryEarning", 'Float'>
    readonly createdAt: FieldRef<"DeliveryEarning", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeliveryEarning findUnique
   */
  export type DeliveryEarningFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEarning
     */
    select?: DeliveryEarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEarning
     */
    omit?: DeliveryEarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEarningInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryEarning to fetch.
     */
    where: DeliveryEarningWhereUniqueInput
  }

  /**
   * DeliveryEarning findUniqueOrThrow
   */
  export type DeliveryEarningFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEarning
     */
    select?: DeliveryEarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEarning
     */
    omit?: DeliveryEarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEarningInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryEarning to fetch.
     */
    where: DeliveryEarningWhereUniqueInput
  }

  /**
   * DeliveryEarning findFirst
   */
  export type DeliveryEarningFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEarning
     */
    select?: DeliveryEarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEarning
     */
    omit?: DeliveryEarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEarningInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryEarning to fetch.
     */
    where?: DeliveryEarningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryEarnings to fetch.
     */
    orderBy?: DeliveryEarningOrderByWithRelationInput | DeliveryEarningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryEarnings.
     */
    cursor?: DeliveryEarningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryEarnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryEarnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryEarnings.
     */
    distinct?: DeliveryEarningScalarFieldEnum | DeliveryEarningScalarFieldEnum[]
  }

  /**
   * DeliveryEarning findFirstOrThrow
   */
  export type DeliveryEarningFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEarning
     */
    select?: DeliveryEarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEarning
     */
    omit?: DeliveryEarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEarningInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryEarning to fetch.
     */
    where?: DeliveryEarningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryEarnings to fetch.
     */
    orderBy?: DeliveryEarningOrderByWithRelationInput | DeliveryEarningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryEarnings.
     */
    cursor?: DeliveryEarningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryEarnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryEarnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryEarnings.
     */
    distinct?: DeliveryEarningScalarFieldEnum | DeliveryEarningScalarFieldEnum[]
  }

  /**
   * DeliveryEarning findMany
   */
  export type DeliveryEarningFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEarning
     */
    select?: DeliveryEarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEarning
     */
    omit?: DeliveryEarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEarningInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryEarnings to fetch.
     */
    where?: DeliveryEarningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryEarnings to fetch.
     */
    orderBy?: DeliveryEarningOrderByWithRelationInput | DeliveryEarningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryEarnings.
     */
    cursor?: DeliveryEarningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryEarnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryEarnings.
     */
    skip?: number
    distinct?: DeliveryEarningScalarFieldEnum | DeliveryEarningScalarFieldEnum[]
  }

  /**
   * DeliveryEarning create
   */
  export type DeliveryEarningCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEarning
     */
    select?: DeliveryEarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEarning
     */
    omit?: DeliveryEarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEarningInclude<ExtArgs> | null
    /**
     * The data needed to create a DeliveryEarning.
     */
    data: XOR<DeliveryEarningCreateInput, DeliveryEarningUncheckedCreateInput>
  }

  /**
   * DeliveryEarning createMany
   */
  export type DeliveryEarningCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryEarnings.
     */
    data: DeliveryEarningCreateManyInput | DeliveryEarningCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryEarning createManyAndReturn
   */
  export type DeliveryEarningCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEarning
     */
    select?: DeliveryEarningSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEarning
     */
    omit?: DeliveryEarningOmit<ExtArgs> | null
    /**
     * The data used to create many DeliveryEarnings.
     */
    data: DeliveryEarningCreateManyInput | DeliveryEarningCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEarningIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryEarning update
   */
  export type DeliveryEarningUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEarning
     */
    select?: DeliveryEarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEarning
     */
    omit?: DeliveryEarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEarningInclude<ExtArgs> | null
    /**
     * The data needed to update a DeliveryEarning.
     */
    data: XOR<DeliveryEarningUpdateInput, DeliveryEarningUncheckedUpdateInput>
    /**
     * Choose, which DeliveryEarning to update.
     */
    where: DeliveryEarningWhereUniqueInput
  }

  /**
   * DeliveryEarning updateMany
   */
  export type DeliveryEarningUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryEarnings.
     */
    data: XOR<DeliveryEarningUpdateManyMutationInput, DeliveryEarningUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryEarnings to update
     */
    where?: DeliveryEarningWhereInput
    /**
     * Limit how many DeliveryEarnings to update.
     */
    limit?: number
  }

  /**
   * DeliveryEarning updateManyAndReturn
   */
  export type DeliveryEarningUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEarning
     */
    select?: DeliveryEarningSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEarning
     */
    omit?: DeliveryEarningOmit<ExtArgs> | null
    /**
     * The data used to update DeliveryEarnings.
     */
    data: XOR<DeliveryEarningUpdateManyMutationInput, DeliveryEarningUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryEarnings to update
     */
    where?: DeliveryEarningWhereInput
    /**
     * Limit how many DeliveryEarnings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEarningIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryEarning upsert
   */
  export type DeliveryEarningUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEarning
     */
    select?: DeliveryEarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEarning
     */
    omit?: DeliveryEarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEarningInclude<ExtArgs> | null
    /**
     * The filter to search for the DeliveryEarning to update in case it exists.
     */
    where: DeliveryEarningWhereUniqueInput
    /**
     * In case the DeliveryEarning found by the `where` argument doesn't exist, create a new DeliveryEarning with this data.
     */
    create: XOR<DeliveryEarningCreateInput, DeliveryEarningUncheckedCreateInput>
    /**
     * In case the DeliveryEarning was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryEarningUpdateInput, DeliveryEarningUncheckedUpdateInput>
  }

  /**
   * DeliveryEarning delete
   */
  export type DeliveryEarningDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEarning
     */
    select?: DeliveryEarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEarning
     */
    omit?: DeliveryEarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEarningInclude<ExtArgs> | null
    /**
     * Filter which DeliveryEarning to delete.
     */
    where: DeliveryEarningWhereUniqueInput
  }

  /**
   * DeliveryEarning deleteMany
   */
  export type DeliveryEarningDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryEarnings to delete
     */
    where?: DeliveryEarningWhereInput
    /**
     * Limit how many DeliveryEarnings to delete.
     */
    limit?: number
  }

  /**
   * DeliveryEarning without action
   */
  export type DeliveryEarningDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEarning
     */
    select?: DeliveryEarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEarning
     */
    omit?: DeliveryEarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEarningInclude<ExtArgs> | null
  }


  /**
   * Model DriverLocationLog
   */

  export type AggregateDriverLocationLog = {
    _count: DriverLocationLogCountAggregateOutputType | null
    _avg: DriverLocationLogAvgAggregateOutputType | null
    _sum: DriverLocationLogSumAggregateOutputType | null
    _min: DriverLocationLogMinAggregateOutputType | null
    _max: DriverLocationLogMaxAggregateOutputType | null
  }

  export type DriverLocationLogAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type DriverLocationLogSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type DriverLocationLogMinAggregateOutputType = {
    id: string | null
    driverId: string | null
    latitude: number | null
    longitude: number | null
    timestamp: Date | null
  }

  export type DriverLocationLogMaxAggregateOutputType = {
    id: string | null
    driverId: string | null
    latitude: number | null
    longitude: number | null
    timestamp: Date | null
  }

  export type DriverLocationLogCountAggregateOutputType = {
    id: number
    driverId: number
    latitude: number
    longitude: number
    timestamp: number
    _all: number
  }


  export type DriverLocationLogAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type DriverLocationLogSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type DriverLocationLogMinAggregateInputType = {
    id?: true
    driverId?: true
    latitude?: true
    longitude?: true
    timestamp?: true
  }

  export type DriverLocationLogMaxAggregateInputType = {
    id?: true
    driverId?: true
    latitude?: true
    longitude?: true
    timestamp?: true
  }

  export type DriverLocationLogCountAggregateInputType = {
    id?: true
    driverId?: true
    latitude?: true
    longitude?: true
    timestamp?: true
    _all?: true
  }

  export type DriverLocationLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DriverLocationLog to aggregate.
     */
    where?: DriverLocationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriverLocationLogs to fetch.
     */
    orderBy?: DriverLocationLogOrderByWithRelationInput | DriverLocationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DriverLocationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriverLocationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriverLocationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DriverLocationLogs
    **/
    _count?: true | DriverLocationLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DriverLocationLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DriverLocationLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DriverLocationLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DriverLocationLogMaxAggregateInputType
  }

  export type GetDriverLocationLogAggregateType<T extends DriverLocationLogAggregateArgs> = {
        [P in keyof T & keyof AggregateDriverLocationLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDriverLocationLog[P]>
      : GetScalarType<T[P], AggregateDriverLocationLog[P]>
  }




  export type DriverLocationLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriverLocationLogWhereInput
    orderBy?: DriverLocationLogOrderByWithAggregationInput | DriverLocationLogOrderByWithAggregationInput[]
    by: DriverLocationLogScalarFieldEnum[] | DriverLocationLogScalarFieldEnum
    having?: DriverLocationLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DriverLocationLogCountAggregateInputType | true
    _avg?: DriverLocationLogAvgAggregateInputType
    _sum?: DriverLocationLogSumAggregateInputType
    _min?: DriverLocationLogMinAggregateInputType
    _max?: DriverLocationLogMaxAggregateInputType
  }

  export type DriverLocationLogGroupByOutputType = {
    id: string
    driverId: string
    latitude: number
    longitude: number
    timestamp: Date
    _count: DriverLocationLogCountAggregateOutputType | null
    _avg: DriverLocationLogAvgAggregateOutputType | null
    _sum: DriverLocationLogSumAggregateOutputType | null
    _min: DriverLocationLogMinAggregateOutputType | null
    _max: DriverLocationLogMaxAggregateOutputType | null
  }

  type GetDriverLocationLogGroupByPayload<T extends DriverLocationLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DriverLocationLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DriverLocationLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DriverLocationLogGroupByOutputType[P]>
            : GetScalarType<T[P], DriverLocationLogGroupByOutputType[P]>
        }
      >
    >


  export type DriverLocationLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    driverId?: boolean
    latitude?: boolean
    longitude?: boolean
    timestamp?: boolean
    driver?: boolean | DeliveryPersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driverLocationLog"]>

  export type DriverLocationLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    driverId?: boolean
    latitude?: boolean
    longitude?: boolean
    timestamp?: boolean
    driver?: boolean | DeliveryPersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driverLocationLog"]>

  export type DriverLocationLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    driverId?: boolean
    latitude?: boolean
    longitude?: boolean
    timestamp?: boolean
    driver?: boolean | DeliveryPersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driverLocationLog"]>

  export type DriverLocationLogSelectScalar = {
    id?: boolean
    driverId?: boolean
    latitude?: boolean
    longitude?: boolean
    timestamp?: boolean
  }

  export type DriverLocationLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "driverId" | "latitude" | "longitude" | "timestamp", ExtArgs["result"]["driverLocationLog"]>
  export type DriverLocationLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    driver?: boolean | DeliveryPersonDefaultArgs<ExtArgs>
  }
  export type DriverLocationLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    driver?: boolean | DeliveryPersonDefaultArgs<ExtArgs>
  }
  export type DriverLocationLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    driver?: boolean | DeliveryPersonDefaultArgs<ExtArgs>
  }

  export type $DriverLocationLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DriverLocationLog"
    objects: {
      driver: Prisma.$DeliveryPersonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      driverId: string
      latitude: number
      longitude: number
      timestamp: Date
    }, ExtArgs["result"]["driverLocationLog"]>
    composites: {}
  }

  type DriverLocationLogGetPayload<S extends boolean | null | undefined | DriverLocationLogDefaultArgs> = $Result.GetResult<Prisma.$DriverLocationLogPayload, S>

  type DriverLocationLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DriverLocationLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DriverLocationLogCountAggregateInputType | true
    }

  export interface DriverLocationLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DriverLocationLog'], meta: { name: 'DriverLocationLog' } }
    /**
     * Find zero or one DriverLocationLog that matches the filter.
     * @param {DriverLocationLogFindUniqueArgs} args - Arguments to find a DriverLocationLog
     * @example
     * // Get one DriverLocationLog
     * const driverLocationLog = await prisma.driverLocationLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DriverLocationLogFindUniqueArgs>(args: SelectSubset<T, DriverLocationLogFindUniqueArgs<ExtArgs>>): Prisma__DriverLocationLogClient<$Result.GetResult<Prisma.$DriverLocationLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DriverLocationLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DriverLocationLogFindUniqueOrThrowArgs} args - Arguments to find a DriverLocationLog
     * @example
     * // Get one DriverLocationLog
     * const driverLocationLog = await prisma.driverLocationLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DriverLocationLogFindUniqueOrThrowArgs>(args: SelectSubset<T, DriverLocationLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DriverLocationLogClient<$Result.GetResult<Prisma.$DriverLocationLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DriverLocationLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverLocationLogFindFirstArgs} args - Arguments to find a DriverLocationLog
     * @example
     * // Get one DriverLocationLog
     * const driverLocationLog = await prisma.driverLocationLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DriverLocationLogFindFirstArgs>(args?: SelectSubset<T, DriverLocationLogFindFirstArgs<ExtArgs>>): Prisma__DriverLocationLogClient<$Result.GetResult<Prisma.$DriverLocationLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DriverLocationLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverLocationLogFindFirstOrThrowArgs} args - Arguments to find a DriverLocationLog
     * @example
     * // Get one DriverLocationLog
     * const driverLocationLog = await prisma.driverLocationLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DriverLocationLogFindFirstOrThrowArgs>(args?: SelectSubset<T, DriverLocationLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__DriverLocationLogClient<$Result.GetResult<Prisma.$DriverLocationLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DriverLocationLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverLocationLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DriverLocationLogs
     * const driverLocationLogs = await prisma.driverLocationLog.findMany()
     * 
     * // Get first 10 DriverLocationLogs
     * const driverLocationLogs = await prisma.driverLocationLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const driverLocationLogWithIdOnly = await prisma.driverLocationLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DriverLocationLogFindManyArgs>(args?: SelectSubset<T, DriverLocationLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverLocationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DriverLocationLog.
     * @param {DriverLocationLogCreateArgs} args - Arguments to create a DriverLocationLog.
     * @example
     * // Create one DriverLocationLog
     * const DriverLocationLog = await prisma.driverLocationLog.create({
     *   data: {
     *     // ... data to create a DriverLocationLog
     *   }
     * })
     * 
     */
    create<T extends DriverLocationLogCreateArgs>(args: SelectSubset<T, DriverLocationLogCreateArgs<ExtArgs>>): Prisma__DriverLocationLogClient<$Result.GetResult<Prisma.$DriverLocationLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DriverLocationLogs.
     * @param {DriverLocationLogCreateManyArgs} args - Arguments to create many DriverLocationLogs.
     * @example
     * // Create many DriverLocationLogs
     * const driverLocationLog = await prisma.driverLocationLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DriverLocationLogCreateManyArgs>(args?: SelectSubset<T, DriverLocationLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DriverLocationLogs and returns the data saved in the database.
     * @param {DriverLocationLogCreateManyAndReturnArgs} args - Arguments to create many DriverLocationLogs.
     * @example
     * // Create many DriverLocationLogs
     * const driverLocationLog = await prisma.driverLocationLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DriverLocationLogs and only return the `id`
     * const driverLocationLogWithIdOnly = await prisma.driverLocationLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DriverLocationLogCreateManyAndReturnArgs>(args?: SelectSubset<T, DriverLocationLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverLocationLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DriverLocationLog.
     * @param {DriverLocationLogDeleteArgs} args - Arguments to delete one DriverLocationLog.
     * @example
     * // Delete one DriverLocationLog
     * const DriverLocationLog = await prisma.driverLocationLog.delete({
     *   where: {
     *     // ... filter to delete one DriverLocationLog
     *   }
     * })
     * 
     */
    delete<T extends DriverLocationLogDeleteArgs>(args: SelectSubset<T, DriverLocationLogDeleteArgs<ExtArgs>>): Prisma__DriverLocationLogClient<$Result.GetResult<Prisma.$DriverLocationLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DriverLocationLog.
     * @param {DriverLocationLogUpdateArgs} args - Arguments to update one DriverLocationLog.
     * @example
     * // Update one DriverLocationLog
     * const driverLocationLog = await prisma.driverLocationLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DriverLocationLogUpdateArgs>(args: SelectSubset<T, DriverLocationLogUpdateArgs<ExtArgs>>): Prisma__DriverLocationLogClient<$Result.GetResult<Prisma.$DriverLocationLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DriverLocationLogs.
     * @param {DriverLocationLogDeleteManyArgs} args - Arguments to filter DriverLocationLogs to delete.
     * @example
     * // Delete a few DriverLocationLogs
     * const { count } = await prisma.driverLocationLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DriverLocationLogDeleteManyArgs>(args?: SelectSubset<T, DriverLocationLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DriverLocationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverLocationLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DriverLocationLogs
     * const driverLocationLog = await prisma.driverLocationLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DriverLocationLogUpdateManyArgs>(args: SelectSubset<T, DriverLocationLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DriverLocationLogs and returns the data updated in the database.
     * @param {DriverLocationLogUpdateManyAndReturnArgs} args - Arguments to update many DriverLocationLogs.
     * @example
     * // Update many DriverLocationLogs
     * const driverLocationLog = await prisma.driverLocationLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DriverLocationLogs and only return the `id`
     * const driverLocationLogWithIdOnly = await prisma.driverLocationLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DriverLocationLogUpdateManyAndReturnArgs>(args: SelectSubset<T, DriverLocationLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverLocationLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DriverLocationLog.
     * @param {DriverLocationLogUpsertArgs} args - Arguments to update or create a DriverLocationLog.
     * @example
     * // Update or create a DriverLocationLog
     * const driverLocationLog = await prisma.driverLocationLog.upsert({
     *   create: {
     *     // ... data to create a DriverLocationLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DriverLocationLog we want to update
     *   }
     * })
     */
    upsert<T extends DriverLocationLogUpsertArgs>(args: SelectSubset<T, DriverLocationLogUpsertArgs<ExtArgs>>): Prisma__DriverLocationLogClient<$Result.GetResult<Prisma.$DriverLocationLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DriverLocationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverLocationLogCountArgs} args - Arguments to filter DriverLocationLogs to count.
     * @example
     * // Count the number of DriverLocationLogs
     * const count = await prisma.driverLocationLog.count({
     *   where: {
     *     // ... the filter for the DriverLocationLogs we want to count
     *   }
     * })
    **/
    count<T extends DriverLocationLogCountArgs>(
      args?: Subset<T, DriverLocationLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DriverLocationLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DriverLocationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverLocationLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DriverLocationLogAggregateArgs>(args: Subset<T, DriverLocationLogAggregateArgs>): Prisma.PrismaPromise<GetDriverLocationLogAggregateType<T>>

    /**
     * Group by DriverLocationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverLocationLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DriverLocationLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DriverLocationLogGroupByArgs['orderBy'] }
        : { orderBy?: DriverLocationLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DriverLocationLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDriverLocationLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DriverLocationLog model
   */
  readonly fields: DriverLocationLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DriverLocationLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DriverLocationLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    driver<T extends DeliveryPersonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryPersonDefaultArgs<ExtArgs>>): Prisma__DeliveryPersonClient<$Result.GetResult<Prisma.$DeliveryPersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DriverLocationLog model
   */
  interface DriverLocationLogFieldRefs {
    readonly id: FieldRef<"DriverLocationLog", 'String'>
    readonly driverId: FieldRef<"DriverLocationLog", 'String'>
    readonly latitude: FieldRef<"DriverLocationLog", 'Float'>
    readonly longitude: FieldRef<"DriverLocationLog", 'Float'>
    readonly timestamp: FieldRef<"DriverLocationLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DriverLocationLog findUnique
   */
  export type DriverLocationLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverLocationLog
     */
    select?: DriverLocationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverLocationLog
     */
    omit?: DriverLocationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverLocationLogInclude<ExtArgs> | null
    /**
     * Filter, which DriverLocationLog to fetch.
     */
    where: DriverLocationLogWhereUniqueInput
  }

  /**
   * DriverLocationLog findUniqueOrThrow
   */
  export type DriverLocationLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverLocationLog
     */
    select?: DriverLocationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverLocationLog
     */
    omit?: DriverLocationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverLocationLogInclude<ExtArgs> | null
    /**
     * Filter, which DriverLocationLog to fetch.
     */
    where: DriverLocationLogWhereUniqueInput
  }

  /**
   * DriverLocationLog findFirst
   */
  export type DriverLocationLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverLocationLog
     */
    select?: DriverLocationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverLocationLog
     */
    omit?: DriverLocationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverLocationLogInclude<ExtArgs> | null
    /**
     * Filter, which DriverLocationLog to fetch.
     */
    where?: DriverLocationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriverLocationLogs to fetch.
     */
    orderBy?: DriverLocationLogOrderByWithRelationInput | DriverLocationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DriverLocationLogs.
     */
    cursor?: DriverLocationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriverLocationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriverLocationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DriverLocationLogs.
     */
    distinct?: DriverLocationLogScalarFieldEnum | DriverLocationLogScalarFieldEnum[]
  }

  /**
   * DriverLocationLog findFirstOrThrow
   */
  export type DriverLocationLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverLocationLog
     */
    select?: DriverLocationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverLocationLog
     */
    omit?: DriverLocationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverLocationLogInclude<ExtArgs> | null
    /**
     * Filter, which DriverLocationLog to fetch.
     */
    where?: DriverLocationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriverLocationLogs to fetch.
     */
    orderBy?: DriverLocationLogOrderByWithRelationInput | DriverLocationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DriverLocationLogs.
     */
    cursor?: DriverLocationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriverLocationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriverLocationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DriverLocationLogs.
     */
    distinct?: DriverLocationLogScalarFieldEnum | DriverLocationLogScalarFieldEnum[]
  }

  /**
   * DriverLocationLog findMany
   */
  export type DriverLocationLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverLocationLog
     */
    select?: DriverLocationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverLocationLog
     */
    omit?: DriverLocationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverLocationLogInclude<ExtArgs> | null
    /**
     * Filter, which DriverLocationLogs to fetch.
     */
    where?: DriverLocationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriverLocationLogs to fetch.
     */
    orderBy?: DriverLocationLogOrderByWithRelationInput | DriverLocationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DriverLocationLogs.
     */
    cursor?: DriverLocationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriverLocationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriverLocationLogs.
     */
    skip?: number
    distinct?: DriverLocationLogScalarFieldEnum | DriverLocationLogScalarFieldEnum[]
  }

  /**
   * DriverLocationLog create
   */
  export type DriverLocationLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverLocationLog
     */
    select?: DriverLocationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverLocationLog
     */
    omit?: DriverLocationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverLocationLogInclude<ExtArgs> | null
    /**
     * The data needed to create a DriverLocationLog.
     */
    data: XOR<DriverLocationLogCreateInput, DriverLocationLogUncheckedCreateInput>
  }

  /**
   * DriverLocationLog createMany
   */
  export type DriverLocationLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DriverLocationLogs.
     */
    data: DriverLocationLogCreateManyInput | DriverLocationLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DriverLocationLog createManyAndReturn
   */
  export type DriverLocationLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverLocationLog
     */
    select?: DriverLocationLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DriverLocationLog
     */
    omit?: DriverLocationLogOmit<ExtArgs> | null
    /**
     * The data used to create many DriverLocationLogs.
     */
    data: DriverLocationLogCreateManyInput | DriverLocationLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverLocationLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DriverLocationLog update
   */
  export type DriverLocationLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverLocationLog
     */
    select?: DriverLocationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverLocationLog
     */
    omit?: DriverLocationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverLocationLogInclude<ExtArgs> | null
    /**
     * The data needed to update a DriverLocationLog.
     */
    data: XOR<DriverLocationLogUpdateInput, DriverLocationLogUncheckedUpdateInput>
    /**
     * Choose, which DriverLocationLog to update.
     */
    where: DriverLocationLogWhereUniqueInput
  }

  /**
   * DriverLocationLog updateMany
   */
  export type DriverLocationLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DriverLocationLogs.
     */
    data: XOR<DriverLocationLogUpdateManyMutationInput, DriverLocationLogUncheckedUpdateManyInput>
    /**
     * Filter which DriverLocationLogs to update
     */
    where?: DriverLocationLogWhereInput
    /**
     * Limit how many DriverLocationLogs to update.
     */
    limit?: number
  }

  /**
   * DriverLocationLog updateManyAndReturn
   */
  export type DriverLocationLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverLocationLog
     */
    select?: DriverLocationLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DriverLocationLog
     */
    omit?: DriverLocationLogOmit<ExtArgs> | null
    /**
     * The data used to update DriverLocationLogs.
     */
    data: XOR<DriverLocationLogUpdateManyMutationInput, DriverLocationLogUncheckedUpdateManyInput>
    /**
     * Filter which DriverLocationLogs to update
     */
    where?: DriverLocationLogWhereInput
    /**
     * Limit how many DriverLocationLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverLocationLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DriverLocationLog upsert
   */
  export type DriverLocationLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverLocationLog
     */
    select?: DriverLocationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverLocationLog
     */
    omit?: DriverLocationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverLocationLogInclude<ExtArgs> | null
    /**
     * The filter to search for the DriverLocationLog to update in case it exists.
     */
    where: DriverLocationLogWhereUniqueInput
    /**
     * In case the DriverLocationLog found by the `where` argument doesn't exist, create a new DriverLocationLog with this data.
     */
    create: XOR<DriverLocationLogCreateInput, DriverLocationLogUncheckedCreateInput>
    /**
     * In case the DriverLocationLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DriverLocationLogUpdateInput, DriverLocationLogUncheckedUpdateInput>
  }

  /**
   * DriverLocationLog delete
   */
  export type DriverLocationLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverLocationLog
     */
    select?: DriverLocationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverLocationLog
     */
    omit?: DriverLocationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverLocationLogInclude<ExtArgs> | null
    /**
     * Filter which DriverLocationLog to delete.
     */
    where: DriverLocationLogWhereUniqueInput
  }

  /**
   * DriverLocationLog deleteMany
   */
  export type DriverLocationLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DriverLocationLogs to delete
     */
    where?: DriverLocationLogWhereInput
    /**
     * Limit how many DriverLocationLogs to delete.
     */
    limit?: number
  }

  /**
   * DriverLocationLog without action
   */
  export type DriverLocationLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverLocationLog
     */
    select?: DriverLocationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverLocationLog
     */
    omit?: DriverLocationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverLocationLogInclude<ExtArgs> | null
  }


  /**
   * Model Activity
   */

  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    vendorId: string | null
    customerId: string | null
    deliveryId: string | null
    type: $Enums.ActivityType | null
    title: string | null
    message: string | null
    createdAt: Date | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    vendorId: string | null
    customerId: string | null
    deliveryId: string | null
    type: $Enums.ActivityType | null
    title: string | null
    message: string | null
    createdAt: Date | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    orderId: number
    vendorId: number
    customerId: number
    deliveryId: number
    type: number
    title: number
    message: number
    meta: number
    createdAt: number
    _all: number
  }


  export type ActivityMinAggregateInputType = {
    id?: true
    orderId?: true
    vendorId?: true
    customerId?: true
    deliveryId?: true
    type?: true
    title?: true
    message?: true
    createdAt?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    orderId?: true
    vendorId?: true
    customerId?: true
    deliveryId?: true
    type?: true
    title?: true
    message?: true
    createdAt?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    orderId?: true
    vendorId?: true
    customerId?: true
    deliveryId?: true
    type?: true
    title?: true
    message?: true
    meta?: true
    createdAt?: true
    _all?: true
  }

  export type ActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activity to aggregate.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type ActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithAggregationInput | ActivityOrderByWithAggregationInput[]
    by: ActivityScalarFieldEnum[] | ActivityScalarFieldEnum
    having?: ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }

  export type ActivityGroupByOutputType = {
    id: string
    orderId: string | null
    vendorId: string | null
    customerId: string | null
    deliveryId: string | null
    type: $Enums.ActivityType
    title: string
    message: string
    meta: JsonValue | null
    createdAt: Date
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends ActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type ActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    vendorId?: boolean
    customerId?: boolean
    deliveryId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    meta?: boolean
    createdAt?: boolean
    order?: boolean | Activity$orderArgs<ExtArgs>
    vendor?: boolean | Activity$vendorArgs<ExtArgs>
    customer?: boolean | Activity$customerArgs<ExtArgs>
    delivery?: boolean | Activity$deliveryArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    vendorId?: boolean
    customerId?: boolean
    deliveryId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    meta?: boolean
    createdAt?: boolean
    order?: boolean | Activity$orderArgs<ExtArgs>
    vendor?: boolean | Activity$vendorArgs<ExtArgs>
    customer?: boolean | Activity$customerArgs<ExtArgs>
    delivery?: boolean | Activity$deliveryArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    vendorId?: boolean
    customerId?: boolean
    deliveryId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    meta?: boolean
    createdAt?: boolean
    order?: boolean | Activity$orderArgs<ExtArgs>
    vendor?: boolean | Activity$vendorArgs<ExtArgs>
    customer?: boolean | Activity$customerArgs<ExtArgs>
    delivery?: boolean | Activity$deliveryArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectScalar = {
    id?: boolean
    orderId?: boolean
    vendorId?: boolean
    customerId?: boolean
    deliveryId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    meta?: boolean
    createdAt?: boolean
  }

  export type ActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "vendorId" | "customerId" | "deliveryId" | "type" | "title" | "message" | "meta" | "createdAt", ExtArgs["result"]["activity"]>
  export type ActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | Activity$orderArgs<ExtArgs>
    vendor?: boolean | Activity$vendorArgs<ExtArgs>
    customer?: boolean | Activity$customerArgs<ExtArgs>
    delivery?: boolean | Activity$deliveryArgs<ExtArgs>
  }
  export type ActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | Activity$orderArgs<ExtArgs>
    vendor?: boolean | Activity$vendorArgs<ExtArgs>
    customer?: boolean | Activity$customerArgs<ExtArgs>
    delivery?: boolean | Activity$deliveryArgs<ExtArgs>
  }
  export type ActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | Activity$orderArgs<ExtArgs>
    vendor?: boolean | Activity$vendorArgs<ExtArgs>
    customer?: boolean | Activity$customerArgs<ExtArgs>
    delivery?: boolean | Activity$deliveryArgs<ExtArgs>
  }

  export type $ActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Activity"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs> | null
      vendor: Prisma.$UserPayload<ExtArgs> | null
      customer: Prisma.$UserPayload<ExtArgs> | null
      delivery: Prisma.$DeliveryPersonPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string | null
      vendorId: string | null
      customerId: string | null
      deliveryId: string | null
      type: $Enums.ActivityType
      title: string
      message: string
      meta: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["activity"]>
    composites: {}
  }

  type ActivityGetPayload<S extends boolean | null | undefined | ActivityDefaultArgs> = $Result.GetResult<Prisma.$ActivityPayload, S>

  type ActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityCountAggregateInputType | true
    }

  export interface ActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Activity'], meta: { name: 'Activity' } }
    /**
     * Find zero or one Activity that matches the filter.
     * @param {ActivityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityFindUniqueArgs>(args: SelectSubset<T, ActivityFindUniqueArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Activity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityFindUniqueOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityFindFirstArgs>(args?: SelectSubset<T, ActivityFindFirstArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityFindManyArgs>(args?: SelectSubset<T, ActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Activity.
     * @param {ActivityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
     */
    create<T extends ActivityCreateArgs>(args: SelectSubset<T, ActivityCreateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Activities.
     * @param {ActivityCreateManyArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityCreateManyArgs>(args?: SelectSubset<T, ActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Activities and returns the data saved in the database.
     * @param {ActivityCreateManyAndReturnArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Activity.
     * @param {ActivityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
     */
    delete<T extends ActivityDeleteArgs>(args: SelectSubset<T, ActivityDeleteArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Activity.
     * @param {ActivityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityUpdateArgs>(args: SelectSubset<T, ActivityUpdateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Activities.
     * @param {ActivityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityDeleteManyArgs>(args?: SelectSubset<T, ActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityUpdateManyArgs>(args: SelectSubset<T, ActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities and returns the data updated in the database.
     * @param {ActivityUpdateManyAndReturnArgs} args - Arguments to update many Activities.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Activity.
     * @param {ActivityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
     */
    upsert<T extends ActivityUpsertArgs>(args: SelectSubset<T, ActivityUpsertArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivityCountArgs>(
      args?: Subset<T, ActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): Prisma.PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityGroupByArgs['orderBy'] }
        : { orderBy?: ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Activity model
   */
  readonly fields: ActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends Activity$orderArgs<ExtArgs> = {}>(args?: Subset<T, Activity$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    vendor<T extends Activity$vendorArgs<ExtArgs> = {}>(args?: Subset<T, Activity$vendorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    customer<T extends Activity$customerArgs<ExtArgs> = {}>(args?: Subset<T, Activity$customerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    delivery<T extends Activity$deliveryArgs<ExtArgs> = {}>(args?: Subset<T, Activity$deliveryArgs<ExtArgs>>): Prisma__DeliveryPersonClient<$Result.GetResult<Prisma.$DeliveryPersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Activity model
   */
  interface ActivityFieldRefs {
    readonly id: FieldRef<"Activity", 'String'>
    readonly orderId: FieldRef<"Activity", 'String'>
    readonly vendorId: FieldRef<"Activity", 'String'>
    readonly customerId: FieldRef<"Activity", 'String'>
    readonly deliveryId: FieldRef<"Activity", 'String'>
    readonly type: FieldRef<"Activity", 'ActivityType'>
    readonly title: FieldRef<"Activity", 'String'>
    readonly message: FieldRef<"Activity", 'String'>
    readonly meta: FieldRef<"Activity", 'Json'>
    readonly createdAt: FieldRef<"Activity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Activity findUnique
   */
  export type ActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findUniqueOrThrow
   */
  export type ActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findFirst
   */
  export type ActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findFirstOrThrow
   */
  export type ActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findMany
   */
  export type ActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activities to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity create
   */
  export type ActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a Activity.
     */
    data: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
  }

  /**
   * Activity createMany
   */
  export type ActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Activity createManyAndReturn
   */
  export type ActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity update
   */
  export type ActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a Activity.
     */
    data: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    /**
     * Choose, which Activity to update.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity updateMany
   */
  export type ActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
  }

  /**
   * Activity updateManyAndReturn
   */
  export type ActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity upsert
   */
  export type ActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the Activity to update in case it exists.
     */
    where: ActivityWhereUniqueInput
    /**
     * In case the Activity found by the `where` argument doesn't exist, create a new Activity with this data.
     */
    create: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    /**
     * In case the Activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
  }

  /**
   * Activity delete
   */
  export type ActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter which Activity to delete.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity deleteMany
   */
  export type ActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activities to delete
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to delete.
     */
    limit?: number
  }

  /**
   * Activity.order
   */
  export type Activity$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * Activity.vendor
   */
  export type Activity$vendorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Activity.customer
   */
  export type Activity$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Activity.delivery
   */
  export type Activity$deliveryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPerson
     */
    select?: DeliveryPersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPerson
     */
    omit?: DeliveryPersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPersonInclude<ExtArgs> | null
    where?: DeliveryPersonWhereInput
  }

  /**
   * Activity without action
   */
  export type ActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
  }


  /**
   * Model DeliveryBroadcast
   */

  export type AggregateDeliveryBroadcast = {
    _count: DeliveryBroadcastCountAggregateOutputType | null
    _min: DeliveryBroadcastMinAggregateOutputType | null
    _max: DeliveryBroadcastMaxAggregateOutputType | null
  }

  export type DeliveryBroadcastMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    acceptedDriverId: string | null
    status: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeliveryBroadcastMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    acceptedDriverId: string | null
    status: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeliveryBroadcastCountAggregateOutputType = {
    id: number
    orderId: number
    driverIds: number
    acceptedDriverId: number
    status: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeliveryBroadcastMinAggregateInputType = {
    id?: true
    orderId?: true
    acceptedDriverId?: true
    status?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeliveryBroadcastMaxAggregateInputType = {
    id?: true
    orderId?: true
    acceptedDriverId?: true
    status?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeliveryBroadcastCountAggregateInputType = {
    id?: true
    orderId?: true
    driverIds?: true
    acceptedDriverId?: true
    status?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeliveryBroadcastAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryBroadcast to aggregate.
     */
    where?: DeliveryBroadcastWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryBroadcasts to fetch.
     */
    orderBy?: DeliveryBroadcastOrderByWithRelationInput | DeliveryBroadcastOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryBroadcastWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryBroadcasts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryBroadcasts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryBroadcasts
    **/
    _count?: true | DeliveryBroadcastCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryBroadcastMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryBroadcastMaxAggregateInputType
  }

  export type GetDeliveryBroadcastAggregateType<T extends DeliveryBroadcastAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryBroadcast]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryBroadcast[P]>
      : GetScalarType<T[P], AggregateDeliveryBroadcast[P]>
  }




  export type DeliveryBroadcastGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryBroadcastWhereInput
    orderBy?: DeliveryBroadcastOrderByWithAggregationInput | DeliveryBroadcastOrderByWithAggregationInput[]
    by: DeliveryBroadcastScalarFieldEnum[] | DeliveryBroadcastScalarFieldEnum
    having?: DeliveryBroadcastScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryBroadcastCountAggregateInputType | true
    _min?: DeliveryBroadcastMinAggregateInputType
    _max?: DeliveryBroadcastMaxAggregateInputType
  }

  export type DeliveryBroadcastGroupByOutputType = {
    id: string
    orderId: string
    driverIds: string[]
    acceptedDriverId: string | null
    status: string
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: DeliveryBroadcastCountAggregateOutputType | null
    _min: DeliveryBroadcastMinAggregateOutputType | null
    _max: DeliveryBroadcastMaxAggregateOutputType | null
  }

  type GetDeliveryBroadcastGroupByPayload<T extends DeliveryBroadcastGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryBroadcastGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryBroadcastGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryBroadcastGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryBroadcastGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryBroadcastSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    driverIds?: boolean
    acceptedDriverId?: boolean
    status?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryBroadcast"]>

  export type DeliveryBroadcastSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    driverIds?: boolean
    acceptedDriverId?: boolean
    status?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryBroadcast"]>

  export type DeliveryBroadcastSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    driverIds?: boolean
    acceptedDriverId?: boolean
    status?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryBroadcast"]>

  export type DeliveryBroadcastSelectScalar = {
    id?: boolean
    orderId?: boolean
    driverIds?: boolean
    acceptedDriverId?: boolean
    status?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DeliveryBroadcastOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "driverIds" | "acceptedDriverId" | "status" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["deliveryBroadcast"]>
  export type DeliveryBroadcastInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type DeliveryBroadcastIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type DeliveryBroadcastIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $DeliveryBroadcastPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliveryBroadcast"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      driverIds: string[]
      acceptedDriverId: string | null
      status: string
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deliveryBroadcast"]>
    composites: {}
  }

  type DeliveryBroadcastGetPayload<S extends boolean | null | undefined | DeliveryBroadcastDefaultArgs> = $Result.GetResult<Prisma.$DeliveryBroadcastPayload, S>

  type DeliveryBroadcastCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeliveryBroadcastFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeliveryBroadcastCountAggregateInputType | true
    }

  export interface DeliveryBroadcastDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryBroadcast'], meta: { name: 'DeliveryBroadcast' } }
    /**
     * Find zero or one DeliveryBroadcast that matches the filter.
     * @param {DeliveryBroadcastFindUniqueArgs} args - Arguments to find a DeliveryBroadcast
     * @example
     * // Get one DeliveryBroadcast
     * const deliveryBroadcast = await prisma.deliveryBroadcast.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryBroadcastFindUniqueArgs>(args: SelectSubset<T, DeliveryBroadcastFindUniqueArgs<ExtArgs>>): Prisma__DeliveryBroadcastClient<$Result.GetResult<Prisma.$DeliveryBroadcastPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeliveryBroadcast that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeliveryBroadcastFindUniqueOrThrowArgs} args - Arguments to find a DeliveryBroadcast
     * @example
     * // Get one DeliveryBroadcast
     * const deliveryBroadcast = await prisma.deliveryBroadcast.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryBroadcastFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryBroadcastFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryBroadcastClient<$Result.GetResult<Prisma.$DeliveryBroadcastPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryBroadcast that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryBroadcastFindFirstArgs} args - Arguments to find a DeliveryBroadcast
     * @example
     * // Get one DeliveryBroadcast
     * const deliveryBroadcast = await prisma.deliveryBroadcast.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryBroadcastFindFirstArgs>(args?: SelectSubset<T, DeliveryBroadcastFindFirstArgs<ExtArgs>>): Prisma__DeliveryBroadcastClient<$Result.GetResult<Prisma.$DeliveryBroadcastPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryBroadcast that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryBroadcastFindFirstOrThrowArgs} args - Arguments to find a DeliveryBroadcast
     * @example
     * // Get one DeliveryBroadcast
     * const deliveryBroadcast = await prisma.deliveryBroadcast.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryBroadcastFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryBroadcastFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryBroadcastClient<$Result.GetResult<Prisma.$DeliveryBroadcastPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeliveryBroadcasts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryBroadcastFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryBroadcasts
     * const deliveryBroadcasts = await prisma.deliveryBroadcast.findMany()
     * 
     * // Get first 10 DeliveryBroadcasts
     * const deliveryBroadcasts = await prisma.deliveryBroadcast.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryBroadcastWithIdOnly = await prisma.deliveryBroadcast.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryBroadcastFindManyArgs>(args?: SelectSubset<T, DeliveryBroadcastFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryBroadcastPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeliveryBroadcast.
     * @param {DeliveryBroadcastCreateArgs} args - Arguments to create a DeliveryBroadcast.
     * @example
     * // Create one DeliveryBroadcast
     * const DeliveryBroadcast = await prisma.deliveryBroadcast.create({
     *   data: {
     *     // ... data to create a DeliveryBroadcast
     *   }
     * })
     * 
     */
    create<T extends DeliveryBroadcastCreateArgs>(args: SelectSubset<T, DeliveryBroadcastCreateArgs<ExtArgs>>): Prisma__DeliveryBroadcastClient<$Result.GetResult<Prisma.$DeliveryBroadcastPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeliveryBroadcasts.
     * @param {DeliveryBroadcastCreateManyArgs} args - Arguments to create many DeliveryBroadcasts.
     * @example
     * // Create many DeliveryBroadcasts
     * const deliveryBroadcast = await prisma.deliveryBroadcast.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryBroadcastCreateManyArgs>(args?: SelectSubset<T, DeliveryBroadcastCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeliveryBroadcasts and returns the data saved in the database.
     * @param {DeliveryBroadcastCreateManyAndReturnArgs} args - Arguments to create many DeliveryBroadcasts.
     * @example
     * // Create many DeliveryBroadcasts
     * const deliveryBroadcast = await prisma.deliveryBroadcast.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeliveryBroadcasts and only return the `id`
     * const deliveryBroadcastWithIdOnly = await prisma.deliveryBroadcast.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryBroadcastCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryBroadcastCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryBroadcastPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeliveryBroadcast.
     * @param {DeliveryBroadcastDeleteArgs} args - Arguments to delete one DeliveryBroadcast.
     * @example
     * // Delete one DeliveryBroadcast
     * const DeliveryBroadcast = await prisma.deliveryBroadcast.delete({
     *   where: {
     *     // ... filter to delete one DeliveryBroadcast
     *   }
     * })
     * 
     */
    delete<T extends DeliveryBroadcastDeleteArgs>(args: SelectSubset<T, DeliveryBroadcastDeleteArgs<ExtArgs>>): Prisma__DeliveryBroadcastClient<$Result.GetResult<Prisma.$DeliveryBroadcastPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeliveryBroadcast.
     * @param {DeliveryBroadcastUpdateArgs} args - Arguments to update one DeliveryBroadcast.
     * @example
     * // Update one DeliveryBroadcast
     * const deliveryBroadcast = await prisma.deliveryBroadcast.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryBroadcastUpdateArgs>(args: SelectSubset<T, DeliveryBroadcastUpdateArgs<ExtArgs>>): Prisma__DeliveryBroadcastClient<$Result.GetResult<Prisma.$DeliveryBroadcastPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeliveryBroadcasts.
     * @param {DeliveryBroadcastDeleteManyArgs} args - Arguments to filter DeliveryBroadcasts to delete.
     * @example
     * // Delete a few DeliveryBroadcasts
     * const { count } = await prisma.deliveryBroadcast.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryBroadcastDeleteManyArgs>(args?: SelectSubset<T, DeliveryBroadcastDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryBroadcasts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryBroadcastUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryBroadcasts
     * const deliveryBroadcast = await prisma.deliveryBroadcast.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryBroadcastUpdateManyArgs>(args: SelectSubset<T, DeliveryBroadcastUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryBroadcasts and returns the data updated in the database.
     * @param {DeliveryBroadcastUpdateManyAndReturnArgs} args - Arguments to update many DeliveryBroadcasts.
     * @example
     * // Update many DeliveryBroadcasts
     * const deliveryBroadcast = await prisma.deliveryBroadcast.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeliveryBroadcasts and only return the `id`
     * const deliveryBroadcastWithIdOnly = await prisma.deliveryBroadcast.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeliveryBroadcastUpdateManyAndReturnArgs>(args: SelectSubset<T, DeliveryBroadcastUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryBroadcastPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeliveryBroadcast.
     * @param {DeliveryBroadcastUpsertArgs} args - Arguments to update or create a DeliveryBroadcast.
     * @example
     * // Update or create a DeliveryBroadcast
     * const deliveryBroadcast = await prisma.deliveryBroadcast.upsert({
     *   create: {
     *     // ... data to create a DeliveryBroadcast
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryBroadcast we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryBroadcastUpsertArgs>(args: SelectSubset<T, DeliveryBroadcastUpsertArgs<ExtArgs>>): Prisma__DeliveryBroadcastClient<$Result.GetResult<Prisma.$DeliveryBroadcastPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeliveryBroadcasts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryBroadcastCountArgs} args - Arguments to filter DeliveryBroadcasts to count.
     * @example
     * // Count the number of DeliveryBroadcasts
     * const count = await prisma.deliveryBroadcast.count({
     *   where: {
     *     // ... the filter for the DeliveryBroadcasts we want to count
     *   }
     * })
    **/
    count<T extends DeliveryBroadcastCountArgs>(
      args?: Subset<T, DeliveryBroadcastCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryBroadcastCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryBroadcast.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryBroadcastAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryBroadcastAggregateArgs>(args: Subset<T, DeliveryBroadcastAggregateArgs>): Prisma.PrismaPromise<GetDeliveryBroadcastAggregateType<T>>

    /**
     * Group by DeliveryBroadcast.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryBroadcastGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryBroadcastGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryBroadcastGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryBroadcastGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryBroadcastGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryBroadcastGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryBroadcast model
   */
  readonly fields: DeliveryBroadcastFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryBroadcast.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryBroadcastClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliveryBroadcast model
   */
  interface DeliveryBroadcastFieldRefs {
    readonly id: FieldRef<"DeliveryBroadcast", 'String'>
    readonly orderId: FieldRef<"DeliveryBroadcast", 'String'>
    readonly driverIds: FieldRef<"DeliveryBroadcast", 'String[]'>
    readonly acceptedDriverId: FieldRef<"DeliveryBroadcast", 'String'>
    readonly status: FieldRef<"DeliveryBroadcast", 'String'>
    readonly expiresAt: FieldRef<"DeliveryBroadcast", 'DateTime'>
    readonly createdAt: FieldRef<"DeliveryBroadcast", 'DateTime'>
    readonly updatedAt: FieldRef<"DeliveryBroadcast", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeliveryBroadcast findUnique
   */
  export type DeliveryBroadcastFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBroadcast
     */
    select?: DeliveryBroadcastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryBroadcast
     */
    omit?: DeliveryBroadcastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryBroadcastInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryBroadcast to fetch.
     */
    where: DeliveryBroadcastWhereUniqueInput
  }

  /**
   * DeliveryBroadcast findUniqueOrThrow
   */
  export type DeliveryBroadcastFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBroadcast
     */
    select?: DeliveryBroadcastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryBroadcast
     */
    omit?: DeliveryBroadcastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryBroadcastInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryBroadcast to fetch.
     */
    where: DeliveryBroadcastWhereUniqueInput
  }

  /**
   * DeliveryBroadcast findFirst
   */
  export type DeliveryBroadcastFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBroadcast
     */
    select?: DeliveryBroadcastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryBroadcast
     */
    omit?: DeliveryBroadcastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryBroadcastInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryBroadcast to fetch.
     */
    where?: DeliveryBroadcastWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryBroadcasts to fetch.
     */
    orderBy?: DeliveryBroadcastOrderByWithRelationInput | DeliveryBroadcastOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryBroadcasts.
     */
    cursor?: DeliveryBroadcastWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryBroadcasts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryBroadcasts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryBroadcasts.
     */
    distinct?: DeliveryBroadcastScalarFieldEnum | DeliveryBroadcastScalarFieldEnum[]
  }

  /**
   * DeliveryBroadcast findFirstOrThrow
   */
  export type DeliveryBroadcastFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBroadcast
     */
    select?: DeliveryBroadcastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryBroadcast
     */
    omit?: DeliveryBroadcastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryBroadcastInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryBroadcast to fetch.
     */
    where?: DeliveryBroadcastWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryBroadcasts to fetch.
     */
    orderBy?: DeliveryBroadcastOrderByWithRelationInput | DeliveryBroadcastOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryBroadcasts.
     */
    cursor?: DeliveryBroadcastWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryBroadcasts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryBroadcasts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryBroadcasts.
     */
    distinct?: DeliveryBroadcastScalarFieldEnum | DeliveryBroadcastScalarFieldEnum[]
  }

  /**
   * DeliveryBroadcast findMany
   */
  export type DeliveryBroadcastFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBroadcast
     */
    select?: DeliveryBroadcastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryBroadcast
     */
    omit?: DeliveryBroadcastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryBroadcastInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryBroadcasts to fetch.
     */
    where?: DeliveryBroadcastWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryBroadcasts to fetch.
     */
    orderBy?: DeliveryBroadcastOrderByWithRelationInput | DeliveryBroadcastOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryBroadcasts.
     */
    cursor?: DeliveryBroadcastWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryBroadcasts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryBroadcasts.
     */
    skip?: number
    distinct?: DeliveryBroadcastScalarFieldEnum | DeliveryBroadcastScalarFieldEnum[]
  }

  /**
   * DeliveryBroadcast create
   */
  export type DeliveryBroadcastCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBroadcast
     */
    select?: DeliveryBroadcastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryBroadcast
     */
    omit?: DeliveryBroadcastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryBroadcastInclude<ExtArgs> | null
    /**
     * The data needed to create a DeliveryBroadcast.
     */
    data: XOR<DeliveryBroadcastCreateInput, DeliveryBroadcastUncheckedCreateInput>
  }

  /**
   * DeliveryBroadcast createMany
   */
  export type DeliveryBroadcastCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryBroadcasts.
     */
    data: DeliveryBroadcastCreateManyInput | DeliveryBroadcastCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryBroadcast createManyAndReturn
   */
  export type DeliveryBroadcastCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBroadcast
     */
    select?: DeliveryBroadcastSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryBroadcast
     */
    omit?: DeliveryBroadcastOmit<ExtArgs> | null
    /**
     * The data used to create many DeliveryBroadcasts.
     */
    data: DeliveryBroadcastCreateManyInput | DeliveryBroadcastCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryBroadcastIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryBroadcast update
   */
  export type DeliveryBroadcastUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBroadcast
     */
    select?: DeliveryBroadcastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryBroadcast
     */
    omit?: DeliveryBroadcastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryBroadcastInclude<ExtArgs> | null
    /**
     * The data needed to update a DeliveryBroadcast.
     */
    data: XOR<DeliveryBroadcastUpdateInput, DeliveryBroadcastUncheckedUpdateInput>
    /**
     * Choose, which DeliveryBroadcast to update.
     */
    where: DeliveryBroadcastWhereUniqueInput
  }

  /**
   * DeliveryBroadcast updateMany
   */
  export type DeliveryBroadcastUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryBroadcasts.
     */
    data: XOR<DeliveryBroadcastUpdateManyMutationInput, DeliveryBroadcastUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryBroadcasts to update
     */
    where?: DeliveryBroadcastWhereInput
    /**
     * Limit how many DeliveryBroadcasts to update.
     */
    limit?: number
  }

  /**
   * DeliveryBroadcast updateManyAndReturn
   */
  export type DeliveryBroadcastUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBroadcast
     */
    select?: DeliveryBroadcastSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryBroadcast
     */
    omit?: DeliveryBroadcastOmit<ExtArgs> | null
    /**
     * The data used to update DeliveryBroadcasts.
     */
    data: XOR<DeliveryBroadcastUpdateManyMutationInput, DeliveryBroadcastUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryBroadcasts to update
     */
    where?: DeliveryBroadcastWhereInput
    /**
     * Limit how many DeliveryBroadcasts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryBroadcastIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryBroadcast upsert
   */
  export type DeliveryBroadcastUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBroadcast
     */
    select?: DeliveryBroadcastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryBroadcast
     */
    omit?: DeliveryBroadcastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryBroadcastInclude<ExtArgs> | null
    /**
     * The filter to search for the DeliveryBroadcast to update in case it exists.
     */
    where: DeliveryBroadcastWhereUniqueInput
    /**
     * In case the DeliveryBroadcast found by the `where` argument doesn't exist, create a new DeliveryBroadcast with this data.
     */
    create: XOR<DeliveryBroadcastCreateInput, DeliveryBroadcastUncheckedCreateInput>
    /**
     * In case the DeliveryBroadcast was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryBroadcastUpdateInput, DeliveryBroadcastUncheckedUpdateInput>
  }

  /**
   * DeliveryBroadcast delete
   */
  export type DeliveryBroadcastDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBroadcast
     */
    select?: DeliveryBroadcastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryBroadcast
     */
    omit?: DeliveryBroadcastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryBroadcastInclude<ExtArgs> | null
    /**
     * Filter which DeliveryBroadcast to delete.
     */
    where: DeliveryBroadcastWhereUniqueInput
  }

  /**
   * DeliveryBroadcast deleteMany
   */
  export type DeliveryBroadcastDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryBroadcasts to delete
     */
    where?: DeliveryBroadcastWhereInput
    /**
     * Limit how many DeliveryBroadcasts to delete.
     */
    limit?: number
  }

  /**
   * DeliveryBroadcast without action
   */
  export type DeliveryBroadcastDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBroadcast
     */
    select?: DeliveryBroadcastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryBroadcast
     */
    omit?: DeliveryBroadcastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryBroadcastInclude<ExtArgs> | null
  }


  /**
   * Model WebhookEvent
   */

  export type AggregateWebhookEvent = {
    _count: WebhookEventCountAggregateOutputType | null
    _min: WebhookEventMinAggregateOutputType | null
    _max: WebhookEventMaxAggregateOutputType | null
  }

  export type WebhookEventMinAggregateOutputType = {
    id: string | null
    reference: string | null
    event: string | null
    status: string | null
    createdAt: Date | null
    processedAt: Date | null
  }

  export type WebhookEventMaxAggregateOutputType = {
    id: string | null
    reference: string | null
    event: string | null
    status: string | null
    createdAt: Date | null
    processedAt: Date | null
  }

  export type WebhookEventCountAggregateOutputType = {
    id: number
    reference: number
    event: number
    payload: number
    status: number
    createdAt: number
    processedAt: number
    _all: number
  }


  export type WebhookEventMinAggregateInputType = {
    id?: true
    reference?: true
    event?: true
    status?: true
    createdAt?: true
    processedAt?: true
  }

  export type WebhookEventMaxAggregateInputType = {
    id?: true
    reference?: true
    event?: true
    status?: true
    createdAt?: true
    processedAt?: true
  }

  export type WebhookEventCountAggregateInputType = {
    id?: true
    reference?: true
    event?: true
    payload?: true
    status?: true
    createdAt?: true
    processedAt?: true
    _all?: true
  }

  export type WebhookEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookEvent to aggregate.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebhookEvents
    **/
    _count?: true | WebhookEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookEventMaxAggregateInputType
  }

  export type GetWebhookEventAggregateType<T extends WebhookEventAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhookEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhookEvent[P]>
      : GetScalarType<T[P], AggregateWebhookEvent[P]>
  }




  export type WebhookEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookEventWhereInput
    orderBy?: WebhookEventOrderByWithAggregationInput | WebhookEventOrderByWithAggregationInput[]
    by: WebhookEventScalarFieldEnum[] | WebhookEventScalarFieldEnum
    having?: WebhookEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookEventCountAggregateInputType | true
    _min?: WebhookEventMinAggregateInputType
    _max?: WebhookEventMaxAggregateInputType
  }

  export type WebhookEventGroupByOutputType = {
    id: string
    reference: string
    event: string
    payload: JsonValue
    status: string
    createdAt: Date
    processedAt: Date | null
    _count: WebhookEventCountAggregateOutputType | null
    _min: WebhookEventMinAggregateOutputType | null
    _max: WebhookEventMaxAggregateOutputType | null
  }

  type GetWebhookEventGroupByPayload<T extends WebhookEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookEventGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookEventGroupByOutputType[P]>
        }
      >
    >


  export type WebhookEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reference?: boolean
    event?: boolean
    payload?: boolean
    status?: boolean
    createdAt?: boolean
    processedAt?: boolean
  }, ExtArgs["result"]["webhookEvent"]>

  export type WebhookEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reference?: boolean
    event?: boolean
    payload?: boolean
    status?: boolean
    createdAt?: boolean
    processedAt?: boolean
  }, ExtArgs["result"]["webhookEvent"]>

  export type WebhookEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reference?: boolean
    event?: boolean
    payload?: boolean
    status?: boolean
    createdAt?: boolean
    processedAt?: boolean
  }, ExtArgs["result"]["webhookEvent"]>

  export type WebhookEventSelectScalar = {
    id?: boolean
    reference?: boolean
    event?: boolean
    payload?: boolean
    status?: boolean
    createdAt?: boolean
    processedAt?: boolean
  }

  export type WebhookEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reference" | "event" | "payload" | "status" | "createdAt" | "processedAt", ExtArgs["result"]["webhookEvent"]>

  export type $WebhookEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebhookEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reference: string
      event: string
      payload: Prisma.JsonValue
      status: string
      createdAt: Date
      processedAt: Date | null
    }, ExtArgs["result"]["webhookEvent"]>
    composites: {}
  }

  type WebhookEventGetPayload<S extends boolean | null | undefined | WebhookEventDefaultArgs> = $Result.GetResult<Prisma.$WebhookEventPayload, S>

  type WebhookEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WebhookEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WebhookEventCountAggregateInputType | true
    }

  export interface WebhookEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebhookEvent'], meta: { name: 'WebhookEvent' } }
    /**
     * Find zero or one WebhookEvent that matches the filter.
     * @param {WebhookEventFindUniqueArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookEventFindUniqueArgs>(args: SelectSubset<T, WebhookEventFindUniqueArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WebhookEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebhookEventFindUniqueOrThrowArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookEventFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebhookEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventFindFirstArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookEventFindFirstArgs>(args?: SelectSubset<T, WebhookEventFindFirstArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebhookEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventFindFirstOrThrowArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookEventFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WebhookEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebhookEvents
     * const webhookEvents = await prisma.webhookEvent.findMany()
     * 
     * // Get first 10 WebhookEvents
     * const webhookEvents = await prisma.webhookEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookEventWithIdOnly = await prisma.webhookEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookEventFindManyArgs>(args?: SelectSubset<T, WebhookEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WebhookEvent.
     * @param {WebhookEventCreateArgs} args - Arguments to create a WebhookEvent.
     * @example
     * // Create one WebhookEvent
     * const WebhookEvent = await prisma.webhookEvent.create({
     *   data: {
     *     // ... data to create a WebhookEvent
     *   }
     * })
     * 
     */
    create<T extends WebhookEventCreateArgs>(args: SelectSubset<T, WebhookEventCreateArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WebhookEvents.
     * @param {WebhookEventCreateManyArgs} args - Arguments to create many WebhookEvents.
     * @example
     * // Create many WebhookEvents
     * const webhookEvent = await prisma.webhookEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookEventCreateManyArgs>(args?: SelectSubset<T, WebhookEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebhookEvents and returns the data saved in the database.
     * @param {WebhookEventCreateManyAndReturnArgs} args - Arguments to create many WebhookEvents.
     * @example
     * // Create many WebhookEvents
     * const webhookEvent = await prisma.webhookEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebhookEvents and only return the `id`
     * const webhookEventWithIdOnly = await prisma.webhookEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookEventCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WebhookEvent.
     * @param {WebhookEventDeleteArgs} args - Arguments to delete one WebhookEvent.
     * @example
     * // Delete one WebhookEvent
     * const WebhookEvent = await prisma.webhookEvent.delete({
     *   where: {
     *     // ... filter to delete one WebhookEvent
     *   }
     * })
     * 
     */
    delete<T extends WebhookEventDeleteArgs>(args: SelectSubset<T, WebhookEventDeleteArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WebhookEvent.
     * @param {WebhookEventUpdateArgs} args - Arguments to update one WebhookEvent.
     * @example
     * // Update one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookEventUpdateArgs>(args: SelectSubset<T, WebhookEventUpdateArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WebhookEvents.
     * @param {WebhookEventDeleteManyArgs} args - Arguments to filter WebhookEvents to delete.
     * @example
     * // Delete a few WebhookEvents
     * const { count } = await prisma.webhookEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookEventDeleteManyArgs>(args?: SelectSubset<T, WebhookEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebhookEvents
     * const webhookEvent = await prisma.webhookEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookEventUpdateManyArgs>(args: SelectSubset<T, WebhookEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookEvents and returns the data updated in the database.
     * @param {WebhookEventUpdateManyAndReturnArgs} args - Arguments to update many WebhookEvents.
     * @example
     * // Update many WebhookEvents
     * const webhookEvent = await prisma.webhookEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WebhookEvents and only return the `id`
     * const webhookEventWithIdOnly = await prisma.webhookEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WebhookEventUpdateManyAndReturnArgs>(args: SelectSubset<T, WebhookEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WebhookEvent.
     * @param {WebhookEventUpsertArgs} args - Arguments to update or create a WebhookEvent.
     * @example
     * // Update or create a WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.upsert({
     *   create: {
     *     // ... data to create a WebhookEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebhookEvent we want to update
     *   }
     * })
     */
    upsert<T extends WebhookEventUpsertArgs>(args: SelectSubset<T, WebhookEventUpsertArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WebhookEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventCountArgs} args - Arguments to filter WebhookEvents to count.
     * @example
     * // Count the number of WebhookEvents
     * const count = await prisma.webhookEvent.count({
     *   where: {
     *     // ... the filter for the WebhookEvents we want to count
     *   }
     * })
    **/
    count<T extends WebhookEventCountArgs>(
      args?: Subset<T, WebhookEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebhookEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookEventAggregateArgs>(args: Subset<T, WebhookEventAggregateArgs>): Prisma.PrismaPromise<GetWebhookEventAggregateType<T>>

    /**
     * Group by WebhookEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookEventGroupByArgs['orderBy'] }
        : { orderBy?: WebhookEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebhookEvent model
   */
  readonly fields: WebhookEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebhookEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebhookEvent model
   */
  interface WebhookEventFieldRefs {
    readonly id: FieldRef<"WebhookEvent", 'String'>
    readonly reference: FieldRef<"WebhookEvent", 'String'>
    readonly event: FieldRef<"WebhookEvent", 'String'>
    readonly payload: FieldRef<"WebhookEvent", 'Json'>
    readonly status: FieldRef<"WebhookEvent", 'String'>
    readonly createdAt: FieldRef<"WebhookEvent", 'DateTime'>
    readonly processedAt: FieldRef<"WebhookEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WebhookEvent findUnique
   */
  export type WebhookEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent findUniqueOrThrow
   */
  export type WebhookEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent findFirst
   */
  export type WebhookEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookEvents.
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookEvents.
     */
    distinct?: WebhookEventScalarFieldEnum | WebhookEventScalarFieldEnum[]
  }

  /**
   * WebhookEvent findFirstOrThrow
   */
  export type WebhookEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookEvents.
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookEvents.
     */
    distinct?: WebhookEventScalarFieldEnum | WebhookEventScalarFieldEnum[]
  }

  /**
   * WebhookEvent findMany
   */
  export type WebhookEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * Filter, which WebhookEvents to fetch.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebhookEvents.
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    distinct?: WebhookEventScalarFieldEnum | WebhookEventScalarFieldEnum[]
  }

  /**
   * WebhookEvent create
   */
  export type WebhookEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * The data needed to create a WebhookEvent.
     */
    data: XOR<WebhookEventCreateInput, WebhookEventUncheckedCreateInput>
  }

  /**
   * WebhookEvent createMany
   */
  export type WebhookEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebhookEvents.
     */
    data: WebhookEventCreateManyInput | WebhookEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookEvent createManyAndReturn
   */
  export type WebhookEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * The data used to create many WebhookEvents.
     */
    data: WebhookEventCreateManyInput | WebhookEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookEvent update
   */
  export type WebhookEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * The data needed to update a WebhookEvent.
     */
    data: XOR<WebhookEventUpdateInput, WebhookEventUncheckedUpdateInput>
    /**
     * Choose, which WebhookEvent to update.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent updateMany
   */
  export type WebhookEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebhookEvents.
     */
    data: XOR<WebhookEventUpdateManyMutationInput, WebhookEventUncheckedUpdateManyInput>
    /**
     * Filter which WebhookEvents to update
     */
    where?: WebhookEventWhereInput
    /**
     * Limit how many WebhookEvents to update.
     */
    limit?: number
  }

  /**
   * WebhookEvent updateManyAndReturn
   */
  export type WebhookEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * The data used to update WebhookEvents.
     */
    data: XOR<WebhookEventUpdateManyMutationInput, WebhookEventUncheckedUpdateManyInput>
    /**
     * Filter which WebhookEvents to update
     */
    where?: WebhookEventWhereInput
    /**
     * Limit how many WebhookEvents to update.
     */
    limit?: number
  }

  /**
   * WebhookEvent upsert
   */
  export type WebhookEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * The filter to search for the WebhookEvent to update in case it exists.
     */
    where: WebhookEventWhereUniqueInput
    /**
     * In case the WebhookEvent found by the `where` argument doesn't exist, create a new WebhookEvent with this data.
     */
    create: XOR<WebhookEventCreateInput, WebhookEventUncheckedCreateInput>
    /**
     * In case the WebhookEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookEventUpdateInput, WebhookEventUncheckedUpdateInput>
  }

  /**
   * WebhookEvent delete
   */
  export type WebhookEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
    /**
     * Filter which WebhookEvent to delete.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent deleteMany
   */
  export type WebhookEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookEvents to delete
     */
    where?: WebhookEventWhereInput
    /**
     * Limit how many WebhookEvents to delete.
     */
    limit?: number
  }

  /**
   * WebhookEvent without action
   */
  export type WebhookEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookEvent
     */
    omit?: WebhookEventOmit<ExtArgs> | null
  }


  /**
   * Model Receipt
   */

  export type AggregateReceipt = {
    _count: ReceiptCountAggregateOutputType | null
    _min: ReceiptMinAggregateOutputType | null
    _max: ReceiptMaxAggregateOutputType | null
  }

  export type ReceiptMinAggregateOutputType = {
    id: string | null
    paymentId: string | null
    pdfUrl: string | null
    createdAt: Date | null
  }

  export type ReceiptMaxAggregateOutputType = {
    id: string | null
    paymentId: string | null
    pdfUrl: string | null
    createdAt: Date | null
  }

  export type ReceiptCountAggregateOutputType = {
    id: number
    paymentId: number
    pdfUrl: number
    createdAt: number
    _all: number
  }


  export type ReceiptMinAggregateInputType = {
    id?: true
    paymentId?: true
    pdfUrl?: true
    createdAt?: true
  }

  export type ReceiptMaxAggregateInputType = {
    id?: true
    paymentId?: true
    pdfUrl?: true
    createdAt?: true
  }

  export type ReceiptCountAggregateInputType = {
    id?: true
    paymentId?: true
    pdfUrl?: true
    createdAt?: true
    _all?: true
  }

  export type ReceiptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Receipt to aggregate.
     */
    where?: ReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receipts to fetch.
     */
    orderBy?: ReceiptOrderByWithRelationInput | ReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Receipts
    **/
    _count?: true | ReceiptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReceiptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReceiptMaxAggregateInputType
  }

  export type GetReceiptAggregateType<T extends ReceiptAggregateArgs> = {
        [P in keyof T & keyof AggregateReceipt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReceipt[P]>
      : GetScalarType<T[P], AggregateReceipt[P]>
  }




  export type ReceiptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceiptWhereInput
    orderBy?: ReceiptOrderByWithAggregationInput | ReceiptOrderByWithAggregationInput[]
    by: ReceiptScalarFieldEnum[] | ReceiptScalarFieldEnum
    having?: ReceiptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReceiptCountAggregateInputType | true
    _min?: ReceiptMinAggregateInputType
    _max?: ReceiptMaxAggregateInputType
  }

  export type ReceiptGroupByOutputType = {
    id: string
    paymentId: string
    pdfUrl: string | null
    createdAt: Date
    _count: ReceiptCountAggregateOutputType | null
    _min: ReceiptMinAggregateOutputType | null
    _max: ReceiptMaxAggregateOutputType | null
  }

  type GetReceiptGroupByPayload<T extends ReceiptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReceiptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReceiptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReceiptGroupByOutputType[P]>
            : GetScalarType<T[P], ReceiptGroupByOutputType[P]>
        }
      >
    >


  export type ReceiptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    pdfUrl?: boolean
    createdAt?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receipt"]>

  export type ReceiptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    pdfUrl?: boolean
    createdAt?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receipt"]>

  export type ReceiptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    pdfUrl?: boolean
    createdAt?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receipt"]>

  export type ReceiptSelectScalar = {
    id?: boolean
    paymentId?: boolean
    pdfUrl?: boolean
    createdAt?: boolean
  }

  export type ReceiptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "paymentId" | "pdfUrl" | "createdAt", ExtArgs["result"]["receipt"]>
  export type ReceiptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }
  export type ReceiptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }
  export type ReceiptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }

  export type $ReceiptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Receipt"
    objects: {
      payment: Prisma.$PaymentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      paymentId: string
      pdfUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["receipt"]>
    composites: {}
  }

  type ReceiptGetPayload<S extends boolean | null | undefined | ReceiptDefaultArgs> = $Result.GetResult<Prisma.$ReceiptPayload, S>

  type ReceiptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReceiptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReceiptCountAggregateInputType | true
    }

  export interface ReceiptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Receipt'], meta: { name: 'Receipt' } }
    /**
     * Find zero or one Receipt that matches the filter.
     * @param {ReceiptFindUniqueArgs} args - Arguments to find a Receipt
     * @example
     * // Get one Receipt
     * const receipt = await prisma.receipt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReceiptFindUniqueArgs>(args: SelectSubset<T, ReceiptFindUniqueArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Receipt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReceiptFindUniqueOrThrowArgs} args - Arguments to find a Receipt
     * @example
     * // Get one Receipt
     * const receipt = await prisma.receipt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReceiptFindUniqueOrThrowArgs>(args: SelectSubset<T, ReceiptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Receipt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptFindFirstArgs} args - Arguments to find a Receipt
     * @example
     * // Get one Receipt
     * const receipt = await prisma.receipt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReceiptFindFirstArgs>(args?: SelectSubset<T, ReceiptFindFirstArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Receipt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptFindFirstOrThrowArgs} args - Arguments to find a Receipt
     * @example
     * // Get one Receipt
     * const receipt = await prisma.receipt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReceiptFindFirstOrThrowArgs>(args?: SelectSubset<T, ReceiptFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Receipts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Receipts
     * const receipts = await prisma.receipt.findMany()
     * 
     * // Get first 10 Receipts
     * const receipts = await prisma.receipt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const receiptWithIdOnly = await prisma.receipt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReceiptFindManyArgs>(args?: SelectSubset<T, ReceiptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Receipt.
     * @param {ReceiptCreateArgs} args - Arguments to create a Receipt.
     * @example
     * // Create one Receipt
     * const Receipt = await prisma.receipt.create({
     *   data: {
     *     // ... data to create a Receipt
     *   }
     * })
     * 
     */
    create<T extends ReceiptCreateArgs>(args: SelectSubset<T, ReceiptCreateArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Receipts.
     * @param {ReceiptCreateManyArgs} args - Arguments to create many Receipts.
     * @example
     * // Create many Receipts
     * const receipt = await prisma.receipt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReceiptCreateManyArgs>(args?: SelectSubset<T, ReceiptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Receipts and returns the data saved in the database.
     * @param {ReceiptCreateManyAndReturnArgs} args - Arguments to create many Receipts.
     * @example
     * // Create many Receipts
     * const receipt = await prisma.receipt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Receipts and only return the `id`
     * const receiptWithIdOnly = await prisma.receipt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReceiptCreateManyAndReturnArgs>(args?: SelectSubset<T, ReceiptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Receipt.
     * @param {ReceiptDeleteArgs} args - Arguments to delete one Receipt.
     * @example
     * // Delete one Receipt
     * const Receipt = await prisma.receipt.delete({
     *   where: {
     *     // ... filter to delete one Receipt
     *   }
     * })
     * 
     */
    delete<T extends ReceiptDeleteArgs>(args: SelectSubset<T, ReceiptDeleteArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Receipt.
     * @param {ReceiptUpdateArgs} args - Arguments to update one Receipt.
     * @example
     * // Update one Receipt
     * const receipt = await prisma.receipt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReceiptUpdateArgs>(args: SelectSubset<T, ReceiptUpdateArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Receipts.
     * @param {ReceiptDeleteManyArgs} args - Arguments to filter Receipts to delete.
     * @example
     * // Delete a few Receipts
     * const { count } = await prisma.receipt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReceiptDeleteManyArgs>(args?: SelectSubset<T, ReceiptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Receipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Receipts
     * const receipt = await prisma.receipt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReceiptUpdateManyArgs>(args: SelectSubset<T, ReceiptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Receipts and returns the data updated in the database.
     * @param {ReceiptUpdateManyAndReturnArgs} args - Arguments to update many Receipts.
     * @example
     * // Update many Receipts
     * const receipt = await prisma.receipt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Receipts and only return the `id`
     * const receiptWithIdOnly = await prisma.receipt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReceiptUpdateManyAndReturnArgs>(args: SelectSubset<T, ReceiptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Receipt.
     * @param {ReceiptUpsertArgs} args - Arguments to update or create a Receipt.
     * @example
     * // Update or create a Receipt
     * const receipt = await prisma.receipt.upsert({
     *   create: {
     *     // ... data to create a Receipt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Receipt we want to update
     *   }
     * })
     */
    upsert<T extends ReceiptUpsertArgs>(args: SelectSubset<T, ReceiptUpsertArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Receipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptCountArgs} args - Arguments to filter Receipts to count.
     * @example
     * // Count the number of Receipts
     * const count = await prisma.receipt.count({
     *   where: {
     *     // ... the filter for the Receipts we want to count
     *   }
     * })
    **/
    count<T extends ReceiptCountArgs>(
      args?: Subset<T, ReceiptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReceiptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Receipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReceiptAggregateArgs>(args: Subset<T, ReceiptAggregateArgs>): Prisma.PrismaPromise<GetReceiptAggregateType<T>>

    /**
     * Group by Receipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReceiptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReceiptGroupByArgs['orderBy'] }
        : { orderBy?: ReceiptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReceiptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReceiptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Receipt model
   */
  readonly fields: ReceiptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Receipt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReceiptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payment<T extends PaymentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentDefaultArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Receipt model
   */
  interface ReceiptFieldRefs {
    readonly id: FieldRef<"Receipt", 'String'>
    readonly paymentId: FieldRef<"Receipt", 'String'>
    readonly pdfUrl: FieldRef<"Receipt", 'String'>
    readonly createdAt: FieldRef<"Receipt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Receipt findUnique
   */
  export type ReceiptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter, which Receipt to fetch.
     */
    where: ReceiptWhereUniqueInput
  }

  /**
   * Receipt findUniqueOrThrow
   */
  export type ReceiptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter, which Receipt to fetch.
     */
    where: ReceiptWhereUniqueInput
  }

  /**
   * Receipt findFirst
   */
  export type ReceiptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter, which Receipt to fetch.
     */
    where?: ReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receipts to fetch.
     */
    orderBy?: ReceiptOrderByWithRelationInput | ReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Receipts.
     */
    cursor?: ReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Receipts.
     */
    distinct?: ReceiptScalarFieldEnum | ReceiptScalarFieldEnum[]
  }

  /**
   * Receipt findFirstOrThrow
   */
  export type ReceiptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter, which Receipt to fetch.
     */
    where?: ReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receipts to fetch.
     */
    orderBy?: ReceiptOrderByWithRelationInput | ReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Receipts.
     */
    cursor?: ReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Receipts.
     */
    distinct?: ReceiptScalarFieldEnum | ReceiptScalarFieldEnum[]
  }

  /**
   * Receipt findMany
   */
  export type ReceiptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter, which Receipts to fetch.
     */
    where?: ReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receipts to fetch.
     */
    orderBy?: ReceiptOrderByWithRelationInput | ReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Receipts.
     */
    cursor?: ReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receipts.
     */
    skip?: number
    distinct?: ReceiptScalarFieldEnum | ReceiptScalarFieldEnum[]
  }

  /**
   * Receipt create
   */
  export type ReceiptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * The data needed to create a Receipt.
     */
    data: XOR<ReceiptCreateInput, ReceiptUncheckedCreateInput>
  }

  /**
   * Receipt createMany
   */
  export type ReceiptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Receipts.
     */
    data: ReceiptCreateManyInput | ReceiptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Receipt createManyAndReturn
   */
  export type ReceiptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * The data used to create many Receipts.
     */
    data: ReceiptCreateManyInput | ReceiptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Receipt update
   */
  export type ReceiptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * The data needed to update a Receipt.
     */
    data: XOR<ReceiptUpdateInput, ReceiptUncheckedUpdateInput>
    /**
     * Choose, which Receipt to update.
     */
    where: ReceiptWhereUniqueInput
  }

  /**
   * Receipt updateMany
   */
  export type ReceiptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Receipts.
     */
    data: XOR<ReceiptUpdateManyMutationInput, ReceiptUncheckedUpdateManyInput>
    /**
     * Filter which Receipts to update
     */
    where?: ReceiptWhereInput
    /**
     * Limit how many Receipts to update.
     */
    limit?: number
  }

  /**
   * Receipt updateManyAndReturn
   */
  export type ReceiptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * The data used to update Receipts.
     */
    data: XOR<ReceiptUpdateManyMutationInput, ReceiptUncheckedUpdateManyInput>
    /**
     * Filter which Receipts to update
     */
    where?: ReceiptWhereInput
    /**
     * Limit how many Receipts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Receipt upsert
   */
  export type ReceiptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * The filter to search for the Receipt to update in case it exists.
     */
    where: ReceiptWhereUniqueInput
    /**
     * In case the Receipt found by the `where` argument doesn't exist, create a new Receipt with this data.
     */
    create: XOR<ReceiptCreateInput, ReceiptUncheckedCreateInput>
    /**
     * In case the Receipt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReceiptUpdateInput, ReceiptUncheckedUpdateInput>
  }

  /**
   * Receipt delete
   */
  export type ReceiptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter which Receipt to delete.
     */
    where: ReceiptWhereUniqueInput
  }

  /**
   * Receipt deleteMany
   */
  export type ReceiptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Receipts to delete
     */
    where?: ReceiptWhereInput
    /**
     * Limit how many Receipts to delete.
     */
    limit?: number
  }

  /**
   * Receipt without action
   */
  export type ReceiptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receipt
     */
    omit?: ReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
  }


  /**
   * Model VendorFollower
   */

  export type AggregateVendorFollower = {
    _count: VendorFollowerCountAggregateOutputType | null
    _min: VendorFollowerMinAggregateOutputType | null
    _max: VendorFollowerMaxAggregateOutputType | null
  }

  export type VendorFollowerMinAggregateOutputType = {
    id: string | null
    vendorId: string | null
    customerId: string | null
    createdAt: Date | null
  }

  export type VendorFollowerMaxAggregateOutputType = {
    id: string | null
    vendorId: string | null
    customerId: string | null
    createdAt: Date | null
  }

  export type VendorFollowerCountAggregateOutputType = {
    id: number
    vendorId: number
    customerId: number
    createdAt: number
    _all: number
  }


  export type VendorFollowerMinAggregateInputType = {
    id?: true
    vendorId?: true
    customerId?: true
    createdAt?: true
  }

  export type VendorFollowerMaxAggregateInputType = {
    id?: true
    vendorId?: true
    customerId?: true
    createdAt?: true
  }

  export type VendorFollowerCountAggregateInputType = {
    id?: true
    vendorId?: true
    customerId?: true
    createdAt?: true
    _all?: true
  }

  export type VendorFollowerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorFollower to aggregate.
     */
    where?: VendorFollowerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorFollowers to fetch.
     */
    orderBy?: VendorFollowerOrderByWithRelationInput | VendorFollowerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorFollowerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorFollowers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorFollowers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VendorFollowers
    **/
    _count?: true | VendorFollowerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorFollowerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorFollowerMaxAggregateInputType
  }

  export type GetVendorFollowerAggregateType<T extends VendorFollowerAggregateArgs> = {
        [P in keyof T & keyof AggregateVendorFollower]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendorFollower[P]>
      : GetScalarType<T[P], AggregateVendorFollower[P]>
  }




  export type VendorFollowerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorFollowerWhereInput
    orderBy?: VendorFollowerOrderByWithAggregationInput | VendorFollowerOrderByWithAggregationInput[]
    by: VendorFollowerScalarFieldEnum[] | VendorFollowerScalarFieldEnum
    having?: VendorFollowerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorFollowerCountAggregateInputType | true
    _min?: VendorFollowerMinAggregateInputType
    _max?: VendorFollowerMaxAggregateInputType
  }

  export type VendorFollowerGroupByOutputType = {
    id: string
    vendorId: string
    customerId: string
    createdAt: Date
    _count: VendorFollowerCountAggregateOutputType | null
    _min: VendorFollowerMinAggregateOutputType | null
    _max: VendorFollowerMaxAggregateOutputType | null
  }

  type GetVendorFollowerGroupByPayload<T extends VendorFollowerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorFollowerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorFollowerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorFollowerGroupByOutputType[P]>
            : GetScalarType<T[P], VendorFollowerGroupByOutputType[P]>
        }
      >
    >


  export type VendorFollowerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    customerId?: boolean
    createdAt?: boolean
    vendor?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorFollower"]>

  export type VendorFollowerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    customerId?: boolean
    createdAt?: boolean
    vendor?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorFollower"]>

  export type VendorFollowerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    customerId?: boolean
    createdAt?: boolean
    vendor?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorFollower"]>

  export type VendorFollowerSelectScalar = {
    id?: boolean
    vendorId?: boolean
    customerId?: boolean
    createdAt?: boolean
  }

  export type VendorFollowerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vendorId" | "customerId" | "createdAt", ExtArgs["result"]["vendorFollower"]>
  export type VendorFollowerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VendorFollowerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VendorFollowerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VendorFollowerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VendorFollower"
    objects: {
      vendor: Prisma.$UserPayload<ExtArgs>
      customer: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendorId: string
      customerId: string
      createdAt: Date
    }, ExtArgs["result"]["vendorFollower"]>
    composites: {}
  }

  type VendorFollowerGetPayload<S extends boolean | null | undefined | VendorFollowerDefaultArgs> = $Result.GetResult<Prisma.$VendorFollowerPayload, S>

  type VendorFollowerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorFollowerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorFollowerCountAggregateInputType | true
    }

  export interface VendorFollowerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VendorFollower'], meta: { name: 'VendorFollower' } }
    /**
     * Find zero or one VendorFollower that matches the filter.
     * @param {VendorFollowerFindUniqueArgs} args - Arguments to find a VendorFollower
     * @example
     * // Get one VendorFollower
     * const vendorFollower = await prisma.vendorFollower.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorFollowerFindUniqueArgs>(args: SelectSubset<T, VendorFollowerFindUniqueArgs<ExtArgs>>): Prisma__VendorFollowerClient<$Result.GetResult<Prisma.$VendorFollowerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VendorFollower that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorFollowerFindUniqueOrThrowArgs} args - Arguments to find a VendorFollower
     * @example
     * // Get one VendorFollower
     * const vendorFollower = await prisma.vendorFollower.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorFollowerFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorFollowerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorFollowerClient<$Result.GetResult<Prisma.$VendorFollowerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorFollower that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFollowerFindFirstArgs} args - Arguments to find a VendorFollower
     * @example
     * // Get one VendorFollower
     * const vendorFollower = await prisma.vendorFollower.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorFollowerFindFirstArgs>(args?: SelectSubset<T, VendorFollowerFindFirstArgs<ExtArgs>>): Prisma__VendorFollowerClient<$Result.GetResult<Prisma.$VendorFollowerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorFollower that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFollowerFindFirstOrThrowArgs} args - Arguments to find a VendorFollower
     * @example
     * // Get one VendorFollower
     * const vendorFollower = await prisma.vendorFollower.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorFollowerFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorFollowerFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorFollowerClient<$Result.GetResult<Prisma.$VendorFollowerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VendorFollowers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFollowerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VendorFollowers
     * const vendorFollowers = await prisma.vendorFollower.findMany()
     * 
     * // Get first 10 VendorFollowers
     * const vendorFollowers = await prisma.vendorFollower.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorFollowerWithIdOnly = await prisma.vendorFollower.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorFollowerFindManyArgs>(args?: SelectSubset<T, VendorFollowerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorFollowerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VendorFollower.
     * @param {VendorFollowerCreateArgs} args - Arguments to create a VendorFollower.
     * @example
     * // Create one VendorFollower
     * const VendorFollower = await prisma.vendorFollower.create({
     *   data: {
     *     // ... data to create a VendorFollower
     *   }
     * })
     * 
     */
    create<T extends VendorFollowerCreateArgs>(args: SelectSubset<T, VendorFollowerCreateArgs<ExtArgs>>): Prisma__VendorFollowerClient<$Result.GetResult<Prisma.$VendorFollowerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VendorFollowers.
     * @param {VendorFollowerCreateManyArgs} args - Arguments to create many VendorFollowers.
     * @example
     * // Create many VendorFollowers
     * const vendorFollower = await prisma.vendorFollower.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorFollowerCreateManyArgs>(args?: SelectSubset<T, VendorFollowerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VendorFollowers and returns the data saved in the database.
     * @param {VendorFollowerCreateManyAndReturnArgs} args - Arguments to create many VendorFollowers.
     * @example
     * // Create many VendorFollowers
     * const vendorFollower = await prisma.vendorFollower.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VendorFollowers and only return the `id`
     * const vendorFollowerWithIdOnly = await prisma.vendorFollower.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorFollowerCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorFollowerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorFollowerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VendorFollower.
     * @param {VendorFollowerDeleteArgs} args - Arguments to delete one VendorFollower.
     * @example
     * // Delete one VendorFollower
     * const VendorFollower = await prisma.vendorFollower.delete({
     *   where: {
     *     // ... filter to delete one VendorFollower
     *   }
     * })
     * 
     */
    delete<T extends VendorFollowerDeleteArgs>(args: SelectSubset<T, VendorFollowerDeleteArgs<ExtArgs>>): Prisma__VendorFollowerClient<$Result.GetResult<Prisma.$VendorFollowerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VendorFollower.
     * @param {VendorFollowerUpdateArgs} args - Arguments to update one VendorFollower.
     * @example
     * // Update one VendorFollower
     * const vendorFollower = await prisma.vendorFollower.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorFollowerUpdateArgs>(args: SelectSubset<T, VendorFollowerUpdateArgs<ExtArgs>>): Prisma__VendorFollowerClient<$Result.GetResult<Prisma.$VendorFollowerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VendorFollowers.
     * @param {VendorFollowerDeleteManyArgs} args - Arguments to filter VendorFollowers to delete.
     * @example
     * // Delete a few VendorFollowers
     * const { count } = await prisma.vendorFollower.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorFollowerDeleteManyArgs>(args?: SelectSubset<T, VendorFollowerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorFollowers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFollowerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VendorFollowers
     * const vendorFollower = await prisma.vendorFollower.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorFollowerUpdateManyArgs>(args: SelectSubset<T, VendorFollowerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorFollowers and returns the data updated in the database.
     * @param {VendorFollowerUpdateManyAndReturnArgs} args - Arguments to update many VendorFollowers.
     * @example
     * // Update many VendorFollowers
     * const vendorFollower = await prisma.vendorFollower.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VendorFollowers and only return the `id`
     * const vendorFollowerWithIdOnly = await prisma.vendorFollower.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VendorFollowerUpdateManyAndReturnArgs>(args: SelectSubset<T, VendorFollowerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorFollowerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VendorFollower.
     * @param {VendorFollowerUpsertArgs} args - Arguments to update or create a VendorFollower.
     * @example
     * // Update or create a VendorFollower
     * const vendorFollower = await prisma.vendorFollower.upsert({
     *   create: {
     *     // ... data to create a VendorFollower
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VendorFollower we want to update
     *   }
     * })
     */
    upsert<T extends VendorFollowerUpsertArgs>(args: SelectSubset<T, VendorFollowerUpsertArgs<ExtArgs>>): Prisma__VendorFollowerClient<$Result.GetResult<Prisma.$VendorFollowerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VendorFollowers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFollowerCountArgs} args - Arguments to filter VendorFollowers to count.
     * @example
     * // Count the number of VendorFollowers
     * const count = await prisma.vendorFollower.count({
     *   where: {
     *     // ... the filter for the VendorFollowers we want to count
     *   }
     * })
    **/
    count<T extends VendorFollowerCountArgs>(
      args?: Subset<T, VendorFollowerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorFollowerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VendorFollower.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFollowerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorFollowerAggregateArgs>(args: Subset<T, VendorFollowerAggregateArgs>): Prisma.PrismaPromise<GetVendorFollowerAggregateType<T>>

    /**
     * Group by VendorFollower.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFollowerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorFollowerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorFollowerGroupByArgs['orderBy'] }
        : { orderBy?: VendorFollowerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorFollowerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorFollowerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VendorFollower model
   */
  readonly fields: VendorFollowerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VendorFollower.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorFollowerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VendorFollower model
   */
  interface VendorFollowerFieldRefs {
    readonly id: FieldRef<"VendorFollower", 'String'>
    readonly vendorId: FieldRef<"VendorFollower", 'String'>
    readonly customerId: FieldRef<"VendorFollower", 'String'>
    readonly createdAt: FieldRef<"VendorFollower", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VendorFollower findUnique
   */
  export type VendorFollowerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorFollower
     */
    select?: VendorFollowerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorFollower
     */
    omit?: VendorFollowerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorFollowerInclude<ExtArgs> | null
    /**
     * Filter, which VendorFollower to fetch.
     */
    where: VendorFollowerWhereUniqueInput
  }

  /**
   * VendorFollower findUniqueOrThrow
   */
  export type VendorFollowerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorFollower
     */
    select?: VendorFollowerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorFollower
     */
    omit?: VendorFollowerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorFollowerInclude<ExtArgs> | null
    /**
     * Filter, which VendorFollower to fetch.
     */
    where: VendorFollowerWhereUniqueInput
  }

  /**
   * VendorFollower findFirst
   */
  export type VendorFollowerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorFollower
     */
    select?: VendorFollowerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorFollower
     */
    omit?: VendorFollowerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorFollowerInclude<ExtArgs> | null
    /**
     * Filter, which VendorFollower to fetch.
     */
    where?: VendorFollowerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorFollowers to fetch.
     */
    orderBy?: VendorFollowerOrderByWithRelationInput | VendorFollowerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorFollowers.
     */
    cursor?: VendorFollowerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorFollowers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorFollowers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorFollowers.
     */
    distinct?: VendorFollowerScalarFieldEnum | VendorFollowerScalarFieldEnum[]
  }

  /**
   * VendorFollower findFirstOrThrow
   */
  export type VendorFollowerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorFollower
     */
    select?: VendorFollowerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorFollower
     */
    omit?: VendorFollowerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorFollowerInclude<ExtArgs> | null
    /**
     * Filter, which VendorFollower to fetch.
     */
    where?: VendorFollowerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorFollowers to fetch.
     */
    orderBy?: VendorFollowerOrderByWithRelationInput | VendorFollowerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorFollowers.
     */
    cursor?: VendorFollowerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorFollowers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorFollowers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorFollowers.
     */
    distinct?: VendorFollowerScalarFieldEnum | VendorFollowerScalarFieldEnum[]
  }

  /**
   * VendorFollower findMany
   */
  export type VendorFollowerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorFollower
     */
    select?: VendorFollowerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorFollower
     */
    omit?: VendorFollowerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorFollowerInclude<ExtArgs> | null
    /**
     * Filter, which VendorFollowers to fetch.
     */
    where?: VendorFollowerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorFollowers to fetch.
     */
    orderBy?: VendorFollowerOrderByWithRelationInput | VendorFollowerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VendorFollowers.
     */
    cursor?: VendorFollowerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorFollowers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorFollowers.
     */
    skip?: number
    distinct?: VendorFollowerScalarFieldEnum | VendorFollowerScalarFieldEnum[]
  }

  /**
   * VendorFollower create
   */
  export type VendorFollowerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorFollower
     */
    select?: VendorFollowerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorFollower
     */
    omit?: VendorFollowerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorFollowerInclude<ExtArgs> | null
    /**
     * The data needed to create a VendorFollower.
     */
    data: XOR<VendorFollowerCreateInput, VendorFollowerUncheckedCreateInput>
  }

  /**
   * VendorFollower createMany
   */
  export type VendorFollowerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VendorFollowers.
     */
    data: VendorFollowerCreateManyInput | VendorFollowerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VendorFollower createManyAndReturn
   */
  export type VendorFollowerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorFollower
     */
    select?: VendorFollowerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorFollower
     */
    omit?: VendorFollowerOmit<ExtArgs> | null
    /**
     * The data used to create many VendorFollowers.
     */
    data: VendorFollowerCreateManyInput | VendorFollowerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorFollowerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorFollower update
   */
  export type VendorFollowerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorFollower
     */
    select?: VendorFollowerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorFollower
     */
    omit?: VendorFollowerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorFollowerInclude<ExtArgs> | null
    /**
     * The data needed to update a VendorFollower.
     */
    data: XOR<VendorFollowerUpdateInput, VendorFollowerUncheckedUpdateInput>
    /**
     * Choose, which VendorFollower to update.
     */
    where: VendorFollowerWhereUniqueInput
  }

  /**
   * VendorFollower updateMany
   */
  export type VendorFollowerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VendorFollowers.
     */
    data: XOR<VendorFollowerUpdateManyMutationInput, VendorFollowerUncheckedUpdateManyInput>
    /**
     * Filter which VendorFollowers to update
     */
    where?: VendorFollowerWhereInput
    /**
     * Limit how many VendorFollowers to update.
     */
    limit?: number
  }

  /**
   * VendorFollower updateManyAndReturn
   */
  export type VendorFollowerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorFollower
     */
    select?: VendorFollowerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorFollower
     */
    omit?: VendorFollowerOmit<ExtArgs> | null
    /**
     * The data used to update VendorFollowers.
     */
    data: XOR<VendorFollowerUpdateManyMutationInput, VendorFollowerUncheckedUpdateManyInput>
    /**
     * Filter which VendorFollowers to update
     */
    where?: VendorFollowerWhereInput
    /**
     * Limit how many VendorFollowers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorFollowerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorFollower upsert
   */
  export type VendorFollowerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorFollower
     */
    select?: VendorFollowerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorFollower
     */
    omit?: VendorFollowerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorFollowerInclude<ExtArgs> | null
    /**
     * The filter to search for the VendorFollower to update in case it exists.
     */
    where: VendorFollowerWhereUniqueInput
    /**
     * In case the VendorFollower found by the `where` argument doesn't exist, create a new VendorFollower with this data.
     */
    create: XOR<VendorFollowerCreateInput, VendorFollowerUncheckedCreateInput>
    /**
     * In case the VendorFollower was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorFollowerUpdateInput, VendorFollowerUncheckedUpdateInput>
  }

  /**
   * VendorFollower delete
   */
  export type VendorFollowerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorFollower
     */
    select?: VendorFollowerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorFollower
     */
    omit?: VendorFollowerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorFollowerInclude<ExtArgs> | null
    /**
     * Filter which VendorFollower to delete.
     */
    where: VendorFollowerWhereUniqueInput
  }

  /**
   * VendorFollower deleteMany
   */
  export type VendorFollowerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorFollowers to delete
     */
    where?: VendorFollowerWhereInput
    /**
     * Limit how many VendorFollowers to delete.
     */
    limit?: number
  }

  /**
   * VendorFollower without action
   */
  export type VendorFollowerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorFollower
     */
    select?: VendorFollowerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorFollower
     */
    omit?: VendorFollowerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorFollowerInclude<ExtArgs> | null
  }


  /**
   * Model SpecialOrderRequest
   */

  export type AggregateSpecialOrderRequest = {
    _count: SpecialOrderRequestCountAggregateOutputType | null
    _avg: SpecialOrderRequestAvgAggregateOutputType | null
    _sum: SpecialOrderRequestSumAggregateOutputType | null
    _min: SpecialOrderRequestMinAggregateOutputType | null
    _max: SpecialOrderRequestMaxAggregateOutputType | null
  }

  export type SpecialOrderRequestAvgAggregateOutputType = {
    quantity: number | null
  }

  export type SpecialOrderRequestSumAggregateOutputType = {
    quantity: number | null
  }

  export type SpecialOrderRequestMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    vendorId: string | null
    productId: string | null
    quantity: number | null
    message: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SpecialOrderRequestMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    vendorId: string | null
    productId: string | null
    quantity: number | null
    message: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SpecialOrderRequestCountAggregateOutputType = {
    id: number
    customerId: number
    vendorId: number
    productId: number
    quantity: number
    message: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SpecialOrderRequestAvgAggregateInputType = {
    quantity?: true
  }

  export type SpecialOrderRequestSumAggregateInputType = {
    quantity?: true
  }

  export type SpecialOrderRequestMinAggregateInputType = {
    id?: true
    customerId?: true
    vendorId?: true
    productId?: true
    quantity?: true
    message?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SpecialOrderRequestMaxAggregateInputType = {
    id?: true
    customerId?: true
    vendorId?: true
    productId?: true
    quantity?: true
    message?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SpecialOrderRequestCountAggregateInputType = {
    id?: true
    customerId?: true
    vendorId?: true
    productId?: true
    quantity?: true
    message?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SpecialOrderRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpecialOrderRequest to aggregate.
     */
    where?: SpecialOrderRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecialOrderRequests to fetch.
     */
    orderBy?: SpecialOrderRequestOrderByWithRelationInput | SpecialOrderRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpecialOrderRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecialOrderRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecialOrderRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpecialOrderRequests
    **/
    _count?: true | SpecialOrderRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpecialOrderRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpecialOrderRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpecialOrderRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpecialOrderRequestMaxAggregateInputType
  }

  export type GetSpecialOrderRequestAggregateType<T extends SpecialOrderRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateSpecialOrderRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpecialOrderRequest[P]>
      : GetScalarType<T[P], AggregateSpecialOrderRequest[P]>
  }




  export type SpecialOrderRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecialOrderRequestWhereInput
    orderBy?: SpecialOrderRequestOrderByWithAggregationInput | SpecialOrderRequestOrderByWithAggregationInput[]
    by: SpecialOrderRequestScalarFieldEnum[] | SpecialOrderRequestScalarFieldEnum
    having?: SpecialOrderRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpecialOrderRequestCountAggregateInputType | true
    _avg?: SpecialOrderRequestAvgAggregateInputType
    _sum?: SpecialOrderRequestSumAggregateInputType
    _min?: SpecialOrderRequestMinAggregateInputType
    _max?: SpecialOrderRequestMaxAggregateInputType
  }

  export type SpecialOrderRequestGroupByOutputType = {
    id: string
    customerId: string
    vendorId: string | null
    productId: string
    quantity: number
    message: string
    status: string
    createdAt: Date
    updatedAt: Date
    _count: SpecialOrderRequestCountAggregateOutputType | null
    _avg: SpecialOrderRequestAvgAggregateOutputType | null
    _sum: SpecialOrderRequestSumAggregateOutputType | null
    _min: SpecialOrderRequestMinAggregateOutputType | null
    _max: SpecialOrderRequestMaxAggregateOutputType | null
  }

  type GetSpecialOrderRequestGroupByPayload<T extends SpecialOrderRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpecialOrderRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpecialOrderRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpecialOrderRequestGroupByOutputType[P]>
            : GetScalarType<T[P], SpecialOrderRequestGroupByOutputType[P]>
        }
      >
    >


  export type SpecialOrderRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    vendorId?: boolean
    productId?: boolean
    quantity?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
    vendor?: boolean | SpecialOrderRequest$vendorArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    offers?: boolean | SpecialOrderRequest$offersArgs<ExtArgs>
    _count?: boolean | SpecialOrderRequestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["specialOrderRequest"]>

  export type SpecialOrderRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    vendorId?: boolean
    productId?: boolean
    quantity?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
    vendor?: boolean | SpecialOrderRequest$vendorArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["specialOrderRequest"]>

  export type SpecialOrderRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    vendorId?: boolean
    productId?: boolean
    quantity?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
    vendor?: boolean | SpecialOrderRequest$vendorArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["specialOrderRequest"]>

  export type SpecialOrderRequestSelectScalar = {
    id?: boolean
    customerId?: boolean
    vendorId?: boolean
    productId?: boolean
    quantity?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SpecialOrderRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "vendorId" | "productId" | "quantity" | "message" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["specialOrderRequest"]>
  export type SpecialOrderRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
    vendor?: boolean | SpecialOrderRequest$vendorArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    offers?: boolean | SpecialOrderRequest$offersArgs<ExtArgs>
    _count?: boolean | SpecialOrderRequestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SpecialOrderRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
    vendor?: boolean | SpecialOrderRequest$vendorArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type SpecialOrderRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
    vendor?: boolean | SpecialOrderRequest$vendorArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $SpecialOrderRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpecialOrderRequest"
    objects: {
      customer: Prisma.$UserPayload<ExtArgs>
      vendor: Prisma.$UserPayload<ExtArgs> | null
      product: Prisma.$ProductPayload<ExtArgs>
      offers: Prisma.$SpecialOrderOfferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      vendorId: string | null
      productId: string
      quantity: number
      message: string
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["specialOrderRequest"]>
    composites: {}
  }

  type SpecialOrderRequestGetPayload<S extends boolean | null | undefined | SpecialOrderRequestDefaultArgs> = $Result.GetResult<Prisma.$SpecialOrderRequestPayload, S>

  type SpecialOrderRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpecialOrderRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpecialOrderRequestCountAggregateInputType | true
    }

  export interface SpecialOrderRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpecialOrderRequest'], meta: { name: 'SpecialOrderRequest' } }
    /**
     * Find zero or one SpecialOrderRequest that matches the filter.
     * @param {SpecialOrderRequestFindUniqueArgs} args - Arguments to find a SpecialOrderRequest
     * @example
     * // Get one SpecialOrderRequest
     * const specialOrderRequest = await prisma.specialOrderRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpecialOrderRequestFindUniqueArgs>(args: SelectSubset<T, SpecialOrderRequestFindUniqueArgs<ExtArgs>>): Prisma__SpecialOrderRequestClient<$Result.GetResult<Prisma.$SpecialOrderRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SpecialOrderRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpecialOrderRequestFindUniqueOrThrowArgs} args - Arguments to find a SpecialOrderRequest
     * @example
     * // Get one SpecialOrderRequest
     * const specialOrderRequest = await prisma.specialOrderRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpecialOrderRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, SpecialOrderRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpecialOrderRequestClient<$Result.GetResult<Prisma.$SpecialOrderRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpecialOrderRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialOrderRequestFindFirstArgs} args - Arguments to find a SpecialOrderRequest
     * @example
     * // Get one SpecialOrderRequest
     * const specialOrderRequest = await prisma.specialOrderRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpecialOrderRequestFindFirstArgs>(args?: SelectSubset<T, SpecialOrderRequestFindFirstArgs<ExtArgs>>): Prisma__SpecialOrderRequestClient<$Result.GetResult<Prisma.$SpecialOrderRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpecialOrderRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialOrderRequestFindFirstOrThrowArgs} args - Arguments to find a SpecialOrderRequest
     * @example
     * // Get one SpecialOrderRequest
     * const specialOrderRequest = await prisma.specialOrderRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpecialOrderRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, SpecialOrderRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpecialOrderRequestClient<$Result.GetResult<Prisma.$SpecialOrderRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SpecialOrderRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialOrderRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpecialOrderRequests
     * const specialOrderRequests = await prisma.specialOrderRequest.findMany()
     * 
     * // Get first 10 SpecialOrderRequests
     * const specialOrderRequests = await prisma.specialOrderRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const specialOrderRequestWithIdOnly = await prisma.specialOrderRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpecialOrderRequestFindManyArgs>(args?: SelectSubset<T, SpecialOrderRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialOrderRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SpecialOrderRequest.
     * @param {SpecialOrderRequestCreateArgs} args - Arguments to create a SpecialOrderRequest.
     * @example
     * // Create one SpecialOrderRequest
     * const SpecialOrderRequest = await prisma.specialOrderRequest.create({
     *   data: {
     *     // ... data to create a SpecialOrderRequest
     *   }
     * })
     * 
     */
    create<T extends SpecialOrderRequestCreateArgs>(args: SelectSubset<T, SpecialOrderRequestCreateArgs<ExtArgs>>): Prisma__SpecialOrderRequestClient<$Result.GetResult<Prisma.$SpecialOrderRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SpecialOrderRequests.
     * @param {SpecialOrderRequestCreateManyArgs} args - Arguments to create many SpecialOrderRequests.
     * @example
     * // Create many SpecialOrderRequests
     * const specialOrderRequest = await prisma.specialOrderRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpecialOrderRequestCreateManyArgs>(args?: SelectSubset<T, SpecialOrderRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpecialOrderRequests and returns the data saved in the database.
     * @param {SpecialOrderRequestCreateManyAndReturnArgs} args - Arguments to create many SpecialOrderRequests.
     * @example
     * // Create many SpecialOrderRequests
     * const specialOrderRequest = await prisma.specialOrderRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpecialOrderRequests and only return the `id`
     * const specialOrderRequestWithIdOnly = await prisma.specialOrderRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpecialOrderRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, SpecialOrderRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialOrderRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SpecialOrderRequest.
     * @param {SpecialOrderRequestDeleteArgs} args - Arguments to delete one SpecialOrderRequest.
     * @example
     * // Delete one SpecialOrderRequest
     * const SpecialOrderRequest = await prisma.specialOrderRequest.delete({
     *   where: {
     *     // ... filter to delete one SpecialOrderRequest
     *   }
     * })
     * 
     */
    delete<T extends SpecialOrderRequestDeleteArgs>(args: SelectSubset<T, SpecialOrderRequestDeleteArgs<ExtArgs>>): Prisma__SpecialOrderRequestClient<$Result.GetResult<Prisma.$SpecialOrderRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SpecialOrderRequest.
     * @param {SpecialOrderRequestUpdateArgs} args - Arguments to update one SpecialOrderRequest.
     * @example
     * // Update one SpecialOrderRequest
     * const specialOrderRequest = await prisma.specialOrderRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpecialOrderRequestUpdateArgs>(args: SelectSubset<T, SpecialOrderRequestUpdateArgs<ExtArgs>>): Prisma__SpecialOrderRequestClient<$Result.GetResult<Prisma.$SpecialOrderRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SpecialOrderRequests.
     * @param {SpecialOrderRequestDeleteManyArgs} args - Arguments to filter SpecialOrderRequests to delete.
     * @example
     * // Delete a few SpecialOrderRequests
     * const { count } = await prisma.specialOrderRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpecialOrderRequestDeleteManyArgs>(args?: SelectSubset<T, SpecialOrderRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpecialOrderRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialOrderRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpecialOrderRequests
     * const specialOrderRequest = await prisma.specialOrderRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpecialOrderRequestUpdateManyArgs>(args: SelectSubset<T, SpecialOrderRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpecialOrderRequests and returns the data updated in the database.
     * @param {SpecialOrderRequestUpdateManyAndReturnArgs} args - Arguments to update many SpecialOrderRequests.
     * @example
     * // Update many SpecialOrderRequests
     * const specialOrderRequest = await prisma.specialOrderRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SpecialOrderRequests and only return the `id`
     * const specialOrderRequestWithIdOnly = await prisma.specialOrderRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SpecialOrderRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, SpecialOrderRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialOrderRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SpecialOrderRequest.
     * @param {SpecialOrderRequestUpsertArgs} args - Arguments to update or create a SpecialOrderRequest.
     * @example
     * // Update or create a SpecialOrderRequest
     * const specialOrderRequest = await prisma.specialOrderRequest.upsert({
     *   create: {
     *     // ... data to create a SpecialOrderRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpecialOrderRequest we want to update
     *   }
     * })
     */
    upsert<T extends SpecialOrderRequestUpsertArgs>(args: SelectSubset<T, SpecialOrderRequestUpsertArgs<ExtArgs>>): Prisma__SpecialOrderRequestClient<$Result.GetResult<Prisma.$SpecialOrderRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SpecialOrderRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialOrderRequestCountArgs} args - Arguments to filter SpecialOrderRequests to count.
     * @example
     * // Count the number of SpecialOrderRequests
     * const count = await prisma.specialOrderRequest.count({
     *   where: {
     *     // ... the filter for the SpecialOrderRequests we want to count
     *   }
     * })
    **/
    count<T extends SpecialOrderRequestCountArgs>(
      args?: Subset<T, SpecialOrderRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpecialOrderRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpecialOrderRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialOrderRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpecialOrderRequestAggregateArgs>(args: Subset<T, SpecialOrderRequestAggregateArgs>): Prisma.PrismaPromise<GetSpecialOrderRequestAggregateType<T>>

    /**
     * Group by SpecialOrderRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialOrderRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpecialOrderRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpecialOrderRequestGroupByArgs['orderBy'] }
        : { orderBy?: SpecialOrderRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpecialOrderRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpecialOrderRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpecialOrderRequest model
   */
  readonly fields: SpecialOrderRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpecialOrderRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpecialOrderRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vendor<T extends SpecialOrderRequest$vendorArgs<ExtArgs> = {}>(args?: Subset<T, SpecialOrderRequest$vendorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    offers<T extends SpecialOrderRequest$offersArgs<ExtArgs> = {}>(args?: Subset<T, SpecialOrderRequest$offersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialOrderOfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpecialOrderRequest model
   */
  interface SpecialOrderRequestFieldRefs {
    readonly id: FieldRef<"SpecialOrderRequest", 'String'>
    readonly customerId: FieldRef<"SpecialOrderRequest", 'String'>
    readonly vendorId: FieldRef<"SpecialOrderRequest", 'String'>
    readonly productId: FieldRef<"SpecialOrderRequest", 'String'>
    readonly quantity: FieldRef<"SpecialOrderRequest", 'Int'>
    readonly message: FieldRef<"SpecialOrderRequest", 'String'>
    readonly status: FieldRef<"SpecialOrderRequest", 'String'>
    readonly createdAt: FieldRef<"SpecialOrderRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"SpecialOrderRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SpecialOrderRequest findUnique
   */
  export type SpecialOrderRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOrderRequest
     */
    select?: SpecialOrderRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOrderRequest
     */
    omit?: SpecialOrderRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialOrderRequestInclude<ExtArgs> | null
    /**
     * Filter, which SpecialOrderRequest to fetch.
     */
    where: SpecialOrderRequestWhereUniqueInput
  }

  /**
   * SpecialOrderRequest findUniqueOrThrow
   */
  export type SpecialOrderRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOrderRequest
     */
    select?: SpecialOrderRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOrderRequest
     */
    omit?: SpecialOrderRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialOrderRequestInclude<ExtArgs> | null
    /**
     * Filter, which SpecialOrderRequest to fetch.
     */
    where: SpecialOrderRequestWhereUniqueInput
  }

  /**
   * SpecialOrderRequest findFirst
   */
  export type SpecialOrderRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOrderRequest
     */
    select?: SpecialOrderRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOrderRequest
     */
    omit?: SpecialOrderRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialOrderRequestInclude<ExtArgs> | null
    /**
     * Filter, which SpecialOrderRequest to fetch.
     */
    where?: SpecialOrderRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecialOrderRequests to fetch.
     */
    orderBy?: SpecialOrderRequestOrderByWithRelationInput | SpecialOrderRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpecialOrderRequests.
     */
    cursor?: SpecialOrderRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecialOrderRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecialOrderRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpecialOrderRequests.
     */
    distinct?: SpecialOrderRequestScalarFieldEnum | SpecialOrderRequestScalarFieldEnum[]
  }

  /**
   * SpecialOrderRequest findFirstOrThrow
   */
  export type SpecialOrderRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOrderRequest
     */
    select?: SpecialOrderRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOrderRequest
     */
    omit?: SpecialOrderRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialOrderRequestInclude<ExtArgs> | null
    /**
     * Filter, which SpecialOrderRequest to fetch.
     */
    where?: SpecialOrderRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecialOrderRequests to fetch.
     */
    orderBy?: SpecialOrderRequestOrderByWithRelationInput | SpecialOrderRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpecialOrderRequests.
     */
    cursor?: SpecialOrderRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecialOrderRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecialOrderRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpecialOrderRequests.
     */
    distinct?: SpecialOrderRequestScalarFieldEnum | SpecialOrderRequestScalarFieldEnum[]
  }

  /**
   * SpecialOrderRequest findMany
   */
  export type SpecialOrderRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOrderRequest
     */
    select?: SpecialOrderRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOrderRequest
     */
    omit?: SpecialOrderRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialOrderRequestInclude<ExtArgs> | null
    /**
     * Filter, which SpecialOrderRequests to fetch.
     */
    where?: SpecialOrderRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecialOrderRequests to fetch.
     */
    orderBy?: SpecialOrderRequestOrderByWithRelationInput | SpecialOrderRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpecialOrderRequests.
     */
    cursor?: SpecialOrderRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecialOrderRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecialOrderRequests.
     */
    skip?: number
    distinct?: SpecialOrderRequestScalarFieldEnum | SpecialOrderRequestScalarFieldEnum[]
  }

  /**
   * SpecialOrderRequest create
   */
  export type SpecialOrderRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOrderRequest
     */
    select?: SpecialOrderRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOrderRequest
     */
    omit?: SpecialOrderRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialOrderRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a SpecialOrderRequest.
     */
    data: XOR<SpecialOrderRequestCreateInput, SpecialOrderRequestUncheckedCreateInput>
  }

  /**
   * SpecialOrderRequest createMany
   */
  export type SpecialOrderRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpecialOrderRequests.
     */
    data: SpecialOrderRequestCreateManyInput | SpecialOrderRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpecialOrderRequest createManyAndReturn
   */
  export type SpecialOrderRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOrderRequest
     */
    select?: SpecialOrderRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOrderRequest
     */
    omit?: SpecialOrderRequestOmit<ExtArgs> | null
    /**
     * The data used to create many SpecialOrderRequests.
     */
    data: SpecialOrderRequestCreateManyInput | SpecialOrderRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialOrderRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpecialOrderRequest update
   */
  export type SpecialOrderRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOrderRequest
     */
    select?: SpecialOrderRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOrderRequest
     */
    omit?: SpecialOrderRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialOrderRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a SpecialOrderRequest.
     */
    data: XOR<SpecialOrderRequestUpdateInput, SpecialOrderRequestUncheckedUpdateInput>
    /**
     * Choose, which SpecialOrderRequest to update.
     */
    where: SpecialOrderRequestWhereUniqueInput
  }

  /**
   * SpecialOrderRequest updateMany
   */
  export type SpecialOrderRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpecialOrderRequests.
     */
    data: XOR<SpecialOrderRequestUpdateManyMutationInput, SpecialOrderRequestUncheckedUpdateManyInput>
    /**
     * Filter which SpecialOrderRequests to update
     */
    where?: SpecialOrderRequestWhereInput
    /**
     * Limit how many SpecialOrderRequests to update.
     */
    limit?: number
  }

  /**
   * SpecialOrderRequest updateManyAndReturn
   */
  export type SpecialOrderRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOrderRequest
     */
    select?: SpecialOrderRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOrderRequest
     */
    omit?: SpecialOrderRequestOmit<ExtArgs> | null
    /**
     * The data used to update SpecialOrderRequests.
     */
    data: XOR<SpecialOrderRequestUpdateManyMutationInput, SpecialOrderRequestUncheckedUpdateManyInput>
    /**
     * Filter which SpecialOrderRequests to update
     */
    where?: SpecialOrderRequestWhereInput
    /**
     * Limit how many SpecialOrderRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialOrderRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpecialOrderRequest upsert
   */
  export type SpecialOrderRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOrderRequest
     */
    select?: SpecialOrderRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOrderRequest
     */
    omit?: SpecialOrderRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialOrderRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the SpecialOrderRequest to update in case it exists.
     */
    where: SpecialOrderRequestWhereUniqueInput
    /**
     * In case the SpecialOrderRequest found by the `where` argument doesn't exist, create a new SpecialOrderRequest with this data.
     */
    create: XOR<SpecialOrderRequestCreateInput, SpecialOrderRequestUncheckedCreateInput>
    /**
     * In case the SpecialOrderRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpecialOrderRequestUpdateInput, SpecialOrderRequestUncheckedUpdateInput>
  }

  /**
   * SpecialOrderRequest delete
   */
  export type SpecialOrderRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOrderRequest
     */
    select?: SpecialOrderRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOrderRequest
     */
    omit?: SpecialOrderRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialOrderRequestInclude<ExtArgs> | null
    /**
     * Filter which SpecialOrderRequest to delete.
     */
    where: SpecialOrderRequestWhereUniqueInput
  }

  /**
   * SpecialOrderRequest deleteMany
   */
  export type SpecialOrderRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpecialOrderRequests to delete
     */
    where?: SpecialOrderRequestWhereInput
    /**
     * Limit how many SpecialOrderRequests to delete.
     */
    limit?: number
  }

  /**
   * SpecialOrderRequest.vendor
   */
  export type SpecialOrderRequest$vendorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SpecialOrderRequest.offers
   */
  export type SpecialOrderRequest$offersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOrderOffer
     */
    select?: SpecialOrderOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOrderOffer
     */
    omit?: SpecialOrderOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialOrderOfferInclude<ExtArgs> | null
    where?: SpecialOrderOfferWhereInput
    orderBy?: SpecialOrderOfferOrderByWithRelationInput | SpecialOrderOfferOrderByWithRelationInput[]
    cursor?: SpecialOrderOfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpecialOrderOfferScalarFieldEnum | SpecialOrderOfferScalarFieldEnum[]
  }

  /**
   * SpecialOrderRequest without action
   */
  export type SpecialOrderRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOrderRequest
     */
    select?: SpecialOrderRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOrderRequest
     */
    omit?: SpecialOrderRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialOrderRequestInclude<ExtArgs> | null
  }


  /**
   * Model SpecialOrderOffer
   */

  export type AggregateSpecialOrderOffer = {
    _count: SpecialOrderOfferCountAggregateOutputType | null
    _avg: SpecialOrderOfferAvgAggregateOutputType | null
    _sum: SpecialOrderOfferSumAggregateOutputType | null
    _min: SpecialOrderOfferMinAggregateOutputType | null
    _max: SpecialOrderOfferMaxAggregateOutputType | null
  }

  export type SpecialOrderOfferAvgAggregateOutputType = {
    price: number | null
  }

  export type SpecialOrderOfferSumAggregateOutputType = {
    price: number | null
  }

  export type SpecialOrderOfferMinAggregateOutputType = {
    id: string | null
    requestId: string | null
    vendorId: string | null
    price: number | null
    message: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SpecialOrderOfferMaxAggregateOutputType = {
    id: string | null
    requestId: string | null
    vendorId: string | null
    price: number | null
    message: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SpecialOrderOfferCountAggregateOutputType = {
    id: number
    requestId: number
    vendorId: number
    price: number
    message: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SpecialOrderOfferAvgAggregateInputType = {
    price?: true
  }

  export type SpecialOrderOfferSumAggregateInputType = {
    price?: true
  }

  export type SpecialOrderOfferMinAggregateInputType = {
    id?: true
    requestId?: true
    vendorId?: true
    price?: true
    message?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SpecialOrderOfferMaxAggregateInputType = {
    id?: true
    requestId?: true
    vendorId?: true
    price?: true
    message?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SpecialOrderOfferCountAggregateInputType = {
    id?: true
    requestId?: true
    vendorId?: true
    price?: true
    message?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SpecialOrderOfferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpecialOrderOffer to aggregate.
     */
    where?: SpecialOrderOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecialOrderOffers to fetch.
     */
    orderBy?: SpecialOrderOfferOrderByWithRelationInput | SpecialOrderOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpecialOrderOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecialOrderOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecialOrderOffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpecialOrderOffers
    **/
    _count?: true | SpecialOrderOfferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpecialOrderOfferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpecialOrderOfferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpecialOrderOfferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpecialOrderOfferMaxAggregateInputType
  }

  export type GetSpecialOrderOfferAggregateType<T extends SpecialOrderOfferAggregateArgs> = {
        [P in keyof T & keyof AggregateSpecialOrderOffer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpecialOrderOffer[P]>
      : GetScalarType<T[P], AggregateSpecialOrderOffer[P]>
  }




  export type SpecialOrderOfferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecialOrderOfferWhereInput
    orderBy?: SpecialOrderOfferOrderByWithAggregationInput | SpecialOrderOfferOrderByWithAggregationInput[]
    by: SpecialOrderOfferScalarFieldEnum[] | SpecialOrderOfferScalarFieldEnum
    having?: SpecialOrderOfferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpecialOrderOfferCountAggregateInputType | true
    _avg?: SpecialOrderOfferAvgAggregateInputType
    _sum?: SpecialOrderOfferSumAggregateInputType
    _min?: SpecialOrderOfferMinAggregateInputType
    _max?: SpecialOrderOfferMaxAggregateInputType
  }

  export type SpecialOrderOfferGroupByOutputType = {
    id: string
    requestId: string
    vendorId: string
    price: number
    message: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: SpecialOrderOfferCountAggregateOutputType | null
    _avg: SpecialOrderOfferAvgAggregateOutputType | null
    _sum: SpecialOrderOfferSumAggregateOutputType | null
    _min: SpecialOrderOfferMinAggregateOutputType | null
    _max: SpecialOrderOfferMaxAggregateOutputType | null
  }

  type GetSpecialOrderOfferGroupByPayload<T extends SpecialOrderOfferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpecialOrderOfferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpecialOrderOfferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpecialOrderOfferGroupByOutputType[P]>
            : GetScalarType<T[P], SpecialOrderOfferGroupByOutputType[P]>
        }
      >
    >


  export type SpecialOrderOfferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    vendorId?: boolean
    price?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    request?: boolean | SpecialOrderRequestDefaultArgs<ExtArgs>
    vendor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["specialOrderOffer"]>

  export type SpecialOrderOfferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    vendorId?: boolean
    price?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    request?: boolean | SpecialOrderRequestDefaultArgs<ExtArgs>
    vendor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["specialOrderOffer"]>

  export type SpecialOrderOfferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    vendorId?: boolean
    price?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    request?: boolean | SpecialOrderRequestDefaultArgs<ExtArgs>
    vendor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["specialOrderOffer"]>

  export type SpecialOrderOfferSelectScalar = {
    id?: boolean
    requestId?: boolean
    vendorId?: boolean
    price?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SpecialOrderOfferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "requestId" | "vendorId" | "price" | "message" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["specialOrderOffer"]>
  export type SpecialOrderOfferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | SpecialOrderRequestDefaultArgs<ExtArgs>
    vendor?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SpecialOrderOfferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | SpecialOrderRequestDefaultArgs<ExtArgs>
    vendor?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SpecialOrderOfferIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | SpecialOrderRequestDefaultArgs<ExtArgs>
    vendor?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SpecialOrderOfferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpecialOrderOffer"
    objects: {
      request: Prisma.$SpecialOrderRequestPayload<ExtArgs>
      vendor: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      requestId: string
      vendorId: string
      price: number
      message: string | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["specialOrderOffer"]>
    composites: {}
  }

  type SpecialOrderOfferGetPayload<S extends boolean | null | undefined | SpecialOrderOfferDefaultArgs> = $Result.GetResult<Prisma.$SpecialOrderOfferPayload, S>

  type SpecialOrderOfferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpecialOrderOfferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpecialOrderOfferCountAggregateInputType | true
    }

  export interface SpecialOrderOfferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpecialOrderOffer'], meta: { name: 'SpecialOrderOffer' } }
    /**
     * Find zero or one SpecialOrderOffer that matches the filter.
     * @param {SpecialOrderOfferFindUniqueArgs} args - Arguments to find a SpecialOrderOffer
     * @example
     * // Get one SpecialOrderOffer
     * const specialOrderOffer = await prisma.specialOrderOffer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpecialOrderOfferFindUniqueArgs>(args: SelectSubset<T, SpecialOrderOfferFindUniqueArgs<ExtArgs>>): Prisma__SpecialOrderOfferClient<$Result.GetResult<Prisma.$SpecialOrderOfferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SpecialOrderOffer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpecialOrderOfferFindUniqueOrThrowArgs} args - Arguments to find a SpecialOrderOffer
     * @example
     * // Get one SpecialOrderOffer
     * const specialOrderOffer = await prisma.specialOrderOffer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpecialOrderOfferFindUniqueOrThrowArgs>(args: SelectSubset<T, SpecialOrderOfferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpecialOrderOfferClient<$Result.GetResult<Prisma.$SpecialOrderOfferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpecialOrderOffer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialOrderOfferFindFirstArgs} args - Arguments to find a SpecialOrderOffer
     * @example
     * // Get one SpecialOrderOffer
     * const specialOrderOffer = await prisma.specialOrderOffer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpecialOrderOfferFindFirstArgs>(args?: SelectSubset<T, SpecialOrderOfferFindFirstArgs<ExtArgs>>): Prisma__SpecialOrderOfferClient<$Result.GetResult<Prisma.$SpecialOrderOfferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpecialOrderOffer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialOrderOfferFindFirstOrThrowArgs} args - Arguments to find a SpecialOrderOffer
     * @example
     * // Get one SpecialOrderOffer
     * const specialOrderOffer = await prisma.specialOrderOffer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpecialOrderOfferFindFirstOrThrowArgs>(args?: SelectSubset<T, SpecialOrderOfferFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpecialOrderOfferClient<$Result.GetResult<Prisma.$SpecialOrderOfferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SpecialOrderOffers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialOrderOfferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpecialOrderOffers
     * const specialOrderOffers = await prisma.specialOrderOffer.findMany()
     * 
     * // Get first 10 SpecialOrderOffers
     * const specialOrderOffers = await prisma.specialOrderOffer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const specialOrderOfferWithIdOnly = await prisma.specialOrderOffer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpecialOrderOfferFindManyArgs>(args?: SelectSubset<T, SpecialOrderOfferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialOrderOfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SpecialOrderOffer.
     * @param {SpecialOrderOfferCreateArgs} args - Arguments to create a SpecialOrderOffer.
     * @example
     * // Create one SpecialOrderOffer
     * const SpecialOrderOffer = await prisma.specialOrderOffer.create({
     *   data: {
     *     // ... data to create a SpecialOrderOffer
     *   }
     * })
     * 
     */
    create<T extends SpecialOrderOfferCreateArgs>(args: SelectSubset<T, SpecialOrderOfferCreateArgs<ExtArgs>>): Prisma__SpecialOrderOfferClient<$Result.GetResult<Prisma.$SpecialOrderOfferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SpecialOrderOffers.
     * @param {SpecialOrderOfferCreateManyArgs} args - Arguments to create many SpecialOrderOffers.
     * @example
     * // Create many SpecialOrderOffers
     * const specialOrderOffer = await prisma.specialOrderOffer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpecialOrderOfferCreateManyArgs>(args?: SelectSubset<T, SpecialOrderOfferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpecialOrderOffers and returns the data saved in the database.
     * @param {SpecialOrderOfferCreateManyAndReturnArgs} args - Arguments to create many SpecialOrderOffers.
     * @example
     * // Create many SpecialOrderOffers
     * const specialOrderOffer = await prisma.specialOrderOffer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpecialOrderOffers and only return the `id`
     * const specialOrderOfferWithIdOnly = await prisma.specialOrderOffer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpecialOrderOfferCreateManyAndReturnArgs>(args?: SelectSubset<T, SpecialOrderOfferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialOrderOfferPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SpecialOrderOffer.
     * @param {SpecialOrderOfferDeleteArgs} args - Arguments to delete one SpecialOrderOffer.
     * @example
     * // Delete one SpecialOrderOffer
     * const SpecialOrderOffer = await prisma.specialOrderOffer.delete({
     *   where: {
     *     // ... filter to delete one SpecialOrderOffer
     *   }
     * })
     * 
     */
    delete<T extends SpecialOrderOfferDeleteArgs>(args: SelectSubset<T, SpecialOrderOfferDeleteArgs<ExtArgs>>): Prisma__SpecialOrderOfferClient<$Result.GetResult<Prisma.$SpecialOrderOfferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SpecialOrderOffer.
     * @param {SpecialOrderOfferUpdateArgs} args - Arguments to update one SpecialOrderOffer.
     * @example
     * // Update one SpecialOrderOffer
     * const specialOrderOffer = await prisma.specialOrderOffer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpecialOrderOfferUpdateArgs>(args: SelectSubset<T, SpecialOrderOfferUpdateArgs<ExtArgs>>): Prisma__SpecialOrderOfferClient<$Result.GetResult<Prisma.$SpecialOrderOfferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SpecialOrderOffers.
     * @param {SpecialOrderOfferDeleteManyArgs} args - Arguments to filter SpecialOrderOffers to delete.
     * @example
     * // Delete a few SpecialOrderOffers
     * const { count } = await prisma.specialOrderOffer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpecialOrderOfferDeleteManyArgs>(args?: SelectSubset<T, SpecialOrderOfferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpecialOrderOffers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialOrderOfferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpecialOrderOffers
     * const specialOrderOffer = await prisma.specialOrderOffer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpecialOrderOfferUpdateManyArgs>(args: SelectSubset<T, SpecialOrderOfferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpecialOrderOffers and returns the data updated in the database.
     * @param {SpecialOrderOfferUpdateManyAndReturnArgs} args - Arguments to update many SpecialOrderOffers.
     * @example
     * // Update many SpecialOrderOffers
     * const specialOrderOffer = await prisma.specialOrderOffer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SpecialOrderOffers and only return the `id`
     * const specialOrderOfferWithIdOnly = await prisma.specialOrderOffer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SpecialOrderOfferUpdateManyAndReturnArgs>(args: SelectSubset<T, SpecialOrderOfferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialOrderOfferPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SpecialOrderOffer.
     * @param {SpecialOrderOfferUpsertArgs} args - Arguments to update or create a SpecialOrderOffer.
     * @example
     * // Update or create a SpecialOrderOffer
     * const specialOrderOffer = await prisma.specialOrderOffer.upsert({
     *   create: {
     *     // ... data to create a SpecialOrderOffer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpecialOrderOffer we want to update
     *   }
     * })
     */
    upsert<T extends SpecialOrderOfferUpsertArgs>(args: SelectSubset<T, SpecialOrderOfferUpsertArgs<ExtArgs>>): Prisma__SpecialOrderOfferClient<$Result.GetResult<Prisma.$SpecialOrderOfferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SpecialOrderOffers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialOrderOfferCountArgs} args - Arguments to filter SpecialOrderOffers to count.
     * @example
     * // Count the number of SpecialOrderOffers
     * const count = await prisma.specialOrderOffer.count({
     *   where: {
     *     // ... the filter for the SpecialOrderOffers we want to count
     *   }
     * })
    **/
    count<T extends SpecialOrderOfferCountArgs>(
      args?: Subset<T, SpecialOrderOfferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpecialOrderOfferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpecialOrderOffer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialOrderOfferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpecialOrderOfferAggregateArgs>(args: Subset<T, SpecialOrderOfferAggregateArgs>): Prisma.PrismaPromise<GetSpecialOrderOfferAggregateType<T>>

    /**
     * Group by SpecialOrderOffer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialOrderOfferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpecialOrderOfferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpecialOrderOfferGroupByArgs['orderBy'] }
        : { orderBy?: SpecialOrderOfferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpecialOrderOfferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpecialOrderOfferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpecialOrderOffer model
   */
  readonly fields: SpecialOrderOfferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpecialOrderOffer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpecialOrderOfferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    request<T extends SpecialOrderRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpecialOrderRequestDefaultArgs<ExtArgs>>): Prisma__SpecialOrderRequestClient<$Result.GetResult<Prisma.$SpecialOrderRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vendor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpecialOrderOffer model
   */
  interface SpecialOrderOfferFieldRefs {
    readonly id: FieldRef<"SpecialOrderOffer", 'String'>
    readonly requestId: FieldRef<"SpecialOrderOffer", 'String'>
    readonly vendorId: FieldRef<"SpecialOrderOffer", 'String'>
    readonly price: FieldRef<"SpecialOrderOffer", 'Float'>
    readonly message: FieldRef<"SpecialOrderOffer", 'String'>
    readonly status: FieldRef<"SpecialOrderOffer", 'String'>
    readonly createdAt: FieldRef<"SpecialOrderOffer", 'DateTime'>
    readonly updatedAt: FieldRef<"SpecialOrderOffer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SpecialOrderOffer findUnique
   */
  export type SpecialOrderOfferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOrderOffer
     */
    select?: SpecialOrderOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOrderOffer
     */
    omit?: SpecialOrderOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialOrderOfferInclude<ExtArgs> | null
    /**
     * Filter, which SpecialOrderOffer to fetch.
     */
    where: SpecialOrderOfferWhereUniqueInput
  }

  /**
   * SpecialOrderOffer findUniqueOrThrow
   */
  export type SpecialOrderOfferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOrderOffer
     */
    select?: SpecialOrderOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOrderOffer
     */
    omit?: SpecialOrderOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialOrderOfferInclude<ExtArgs> | null
    /**
     * Filter, which SpecialOrderOffer to fetch.
     */
    where: SpecialOrderOfferWhereUniqueInput
  }

  /**
   * SpecialOrderOffer findFirst
   */
  export type SpecialOrderOfferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOrderOffer
     */
    select?: SpecialOrderOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOrderOffer
     */
    omit?: SpecialOrderOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialOrderOfferInclude<ExtArgs> | null
    /**
     * Filter, which SpecialOrderOffer to fetch.
     */
    where?: SpecialOrderOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecialOrderOffers to fetch.
     */
    orderBy?: SpecialOrderOfferOrderByWithRelationInput | SpecialOrderOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpecialOrderOffers.
     */
    cursor?: SpecialOrderOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecialOrderOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecialOrderOffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpecialOrderOffers.
     */
    distinct?: SpecialOrderOfferScalarFieldEnum | SpecialOrderOfferScalarFieldEnum[]
  }

  /**
   * SpecialOrderOffer findFirstOrThrow
   */
  export type SpecialOrderOfferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOrderOffer
     */
    select?: SpecialOrderOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOrderOffer
     */
    omit?: SpecialOrderOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialOrderOfferInclude<ExtArgs> | null
    /**
     * Filter, which SpecialOrderOffer to fetch.
     */
    where?: SpecialOrderOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecialOrderOffers to fetch.
     */
    orderBy?: SpecialOrderOfferOrderByWithRelationInput | SpecialOrderOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpecialOrderOffers.
     */
    cursor?: SpecialOrderOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecialOrderOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecialOrderOffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpecialOrderOffers.
     */
    distinct?: SpecialOrderOfferScalarFieldEnum | SpecialOrderOfferScalarFieldEnum[]
  }

  /**
   * SpecialOrderOffer findMany
   */
  export type SpecialOrderOfferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOrderOffer
     */
    select?: SpecialOrderOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOrderOffer
     */
    omit?: SpecialOrderOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialOrderOfferInclude<ExtArgs> | null
    /**
     * Filter, which SpecialOrderOffers to fetch.
     */
    where?: SpecialOrderOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecialOrderOffers to fetch.
     */
    orderBy?: SpecialOrderOfferOrderByWithRelationInput | SpecialOrderOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpecialOrderOffers.
     */
    cursor?: SpecialOrderOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecialOrderOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecialOrderOffers.
     */
    skip?: number
    distinct?: SpecialOrderOfferScalarFieldEnum | SpecialOrderOfferScalarFieldEnum[]
  }

  /**
   * SpecialOrderOffer create
   */
  export type SpecialOrderOfferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOrderOffer
     */
    select?: SpecialOrderOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOrderOffer
     */
    omit?: SpecialOrderOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialOrderOfferInclude<ExtArgs> | null
    /**
     * The data needed to create a SpecialOrderOffer.
     */
    data: XOR<SpecialOrderOfferCreateInput, SpecialOrderOfferUncheckedCreateInput>
  }

  /**
   * SpecialOrderOffer createMany
   */
  export type SpecialOrderOfferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpecialOrderOffers.
     */
    data: SpecialOrderOfferCreateManyInput | SpecialOrderOfferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpecialOrderOffer createManyAndReturn
   */
  export type SpecialOrderOfferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOrderOffer
     */
    select?: SpecialOrderOfferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOrderOffer
     */
    omit?: SpecialOrderOfferOmit<ExtArgs> | null
    /**
     * The data used to create many SpecialOrderOffers.
     */
    data: SpecialOrderOfferCreateManyInput | SpecialOrderOfferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialOrderOfferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpecialOrderOffer update
   */
  export type SpecialOrderOfferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOrderOffer
     */
    select?: SpecialOrderOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOrderOffer
     */
    omit?: SpecialOrderOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialOrderOfferInclude<ExtArgs> | null
    /**
     * The data needed to update a SpecialOrderOffer.
     */
    data: XOR<SpecialOrderOfferUpdateInput, SpecialOrderOfferUncheckedUpdateInput>
    /**
     * Choose, which SpecialOrderOffer to update.
     */
    where: SpecialOrderOfferWhereUniqueInput
  }

  /**
   * SpecialOrderOffer updateMany
   */
  export type SpecialOrderOfferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpecialOrderOffers.
     */
    data: XOR<SpecialOrderOfferUpdateManyMutationInput, SpecialOrderOfferUncheckedUpdateManyInput>
    /**
     * Filter which SpecialOrderOffers to update
     */
    where?: SpecialOrderOfferWhereInput
    /**
     * Limit how many SpecialOrderOffers to update.
     */
    limit?: number
  }

  /**
   * SpecialOrderOffer updateManyAndReturn
   */
  export type SpecialOrderOfferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOrderOffer
     */
    select?: SpecialOrderOfferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOrderOffer
     */
    omit?: SpecialOrderOfferOmit<ExtArgs> | null
    /**
     * The data used to update SpecialOrderOffers.
     */
    data: XOR<SpecialOrderOfferUpdateManyMutationInput, SpecialOrderOfferUncheckedUpdateManyInput>
    /**
     * Filter which SpecialOrderOffers to update
     */
    where?: SpecialOrderOfferWhereInput
    /**
     * Limit how many SpecialOrderOffers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialOrderOfferIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpecialOrderOffer upsert
   */
  export type SpecialOrderOfferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOrderOffer
     */
    select?: SpecialOrderOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOrderOffer
     */
    omit?: SpecialOrderOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialOrderOfferInclude<ExtArgs> | null
    /**
     * The filter to search for the SpecialOrderOffer to update in case it exists.
     */
    where: SpecialOrderOfferWhereUniqueInput
    /**
     * In case the SpecialOrderOffer found by the `where` argument doesn't exist, create a new SpecialOrderOffer with this data.
     */
    create: XOR<SpecialOrderOfferCreateInput, SpecialOrderOfferUncheckedCreateInput>
    /**
     * In case the SpecialOrderOffer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpecialOrderOfferUpdateInput, SpecialOrderOfferUncheckedUpdateInput>
  }

  /**
   * SpecialOrderOffer delete
   */
  export type SpecialOrderOfferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOrderOffer
     */
    select?: SpecialOrderOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOrderOffer
     */
    omit?: SpecialOrderOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialOrderOfferInclude<ExtArgs> | null
    /**
     * Filter which SpecialOrderOffer to delete.
     */
    where: SpecialOrderOfferWhereUniqueInput
  }

  /**
   * SpecialOrderOffer deleteMany
   */
  export type SpecialOrderOfferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpecialOrderOffers to delete
     */
    where?: SpecialOrderOfferWhereInput
    /**
     * Limit how many SpecialOrderOffers to delete.
     */
    limit?: number
  }

  /**
   * SpecialOrderOffer without action
   */
  export type SpecialOrderOfferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOrderOffer
     */
    select?: SpecialOrderOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOrderOffer
     */
    omit?: SpecialOrderOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialOrderOfferInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    name: 'name',
    email: 'email',
    phoneNumber: 'phoneNumber',
    password: 'password',
    avatarUrl: 'avatarUrl',
    preferences: 'preferences',
    bio: 'bio',
    role: 'role',
    brandName: 'brandName',
    brandLogo: 'brandLogo',
    googleId: 'googleId',
    tokenVersion: 'tokenVersion',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    authProviders: 'authProviders',
    lastLoginAt: 'lastLoginAt',
    loginMethod: 'loginMethod',
    isEmailVerified: 'isEmailVerified',
    emailVerificationToken: 'emailVerificationToken',
    emailVerificationExpiresAt: 'emailVerificationExpiresAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    label: 'label',
    street: 'street',
    city: 'city',
    state: 'state',
    country: 'country',
    zipCode: 'zipCode',
    landmark: 'landmark',
    latitude: 'latitude',
    longitude: 'longitude',
    isDefault: 'isDefault',
    createdAt: 'createdAt'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    price: 'price',
    archived: 'archived',
    category: 'category',
    images: 'images',
    thumbnail: 'thumbnail',
    video: 'video',
    vendorId: 'vendorId',
    averageRating: 'averageRating',
    reviewCount: 'reviewCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    totalViews: 'totalViews',
    popularityScore: 'popularityScore',
    popularityUpdatedAt: 'popularityUpdatedAt',
    popularityPercent: 'popularityPercent',
    isNew: 'isNew',
    isLive: 'isLive',
    liveUntil: 'liveUntil'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProductScheduleScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    goLiveAt: 'goLiveAt',
    takeDownAt: 'takeDownAt',
    isLive: 'isLive',
    graceMinutes: 'graceMinutes',
    autoGraceEnabled: 'autoGraceEnabled',
    manualGraceEnabled: 'manualGraceEnabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScheduleScalarFieldEnum = (typeof ProductScheduleScalarFieldEnum)[keyof typeof ProductScheduleScalarFieldEnum]


  export const ProductOptionScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    name: 'name',
    price: 'price'
  };

  export type ProductOptionScalarFieldEnum = (typeof ProductOptionScalarFieldEnum)[keyof typeof ProductOptionScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    vendorId: 'vendorId',
    addressId: 'addressId',
    basePrice: 'basePrice',
    extraCharge: 'extraCharge',
    totalPrice: 'totalPrice',
    vendorNote: 'vendorNote',
    customerApproval: 'customerApproval',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    paymentInitiatedAt: 'paymentInitiatedAt',
    paymentStartedAt: 'paymentStartedAt',
    paidAt: 'paidAt',
    paymentStatus: 'paymentStatus',
    cancelledAt: 'cancelledAt',
    cancellationReason: 'cancellationReason',
    protectedUntil: 'protectedUntil',
    paymentGraceMinutes: 'paymentGraceMinutes'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    productId: 'productId',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    subtotal: 'subtotal',
    createdAt: 'createdAt'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const OrderItemOptionScalarFieldEnum: {
    id: 'id',
    optionId: 'optionId',
    name: 'name',
    price: 'price',
    orderItemId: 'orderItemId'
  };

  export type OrderItemOptionScalarFieldEnum = (typeof OrderItemOptionScalarFieldEnum)[keyof typeof OrderItemOptionScalarFieldEnum]


  export const ProductReviewScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    customerId: 'customerId',
    rating: 'rating',
    comment: 'comment',
    images: 'images',
    createdAt: 'createdAt',
    verifiedPurchase: 'verifiedPurchase'
  };

  export type ProductReviewScalarFieldEnum = (typeof ProductReviewScalarFieldEnum)[keyof typeof ProductReviewScalarFieldEnum]


  export const VendorReplyScalarFieldEnum: {
    id: 'id',
    reviewId: 'reviewId',
    vendorId: 'vendorId',
    message: 'message',
    createdAt: 'createdAt'
  };

  export type VendorReplyScalarFieldEnum = (typeof VendorReplyScalarFieldEnum)[keyof typeof VendorReplyScalarFieldEnum]


  export const ReviewVoteScalarFieldEnum: {
    id: 'id',
    reviewId: 'reviewId',
    userId: 'userId',
    isHelpful: 'isHelpful',
    createdAt: 'createdAt'
  };

  export type ReviewVoteScalarFieldEnum = (typeof ReviewVoteScalarFieldEnum)[keyof typeof ReviewVoteScalarFieldEnum]


  export const ReviewReportScalarFieldEnum: {
    id: 'id',
    reviewId: 'reviewId',
    userId: 'userId',
    reason: 'reason',
    createdAt: 'createdAt'
  };

  export type ReviewReportScalarFieldEnum = (typeof ReviewReportScalarFieldEnum)[keyof typeof ReviewReportScalarFieldEnum]


  export const VendorReviewScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    customerId: 'customerId',
    rating: 'rating',
    comment: 'comment',
    createdAt: 'createdAt'
  };

  export type VendorReviewScalarFieldEnum = (typeof VendorReviewScalarFieldEnum)[keyof typeof VendorReviewScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    message: 'message',
    type: 'type',
    metadata: 'metadata',
    read: 'read',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const LoginHistoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    method: 'method',
    deviceId: 'deviceId',
    location: 'location',
    ip: 'ip',
    userAgent: 'userAgent',
    geoCity: 'geoCity',
    geoRegion: 'geoRegion',
    geoCountry: 'geoCountry',
    createdAt: 'createdAt'
  };

  export type LoginHistoryScalarFieldEnum = (typeof LoginHistoryScalarFieldEnum)[keyof typeof LoginHistoryScalarFieldEnum]


  export const PasswordResetTokenScalarFieldEnum: {
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt'
  };

  export type PasswordResetTokenScalarFieldEnum = (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    orderId: 'orderId',
    amount: 'amount',
    reference: 'reference',
    status: 'status',
    paystackData: 'paystackData',
    channel: 'channel',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    deviceId: 'deviceId',
    geoCity: 'geoCity',
    geoCountry: 'geoCountry',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    metadata: 'metadata',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    expiresAt: 'expiresAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    deviceId: 'deviceId',
    geoCity: 'geoCity',
    geoRegion: 'geoRegion',
    geoCountry: 'geoCountry',
    details: 'details',
    path: 'path',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const RefundRequestScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    paymentRef: 'paymentRef',
    reason: 'reason',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RefundRequestScalarFieldEnum = (typeof RefundRequestScalarFieldEnum)[keyof typeof RefundRequestScalarFieldEnum]


  export const CartScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    basePrice: 'basePrice',
    totalPrice: 'totalPrice',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CartScalarFieldEnum = (typeof CartScalarFieldEnum)[keyof typeof CartScalarFieldEnum]


  export const CartItemScalarFieldEnum: {
    id: 'id',
    cartId: 'cartId',
    productId: 'productId',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    subtotal: 'subtotal',
    specialRequest: 'specialRequest'
  };

  export type CartItemScalarFieldEnum = (typeof CartItemScalarFieldEnum)[keyof typeof CartItemScalarFieldEnum]


  export const CartItemOptionScalarFieldEnum: {
    id: 'id',
    cartItemId: 'cartItemId',
    productOptionId: 'productOptionId',
    name: 'name',
    price: 'price'
  };

  export type CartItemOptionScalarFieldEnum = (typeof CartItemOptionScalarFieldEnum)[keyof typeof CartItemOptionScalarFieldEnum]


  export const UserPaymentMethodScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    cardToken: 'cardToken',
    last4: 'last4',
    brand: 'brand',
    isDefault: 'isDefault',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserPaymentMethodScalarFieldEnum = (typeof UserPaymentMethodScalarFieldEnum)[keyof typeof UserPaymentMethodScalarFieldEnum]


  export const DeliveryPersonScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    vehicleType: 'vehicleType',
    licensePlate: 'licensePlate',
    status: 'status',
    rating: 'rating',
    totalDeliveries: 'totalDeliveries',
    isOnline: 'isOnline',
    latitude: 'latitude',
    longitude: 'longitude',
    lastSeenAt: 'lastSeenAt',
    walletBalance: 'walletBalance',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeliveryPersonScalarFieldEnum = (typeof DeliveryPersonScalarFieldEnum)[keyof typeof DeliveryPersonScalarFieldEnum]


  export const DeliveryAssignmentScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    deliveryPersonId: 'deliveryPersonId',
    status: 'status',
    assignedAt: 'assignedAt',
    acceptedAt: 'acceptedAt',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    declinedAt: 'declinedAt',
    timeoutSeconds: 'timeoutSeconds',
    attempts: 'attempts',
    batchId: 'batchId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeliveryAssignmentScalarFieldEnum = (typeof DeliveryAssignmentScalarFieldEnum)[keyof typeof DeliveryAssignmentScalarFieldEnum]


  export const DeliveryEarningScalarFieldEnum: {
    id: 'id',
    deliveryPersonId: 'deliveryPersonId',
    orderId: 'orderId',
    baseFee: 'baseFee',
    distanceFee: 'distanceFee',
    tip: 'tip',
    deductions: 'deductions',
    totalEarned: 'totalEarned',
    createdAt: 'createdAt'
  };

  export type DeliveryEarningScalarFieldEnum = (typeof DeliveryEarningScalarFieldEnum)[keyof typeof DeliveryEarningScalarFieldEnum]


  export const DriverLocationLogScalarFieldEnum: {
    id: 'id',
    driverId: 'driverId',
    latitude: 'latitude',
    longitude: 'longitude',
    timestamp: 'timestamp'
  };

  export type DriverLocationLogScalarFieldEnum = (typeof DriverLocationLogScalarFieldEnum)[keyof typeof DriverLocationLogScalarFieldEnum]


  export const ActivityScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    vendorId: 'vendorId',
    customerId: 'customerId',
    deliveryId: 'deliveryId',
    type: 'type',
    title: 'title',
    message: 'message',
    meta: 'meta',
    createdAt: 'createdAt'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const DeliveryBroadcastScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    driverIds: 'driverIds',
    acceptedDriverId: 'acceptedDriverId',
    status: 'status',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeliveryBroadcastScalarFieldEnum = (typeof DeliveryBroadcastScalarFieldEnum)[keyof typeof DeliveryBroadcastScalarFieldEnum]


  export const WebhookEventScalarFieldEnum: {
    id: 'id',
    reference: 'reference',
    event: 'event',
    payload: 'payload',
    status: 'status',
    createdAt: 'createdAt',
    processedAt: 'processedAt'
  };

  export type WebhookEventScalarFieldEnum = (typeof WebhookEventScalarFieldEnum)[keyof typeof WebhookEventScalarFieldEnum]


  export const ReceiptScalarFieldEnum: {
    id: 'id',
    paymentId: 'paymentId',
    pdfUrl: 'pdfUrl',
    createdAt: 'createdAt'
  };

  export type ReceiptScalarFieldEnum = (typeof ReceiptScalarFieldEnum)[keyof typeof ReceiptScalarFieldEnum]


  export const VendorFollowerScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    customerId: 'customerId',
    createdAt: 'createdAt'
  };

  export type VendorFollowerScalarFieldEnum = (typeof VendorFollowerScalarFieldEnum)[keyof typeof VendorFollowerScalarFieldEnum]


  export const SpecialOrderRequestScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    vendorId: 'vendorId',
    productId: 'productId',
    quantity: 'quantity',
    message: 'message',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SpecialOrderRequestScalarFieldEnum = (typeof SpecialOrderRequestScalarFieldEnum)[keyof typeof SpecialOrderRequestScalarFieldEnum]


  export const SpecialOrderOfferScalarFieldEnum: {
    id: 'id',
    requestId: 'requestId',
    vendorId: 'vendorId',
    price: 'price',
    message: 'message',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SpecialOrderOfferScalarFieldEnum = (typeof SpecialOrderOfferScalarFieldEnum)[keyof typeof SpecialOrderOfferScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Category'
   */
  export type EnumCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Category'>
    


  /**
   * Reference to a field of type 'Category[]'
   */
  export type ListEnumCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Category[]'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'RefundStatus'
   */
  export type EnumRefundStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RefundStatus'>
    


  /**
   * Reference to a field of type 'RefundStatus[]'
   */
  export type ListEnumRefundStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RefundStatus[]'>
    


  /**
   * Reference to a field of type 'DeliveryStatus'
   */
  export type EnumDeliveryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeliveryStatus'>
    


  /**
   * Reference to a field of type 'DeliveryStatus[]'
   */
  export type ListEnumDeliveryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeliveryStatus[]'>
    


  /**
   * Reference to a field of type 'ActivityType'
   */
  export type EnumActivityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityType'>
    


  /**
   * Reference to a field of type 'ActivityType[]'
   */
  export type ListEnumActivityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityType[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    username?: StringNullableFilter<"User"> | string | null
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    phoneNumber?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    preferences?: StringNullableListFilter<"User">
    bio?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleNullableFilter<"User"> | $Enums.Role | null
    brandName?: StringNullableFilter<"User"> | string | null
    brandLogo?: StringNullableFilter<"User"> | string | null
    googleId?: StringNullableFilter<"User"> | string | null
    tokenVersion?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    authProviders?: StringNullableListFilter<"User">
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    loginMethod?: StringNullableFilter<"User"> | string | null
    isEmailVerified?: BoolFilter<"User"> | boolean
    emailVerificationToken?: StringNullableFilter<"User"> | string | null
    emailVerificationExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    products?: ProductListRelationFilter
    vendorReviewsReceived?: VendorReviewListRelationFilter
    vendorReviewsGiven?: VendorReviewListRelationFilter
    productReviewsGiven?: ProductReviewListRelationFilter
    customerOrders?: OrderListRelationFilter
    vendorOrders?: OrderListRelationFilter
    vendorRepliesSent?: VendorReplyListRelationFilter
    reviewVotes?: ReviewVoteListRelationFilter
    reviewReports?: ReviewReportListRelationFilter
    notifications?: NotificationListRelationFilter
    loginHistory?: LoginHistoryListRelationFilter
    addresses?: AddressListRelationFilter
    carts?: CartListRelationFilter
    UserPaymentMethod?: UserPaymentMethodListRelationFilter
    deliveryPerson?: XOR<DeliveryPersonNullableScalarRelationFilter, DeliveryPersonWhereInput> | null
    passwordResetToken?: XOR<PasswordResetTokenNullableScalarRelationFilter, PasswordResetTokenWhereInput> | null
    payments?: PaymentListRelationFilter
    RefundRequest?: RefundRequestListRelationFilter
    vendorActivities?: ActivityListRelationFilter
    customerActivities?: ActivityListRelationFilter
    followers?: VendorFollowerListRelationFilter
    following?: VendorFollowerListRelationFilter
    specialRequestsMade?: SpecialOrderRequestListRelationFilter
    specialRequestsReceived?: SpecialOrderRequestListRelationFilter
    specialOffersSent?: SpecialOrderOfferListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    preferences?: SortOrder
    bio?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    brandName?: SortOrderInput | SortOrder
    brandLogo?: SortOrderInput | SortOrder
    googleId?: SortOrderInput | SortOrder
    tokenVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authProviders?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    loginMethod?: SortOrderInput | SortOrder
    isEmailVerified?: SortOrder
    emailVerificationToken?: SortOrderInput | SortOrder
    emailVerificationExpiresAt?: SortOrderInput | SortOrder
    products?: ProductOrderByRelationAggregateInput
    vendorReviewsReceived?: VendorReviewOrderByRelationAggregateInput
    vendorReviewsGiven?: VendorReviewOrderByRelationAggregateInput
    productReviewsGiven?: ProductReviewOrderByRelationAggregateInput
    customerOrders?: OrderOrderByRelationAggregateInput
    vendorOrders?: OrderOrderByRelationAggregateInput
    vendorRepliesSent?: VendorReplyOrderByRelationAggregateInput
    reviewVotes?: ReviewVoteOrderByRelationAggregateInput
    reviewReports?: ReviewReportOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    loginHistory?: LoginHistoryOrderByRelationAggregateInput
    addresses?: AddressOrderByRelationAggregateInput
    carts?: CartOrderByRelationAggregateInput
    UserPaymentMethod?: UserPaymentMethodOrderByRelationAggregateInput
    deliveryPerson?: DeliveryPersonOrderByWithRelationInput
    passwordResetToken?: PasswordResetTokenOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
    RefundRequest?: RefundRequestOrderByRelationAggregateInput
    vendorActivities?: ActivityOrderByRelationAggregateInput
    customerActivities?: ActivityOrderByRelationAggregateInput
    followers?: VendorFollowerOrderByRelationAggregateInput
    following?: VendorFollowerOrderByRelationAggregateInput
    specialRequestsMade?: SpecialOrderRequestOrderByRelationAggregateInput
    specialRequestsReceived?: SpecialOrderRequestOrderByRelationAggregateInput
    specialOffersSent?: SpecialOrderOfferOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    googleId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    phoneNumber?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    preferences?: StringNullableListFilter<"User">
    bio?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleNullableFilter<"User"> | $Enums.Role | null
    brandName?: StringNullableFilter<"User"> | string | null
    brandLogo?: StringNullableFilter<"User"> | string | null
    tokenVersion?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    authProviders?: StringNullableListFilter<"User">
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    loginMethod?: StringNullableFilter<"User"> | string | null
    isEmailVerified?: BoolFilter<"User"> | boolean
    emailVerificationToken?: StringNullableFilter<"User"> | string | null
    emailVerificationExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    products?: ProductListRelationFilter
    vendorReviewsReceived?: VendorReviewListRelationFilter
    vendorReviewsGiven?: VendorReviewListRelationFilter
    productReviewsGiven?: ProductReviewListRelationFilter
    customerOrders?: OrderListRelationFilter
    vendorOrders?: OrderListRelationFilter
    vendorRepliesSent?: VendorReplyListRelationFilter
    reviewVotes?: ReviewVoteListRelationFilter
    reviewReports?: ReviewReportListRelationFilter
    notifications?: NotificationListRelationFilter
    loginHistory?: LoginHistoryListRelationFilter
    addresses?: AddressListRelationFilter
    carts?: CartListRelationFilter
    UserPaymentMethod?: UserPaymentMethodListRelationFilter
    deliveryPerson?: XOR<DeliveryPersonNullableScalarRelationFilter, DeliveryPersonWhereInput> | null
    passwordResetToken?: XOR<PasswordResetTokenNullableScalarRelationFilter, PasswordResetTokenWhereInput> | null
    payments?: PaymentListRelationFilter
    RefundRequest?: RefundRequestListRelationFilter
    vendorActivities?: ActivityListRelationFilter
    customerActivities?: ActivityListRelationFilter
    followers?: VendorFollowerListRelationFilter
    following?: VendorFollowerListRelationFilter
    specialRequestsMade?: SpecialOrderRequestListRelationFilter
    specialRequestsReceived?: SpecialOrderRequestListRelationFilter
    specialOffersSent?: SpecialOrderOfferListRelationFilter
  }, "id" | "username" | "email" | "googleId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    preferences?: SortOrder
    bio?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    brandName?: SortOrderInput | SortOrder
    brandLogo?: SortOrderInput | SortOrder
    googleId?: SortOrderInput | SortOrder
    tokenVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authProviders?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    loginMethod?: SortOrderInput | SortOrder
    isEmailVerified?: SortOrder
    emailVerificationToken?: SortOrderInput | SortOrder
    emailVerificationExpiresAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    preferences?: StringNullableListFilter<"User">
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleNullableWithAggregatesFilter<"User"> | $Enums.Role | null
    brandName?: StringNullableWithAggregatesFilter<"User"> | string | null
    brandLogo?: StringNullableWithAggregatesFilter<"User"> | string | null
    googleId?: StringNullableWithAggregatesFilter<"User"> | string | null
    tokenVersion?: IntWithAggregatesFilter<"User"> | number
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    authProviders?: StringNullableListFilter<"User">
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    loginMethod?: StringNullableWithAggregatesFilter<"User"> | string | null
    isEmailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    emailVerificationToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerificationExpiresAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type AddressWhereInput = {
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    id?: StringFilter<"Address"> | string
    userId?: StringFilter<"Address"> | string
    label?: StringFilter<"Address"> | string
    street?: StringFilter<"Address"> | string
    city?: StringFilter<"Address"> | string
    state?: StringNullableFilter<"Address"> | string | null
    country?: StringFilter<"Address"> | string
    zipCode?: StringNullableFilter<"Address"> | string | null
    landmark?: StringNullableFilter<"Address"> | string | null
    latitude?: FloatNullableFilter<"Address"> | number | null
    longitude?: FloatNullableFilter<"Address"> | number | null
    isDefault?: BoolFilter<"Address"> | boolean
    createdAt?: DateTimeFilter<"Address"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    orders?: OrderListRelationFilter
  }

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    label?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrder
    zipCode?: SortOrderInput | SortOrder
    landmark?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    orders?: OrderOrderByRelationAggregateInput
  }

  export type AddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    userId?: StringFilter<"Address"> | string
    label?: StringFilter<"Address"> | string
    street?: StringFilter<"Address"> | string
    city?: StringFilter<"Address"> | string
    state?: StringNullableFilter<"Address"> | string | null
    country?: StringFilter<"Address"> | string
    zipCode?: StringNullableFilter<"Address"> | string | null
    landmark?: StringNullableFilter<"Address"> | string | null
    latitude?: FloatNullableFilter<"Address"> | number | null
    longitude?: FloatNullableFilter<"Address"> | number | null
    isDefault?: BoolFilter<"Address"> | boolean
    createdAt?: DateTimeFilter<"Address"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    orders?: OrderListRelationFilter
  }, "id">

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    label?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrder
    zipCode?: SortOrderInput | SortOrder
    landmark?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    _count?: AddressCountOrderByAggregateInput
    _avg?: AddressAvgOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
    _sum?: AddressSumOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    OR?: AddressScalarWhereWithAggregatesInput[]
    NOT?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Address"> | string
    userId?: StringWithAggregatesFilter<"Address"> | string
    label?: StringWithAggregatesFilter<"Address"> | string
    street?: StringWithAggregatesFilter<"Address"> | string
    city?: StringWithAggregatesFilter<"Address"> | string
    state?: StringNullableWithAggregatesFilter<"Address"> | string | null
    country?: StringWithAggregatesFilter<"Address"> | string
    zipCode?: StringNullableWithAggregatesFilter<"Address"> | string | null
    landmark?: StringNullableWithAggregatesFilter<"Address"> | string | null
    latitude?: FloatNullableWithAggregatesFilter<"Address"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Address"> | number | null
    isDefault?: BoolWithAggregatesFilter<"Address"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    price?: FloatFilter<"Product"> | number
    archived?: BoolFilter<"Product"> | boolean
    category?: EnumCategoryFilter<"Product"> | $Enums.Category
    images?: StringNullableListFilter<"Product">
    thumbnail?: StringNullableFilter<"Product"> | string | null
    video?: StringNullableListFilter<"Product">
    vendorId?: StringFilter<"Product"> | string
    averageRating?: FloatNullableFilter<"Product"> | number | null
    reviewCount?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    totalViews?: IntFilter<"Product"> | number
    popularityScore?: FloatFilter<"Product"> | number
    popularityUpdatedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    popularityPercent?: FloatFilter<"Product"> | number
    isNew?: BoolFilter<"Product"> | boolean
    isLive?: BoolFilter<"Product"> | boolean
    liveUntil?: DateTimeNullableFilter<"Product"> | Date | string | null
    vendor?: XOR<UserScalarRelationFilter, UserWhereInput>
    reviews?: ProductReviewListRelationFilter
    orders?: OrderListRelationFilter
    orderItems?: OrderItemListRelationFilter
    options?: ProductOptionListRelationFilter
    CartItem?: CartItemListRelationFilter
    specialRequests?: SpecialOrderRequestListRelationFilter
    productSchedule?: XOR<ProductScheduleNullableScalarRelationFilter, ProductScheduleWhereInput> | null
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    archived?: SortOrder
    category?: SortOrder
    images?: SortOrder
    thumbnail?: SortOrderInput | SortOrder
    video?: SortOrder
    vendorId?: SortOrder
    averageRating?: SortOrderInput | SortOrder
    reviewCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    totalViews?: SortOrder
    popularityScore?: SortOrder
    popularityUpdatedAt?: SortOrderInput | SortOrder
    popularityPercent?: SortOrder
    isNew?: SortOrder
    isLive?: SortOrder
    liveUntil?: SortOrderInput | SortOrder
    vendor?: UserOrderByWithRelationInput
    reviews?: ProductReviewOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    orderItems?: OrderItemOrderByRelationAggregateInput
    options?: ProductOptionOrderByRelationAggregateInput
    CartItem?: CartItemOrderByRelationAggregateInput
    specialRequests?: SpecialOrderRequestOrderByRelationAggregateInput
    productSchedule?: ProductScheduleOrderByWithRelationInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    price?: FloatFilter<"Product"> | number
    archived?: BoolFilter<"Product"> | boolean
    category?: EnumCategoryFilter<"Product"> | $Enums.Category
    images?: StringNullableListFilter<"Product">
    thumbnail?: StringNullableFilter<"Product"> | string | null
    video?: StringNullableListFilter<"Product">
    vendorId?: StringFilter<"Product"> | string
    averageRating?: FloatNullableFilter<"Product"> | number | null
    reviewCount?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    totalViews?: IntFilter<"Product"> | number
    popularityScore?: FloatFilter<"Product"> | number
    popularityUpdatedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    popularityPercent?: FloatFilter<"Product"> | number
    isNew?: BoolFilter<"Product"> | boolean
    isLive?: BoolFilter<"Product"> | boolean
    liveUntil?: DateTimeNullableFilter<"Product"> | Date | string | null
    vendor?: XOR<UserScalarRelationFilter, UserWhereInput>
    reviews?: ProductReviewListRelationFilter
    orders?: OrderListRelationFilter
    orderItems?: OrderItemListRelationFilter
    options?: ProductOptionListRelationFilter
    CartItem?: CartItemListRelationFilter
    specialRequests?: SpecialOrderRequestListRelationFilter
    productSchedule?: XOR<ProductScheduleNullableScalarRelationFilter, ProductScheduleWhereInput> | null
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    archived?: SortOrder
    category?: SortOrder
    images?: SortOrder
    thumbnail?: SortOrderInput | SortOrder
    video?: SortOrder
    vendorId?: SortOrder
    averageRating?: SortOrderInput | SortOrder
    reviewCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    totalViews?: SortOrder
    popularityScore?: SortOrder
    popularityUpdatedAt?: SortOrderInput | SortOrder
    popularityPercent?: SortOrder
    isNew?: SortOrder
    isLive?: SortOrder
    liveUntil?: SortOrderInput | SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringWithAggregatesFilter<"Product"> | string
    price?: FloatWithAggregatesFilter<"Product"> | number
    archived?: BoolWithAggregatesFilter<"Product"> | boolean
    category?: EnumCategoryWithAggregatesFilter<"Product"> | $Enums.Category
    images?: StringNullableListFilter<"Product">
    thumbnail?: StringNullableWithAggregatesFilter<"Product"> | string | null
    video?: StringNullableListFilter<"Product">
    vendorId?: StringWithAggregatesFilter<"Product"> | string
    averageRating?: FloatNullableWithAggregatesFilter<"Product"> | number | null
    reviewCount?: IntWithAggregatesFilter<"Product"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    totalViews?: IntWithAggregatesFilter<"Product"> | number
    popularityScore?: FloatWithAggregatesFilter<"Product"> | number
    popularityUpdatedAt?: DateTimeNullableWithAggregatesFilter<"Product"> | Date | string | null
    popularityPercent?: FloatWithAggregatesFilter<"Product"> | number
    isNew?: BoolWithAggregatesFilter<"Product"> | boolean
    isLive?: BoolWithAggregatesFilter<"Product"> | boolean
    liveUntil?: DateTimeNullableWithAggregatesFilter<"Product"> | Date | string | null
  }

  export type ProductScheduleWhereInput = {
    AND?: ProductScheduleWhereInput | ProductScheduleWhereInput[]
    OR?: ProductScheduleWhereInput[]
    NOT?: ProductScheduleWhereInput | ProductScheduleWhereInput[]
    id?: StringFilter<"ProductSchedule"> | string
    productId?: StringFilter<"ProductSchedule"> | string
    goLiveAt?: DateTimeNullableFilter<"ProductSchedule"> | Date | string | null
    takeDownAt?: DateTimeNullableFilter<"ProductSchedule"> | Date | string | null
    isLive?: BoolFilter<"ProductSchedule"> | boolean
    graceMinutes?: IntNullableFilter<"ProductSchedule"> | number | null
    autoGraceEnabled?: BoolFilter<"ProductSchedule"> | boolean
    manualGraceEnabled?: BoolFilter<"ProductSchedule"> | boolean
    createdAt?: DateTimeFilter<"ProductSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"ProductSchedule"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ProductScheduleOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    goLiveAt?: SortOrderInput | SortOrder
    takeDownAt?: SortOrderInput | SortOrder
    isLive?: SortOrder
    graceMinutes?: SortOrderInput | SortOrder
    autoGraceEnabled?: SortOrder
    manualGraceEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type ProductScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId?: string
    AND?: ProductScheduleWhereInput | ProductScheduleWhereInput[]
    OR?: ProductScheduleWhereInput[]
    NOT?: ProductScheduleWhereInput | ProductScheduleWhereInput[]
    goLiveAt?: DateTimeNullableFilter<"ProductSchedule"> | Date | string | null
    takeDownAt?: DateTimeNullableFilter<"ProductSchedule"> | Date | string | null
    isLive?: BoolFilter<"ProductSchedule"> | boolean
    graceMinutes?: IntNullableFilter<"ProductSchedule"> | number | null
    autoGraceEnabled?: BoolFilter<"ProductSchedule"> | boolean
    manualGraceEnabled?: BoolFilter<"ProductSchedule"> | boolean
    createdAt?: DateTimeFilter<"ProductSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"ProductSchedule"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id" | "productId">

  export type ProductScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    goLiveAt?: SortOrderInput | SortOrder
    takeDownAt?: SortOrderInput | SortOrder
    isLive?: SortOrder
    graceMinutes?: SortOrderInput | SortOrder
    autoGraceEnabled?: SortOrder
    manualGraceEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductScheduleCountOrderByAggregateInput
    _avg?: ProductScheduleAvgOrderByAggregateInput
    _max?: ProductScheduleMaxOrderByAggregateInput
    _min?: ProductScheduleMinOrderByAggregateInput
    _sum?: ProductScheduleSumOrderByAggregateInput
  }

  export type ProductScheduleScalarWhereWithAggregatesInput = {
    AND?: ProductScheduleScalarWhereWithAggregatesInput | ProductScheduleScalarWhereWithAggregatesInput[]
    OR?: ProductScheduleScalarWhereWithAggregatesInput[]
    NOT?: ProductScheduleScalarWhereWithAggregatesInput | ProductScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductSchedule"> | string
    productId?: StringWithAggregatesFilter<"ProductSchedule"> | string
    goLiveAt?: DateTimeNullableWithAggregatesFilter<"ProductSchedule"> | Date | string | null
    takeDownAt?: DateTimeNullableWithAggregatesFilter<"ProductSchedule"> | Date | string | null
    isLive?: BoolWithAggregatesFilter<"ProductSchedule"> | boolean
    graceMinutes?: IntNullableWithAggregatesFilter<"ProductSchedule"> | number | null
    autoGraceEnabled?: BoolWithAggregatesFilter<"ProductSchedule"> | boolean
    manualGraceEnabled?: BoolWithAggregatesFilter<"ProductSchedule"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProductSchedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductSchedule"> | Date | string
  }

  export type ProductOptionWhereInput = {
    AND?: ProductOptionWhereInput | ProductOptionWhereInput[]
    OR?: ProductOptionWhereInput[]
    NOT?: ProductOptionWhereInput | ProductOptionWhereInput[]
    id?: StringFilter<"ProductOption"> | string
    productId?: StringFilter<"ProductOption"> | string
    name?: StringFilter<"ProductOption"> | string
    price?: FloatFilter<"ProductOption"> | number
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    OrderItemOption?: OrderItemOptionListRelationFilter
    CartItemOption?: CartItemOptionListRelationFilter
  }

  export type ProductOptionOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    product?: ProductOrderByWithRelationInput
    OrderItemOption?: OrderItemOptionOrderByRelationAggregateInput
    CartItemOption?: CartItemOptionOrderByRelationAggregateInput
  }

  export type ProductOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductOptionWhereInput | ProductOptionWhereInput[]
    OR?: ProductOptionWhereInput[]
    NOT?: ProductOptionWhereInput | ProductOptionWhereInput[]
    productId?: StringFilter<"ProductOption"> | string
    name?: StringFilter<"ProductOption"> | string
    price?: FloatFilter<"ProductOption"> | number
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    OrderItemOption?: OrderItemOptionListRelationFilter
    CartItemOption?: CartItemOptionListRelationFilter
  }, "id">

  export type ProductOptionOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    _count?: ProductOptionCountOrderByAggregateInput
    _avg?: ProductOptionAvgOrderByAggregateInput
    _max?: ProductOptionMaxOrderByAggregateInput
    _min?: ProductOptionMinOrderByAggregateInput
    _sum?: ProductOptionSumOrderByAggregateInput
  }

  export type ProductOptionScalarWhereWithAggregatesInput = {
    AND?: ProductOptionScalarWhereWithAggregatesInput | ProductOptionScalarWhereWithAggregatesInput[]
    OR?: ProductOptionScalarWhereWithAggregatesInput[]
    NOT?: ProductOptionScalarWhereWithAggregatesInput | ProductOptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductOption"> | string
    productId?: StringWithAggregatesFilter<"ProductOption"> | string
    name?: StringWithAggregatesFilter<"ProductOption"> | string
    price?: FloatWithAggregatesFilter<"ProductOption"> | number
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    customerId?: StringFilter<"Order"> | string
    vendorId?: StringFilter<"Order"> | string
    addressId?: StringNullableFilter<"Order"> | string | null
    basePrice?: FloatFilter<"Order"> | number
    extraCharge?: FloatFilter<"Order"> | number
    totalPrice?: FloatFilter<"Order"> | number
    vendorNote?: StringNullableFilter<"Order"> | string | null
    customerApproval?: BoolFilter<"Order"> | boolean
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    paymentInitiatedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    paymentStartedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    paymentStatus?: EnumPaymentStatusNullableFilter<"Order"> | $Enums.PaymentStatus | null
    cancelledAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    cancellationReason?: StringNullableFilter<"Order"> | string | null
    protectedUntil?: DateTimeNullableFilter<"Order"> | Date | string | null
    paymentGraceMinutes?: IntNullableFilter<"Order"> | number | null
    customer?: XOR<UserScalarRelationFilter, UserWhereInput>
    vendor?: XOR<UserScalarRelationFilter, UserWhereInput>
    address?: XOR<AddressNullableScalarRelationFilter, AddressWhereInput> | null
    items?: OrderItemListRelationFilter
    payments?: PaymentListRelationFilter
    Product?: ProductListRelationFilter
    assignments?: DeliveryAssignmentListRelationFilter
    earnings?: DeliveryEarningListRelationFilter
    Activity?: ActivityListRelationFilter
    DeliveryBroadcast?: DeliveryBroadcastListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    vendorId?: SortOrder
    addressId?: SortOrderInput | SortOrder
    basePrice?: SortOrder
    extraCharge?: SortOrder
    totalPrice?: SortOrder
    vendorNote?: SortOrderInput | SortOrder
    customerApproval?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentInitiatedAt?: SortOrderInput | SortOrder
    paymentStartedAt?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    paymentStatus?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancellationReason?: SortOrderInput | SortOrder
    protectedUntil?: SortOrderInput | SortOrder
    paymentGraceMinutes?: SortOrderInput | SortOrder
    customer?: UserOrderByWithRelationInput
    vendor?: UserOrderByWithRelationInput
    address?: AddressOrderByWithRelationInput
    items?: OrderItemOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    Product?: ProductOrderByRelationAggregateInput
    assignments?: DeliveryAssignmentOrderByRelationAggregateInput
    earnings?: DeliveryEarningOrderByRelationAggregateInput
    Activity?: ActivityOrderByRelationAggregateInput
    DeliveryBroadcast?: DeliveryBroadcastOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    customerId?: StringFilter<"Order"> | string
    vendorId?: StringFilter<"Order"> | string
    addressId?: StringNullableFilter<"Order"> | string | null
    basePrice?: FloatFilter<"Order"> | number
    extraCharge?: FloatFilter<"Order"> | number
    totalPrice?: FloatFilter<"Order"> | number
    vendorNote?: StringNullableFilter<"Order"> | string | null
    customerApproval?: BoolFilter<"Order"> | boolean
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    paymentInitiatedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    paymentStartedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    paymentStatus?: EnumPaymentStatusNullableFilter<"Order"> | $Enums.PaymentStatus | null
    cancelledAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    cancellationReason?: StringNullableFilter<"Order"> | string | null
    protectedUntil?: DateTimeNullableFilter<"Order"> | Date | string | null
    paymentGraceMinutes?: IntNullableFilter<"Order"> | number | null
    customer?: XOR<UserScalarRelationFilter, UserWhereInput>
    vendor?: XOR<UserScalarRelationFilter, UserWhereInput>
    address?: XOR<AddressNullableScalarRelationFilter, AddressWhereInput> | null
    items?: OrderItemListRelationFilter
    payments?: PaymentListRelationFilter
    Product?: ProductListRelationFilter
    assignments?: DeliveryAssignmentListRelationFilter
    earnings?: DeliveryEarningListRelationFilter
    Activity?: ActivityListRelationFilter
    DeliveryBroadcast?: DeliveryBroadcastListRelationFilter
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    vendorId?: SortOrder
    addressId?: SortOrderInput | SortOrder
    basePrice?: SortOrder
    extraCharge?: SortOrder
    totalPrice?: SortOrder
    vendorNote?: SortOrderInput | SortOrder
    customerApproval?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentInitiatedAt?: SortOrderInput | SortOrder
    paymentStartedAt?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    paymentStatus?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancellationReason?: SortOrderInput | SortOrder
    protectedUntil?: SortOrderInput | SortOrder
    paymentGraceMinutes?: SortOrderInput | SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    customerId?: StringWithAggregatesFilter<"Order"> | string
    vendorId?: StringWithAggregatesFilter<"Order"> | string
    addressId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    basePrice?: FloatWithAggregatesFilter<"Order"> | number
    extraCharge?: FloatWithAggregatesFilter<"Order"> | number
    totalPrice?: FloatWithAggregatesFilter<"Order"> | number
    vendorNote?: StringNullableWithAggregatesFilter<"Order"> | string | null
    customerApproval?: BoolWithAggregatesFilter<"Order"> | boolean
    status?: EnumOrderStatusWithAggregatesFilter<"Order"> | $Enums.OrderStatus
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    paymentInitiatedAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    paymentStartedAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    paidAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    paymentStatus?: EnumPaymentStatusNullableWithAggregatesFilter<"Order"> | $Enums.PaymentStatus | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    cancellationReason?: StringNullableWithAggregatesFilter<"Order"> | string | null
    protectedUntil?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    paymentGraceMinutes?: IntNullableWithAggregatesFilter<"Order"> | number | null
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    unitPrice?: FloatFilter<"OrderItem"> | number
    subtotal?: FloatFilter<"OrderItem"> | number
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    options?: OrderItemOptionListRelationFilter
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
    createdAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    options?: OrderItemOptionOrderByRelationAggregateInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    unitPrice?: FloatFilter<"OrderItem"> | number
    subtotal?: FloatFilter<"OrderItem"> | number
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    options?: OrderItemOptionListRelationFilter
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
    createdAt?: SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderItem"> | string
    orderId?: StringWithAggregatesFilter<"OrderItem"> | string
    productId?: StringWithAggregatesFilter<"OrderItem"> | string
    quantity?: IntWithAggregatesFilter<"OrderItem"> | number
    unitPrice?: FloatWithAggregatesFilter<"OrderItem"> | number
    subtotal?: FloatWithAggregatesFilter<"OrderItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
  }

  export type OrderItemOptionWhereInput = {
    AND?: OrderItemOptionWhereInput | OrderItemOptionWhereInput[]
    OR?: OrderItemOptionWhereInput[]
    NOT?: OrderItemOptionWhereInput | OrderItemOptionWhereInput[]
    id?: StringFilter<"OrderItemOption"> | string
    optionId?: StringFilter<"OrderItemOption"> | string
    name?: StringFilter<"OrderItemOption"> | string
    price?: FloatFilter<"OrderItemOption"> | number
    orderItemId?: StringFilter<"OrderItemOption"> | string
    orderItem?: XOR<OrderItemScalarRelationFilter, OrderItemWhereInput>
    productOption?: XOR<ProductOptionScalarRelationFilter, ProductOptionWhereInput>
  }

  export type OrderItemOptionOrderByWithRelationInput = {
    id?: SortOrder
    optionId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    orderItemId?: SortOrder
    orderItem?: OrderItemOrderByWithRelationInput
    productOption?: ProductOptionOrderByWithRelationInput
  }

  export type OrderItemOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderItemOptionWhereInput | OrderItemOptionWhereInput[]
    OR?: OrderItemOptionWhereInput[]
    NOT?: OrderItemOptionWhereInput | OrderItemOptionWhereInput[]
    optionId?: StringFilter<"OrderItemOption"> | string
    name?: StringFilter<"OrderItemOption"> | string
    price?: FloatFilter<"OrderItemOption"> | number
    orderItemId?: StringFilter<"OrderItemOption"> | string
    orderItem?: XOR<OrderItemScalarRelationFilter, OrderItemWhereInput>
    productOption?: XOR<ProductOptionScalarRelationFilter, ProductOptionWhereInput>
  }, "id">

  export type OrderItemOptionOrderByWithAggregationInput = {
    id?: SortOrder
    optionId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    orderItemId?: SortOrder
    _count?: OrderItemOptionCountOrderByAggregateInput
    _avg?: OrderItemOptionAvgOrderByAggregateInput
    _max?: OrderItemOptionMaxOrderByAggregateInput
    _min?: OrderItemOptionMinOrderByAggregateInput
    _sum?: OrderItemOptionSumOrderByAggregateInput
  }

  export type OrderItemOptionScalarWhereWithAggregatesInput = {
    AND?: OrderItemOptionScalarWhereWithAggregatesInput | OrderItemOptionScalarWhereWithAggregatesInput[]
    OR?: OrderItemOptionScalarWhereWithAggregatesInput[]
    NOT?: OrderItemOptionScalarWhereWithAggregatesInput | OrderItemOptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderItemOption"> | string
    optionId?: StringWithAggregatesFilter<"OrderItemOption"> | string
    name?: StringWithAggregatesFilter<"OrderItemOption"> | string
    price?: FloatWithAggregatesFilter<"OrderItemOption"> | number
    orderItemId?: StringWithAggregatesFilter<"OrderItemOption"> | string
  }

  export type ProductReviewWhereInput = {
    AND?: ProductReviewWhereInput | ProductReviewWhereInput[]
    OR?: ProductReviewWhereInput[]
    NOT?: ProductReviewWhereInput | ProductReviewWhereInput[]
    id?: StringFilter<"ProductReview"> | string
    productId?: StringFilter<"ProductReview"> | string
    customerId?: StringFilter<"ProductReview"> | string
    rating?: IntFilter<"ProductReview"> | number
    comment?: StringNullableFilter<"ProductReview"> | string | null
    images?: StringNullableListFilter<"ProductReview">
    createdAt?: DateTimeFilter<"ProductReview"> | Date | string
    verifiedPurchase?: BoolFilter<"ProductReview"> | boolean
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    customer?: XOR<UserScalarRelationFilter, UserWhereInput>
    reply?: XOR<VendorReplyNullableScalarRelationFilter, VendorReplyWhereInput> | null
    votes?: ReviewVoteListRelationFilter
    reports?: ReviewReportListRelationFilter
  }

  export type ProductReviewOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    customerId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    images?: SortOrder
    createdAt?: SortOrder
    verifiedPurchase?: SortOrder
    product?: ProductOrderByWithRelationInput
    customer?: UserOrderByWithRelationInput
    reply?: VendorReplyOrderByWithRelationInput
    votes?: ReviewVoteOrderByRelationAggregateInput
    reports?: ReviewReportOrderByRelationAggregateInput
  }

  export type ProductReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductReviewWhereInput | ProductReviewWhereInput[]
    OR?: ProductReviewWhereInput[]
    NOT?: ProductReviewWhereInput | ProductReviewWhereInput[]
    productId?: StringFilter<"ProductReview"> | string
    customerId?: StringFilter<"ProductReview"> | string
    rating?: IntFilter<"ProductReview"> | number
    comment?: StringNullableFilter<"ProductReview"> | string | null
    images?: StringNullableListFilter<"ProductReview">
    createdAt?: DateTimeFilter<"ProductReview"> | Date | string
    verifiedPurchase?: BoolFilter<"ProductReview"> | boolean
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    customer?: XOR<UserScalarRelationFilter, UserWhereInput>
    reply?: XOR<VendorReplyNullableScalarRelationFilter, VendorReplyWhereInput> | null
    votes?: ReviewVoteListRelationFilter
    reports?: ReviewReportListRelationFilter
  }, "id">

  export type ProductReviewOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    customerId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    images?: SortOrder
    createdAt?: SortOrder
    verifiedPurchase?: SortOrder
    _count?: ProductReviewCountOrderByAggregateInput
    _avg?: ProductReviewAvgOrderByAggregateInput
    _max?: ProductReviewMaxOrderByAggregateInput
    _min?: ProductReviewMinOrderByAggregateInput
    _sum?: ProductReviewSumOrderByAggregateInput
  }

  export type ProductReviewScalarWhereWithAggregatesInput = {
    AND?: ProductReviewScalarWhereWithAggregatesInput | ProductReviewScalarWhereWithAggregatesInput[]
    OR?: ProductReviewScalarWhereWithAggregatesInput[]
    NOT?: ProductReviewScalarWhereWithAggregatesInput | ProductReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductReview"> | string
    productId?: StringWithAggregatesFilter<"ProductReview"> | string
    customerId?: StringWithAggregatesFilter<"ProductReview"> | string
    rating?: IntWithAggregatesFilter<"ProductReview"> | number
    comment?: StringNullableWithAggregatesFilter<"ProductReview"> | string | null
    images?: StringNullableListFilter<"ProductReview">
    createdAt?: DateTimeWithAggregatesFilter<"ProductReview"> | Date | string
    verifiedPurchase?: BoolWithAggregatesFilter<"ProductReview"> | boolean
  }

  export type VendorReplyWhereInput = {
    AND?: VendorReplyWhereInput | VendorReplyWhereInput[]
    OR?: VendorReplyWhereInput[]
    NOT?: VendorReplyWhereInput | VendorReplyWhereInput[]
    id?: StringFilter<"VendorReply"> | string
    reviewId?: StringFilter<"VendorReply"> | string
    vendorId?: StringFilter<"VendorReply"> | string
    message?: StringFilter<"VendorReply"> | string
    createdAt?: DateTimeFilter<"VendorReply"> | Date | string
    review?: XOR<ProductReviewScalarRelationFilter, ProductReviewWhereInput>
    vendor?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type VendorReplyOrderByWithRelationInput = {
    id?: SortOrder
    reviewId?: SortOrder
    vendorId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    review?: ProductReviewOrderByWithRelationInput
    vendor?: UserOrderByWithRelationInput
  }

  export type VendorReplyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    reviewId?: string
    AND?: VendorReplyWhereInput | VendorReplyWhereInput[]
    OR?: VendorReplyWhereInput[]
    NOT?: VendorReplyWhereInput | VendorReplyWhereInput[]
    vendorId?: StringFilter<"VendorReply"> | string
    message?: StringFilter<"VendorReply"> | string
    createdAt?: DateTimeFilter<"VendorReply"> | Date | string
    review?: XOR<ProductReviewScalarRelationFilter, ProductReviewWhereInput>
    vendor?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "reviewId">

  export type VendorReplyOrderByWithAggregationInput = {
    id?: SortOrder
    reviewId?: SortOrder
    vendorId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    _count?: VendorReplyCountOrderByAggregateInput
    _max?: VendorReplyMaxOrderByAggregateInput
    _min?: VendorReplyMinOrderByAggregateInput
  }

  export type VendorReplyScalarWhereWithAggregatesInput = {
    AND?: VendorReplyScalarWhereWithAggregatesInput | VendorReplyScalarWhereWithAggregatesInput[]
    OR?: VendorReplyScalarWhereWithAggregatesInput[]
    NOT?: VendorReplyScalarWhereWithAggregatesInput | VendorReplyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VendorReply"> | string
    reviewId?: StringWithAggregatesFilter<"VendorReply"> | string
    vendorId?: StringWithAggregatesFilter<"VendorReply"> | string
    message?: StringWithAggregatesFilter<"VendorReply"> | string
    createdAt?: DateTimeWithAggregatesFilter<"VendorReply"> | Date | string
  }

  export type ReviewVoteWhereInput = {
    AND?: ReviewVoteWhereInput | ReviewVoteWhereInput[]
    OR?: ReviewVoteWhereInput[]
    NOT?: ReviewVoteWhereInput | ReviewVoteWhereInput[]
    id?: StringFilter<"ReviewVote"> | string
    reviewId?: StringFilter<"ReviewVote"> | string
    userId?: StringFilter<"ReviewVote"> | string
    isHelpful?: BoolFilter<"ReviewVote"> | boolean
    createdAt?: DateTimeFilter<"ReviewVote"> | Date | string
    review?: XOR<ProductReviewScalarRelationFilter, ProductReviewWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReviewVoteOrderByWithRelationInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    isHelpful?: SortOrder
    createdAt?: SortOrder
    review?: ProductReviewOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ReviewVoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    reviewId_userId?: ReviewVoteReviewIdUserIdCompoundUniqueInput
    AND?: ReviewVoteWhereInput | ReviewVoteWhereInput[]
    OR?: ReviewVoteWhereInput[]
    NOT?: ReviewVoteWhereInput | ReviewVoteWhereInput[]
    reviewId?: StringFilter<"ReviewVote"> | string
    userId?: StringFilter<"ReviewVote"> | string
    isHelpful?: BoolFilter<"ReviewVote"> | boolean
    createdAt?: DateTimeFilter<"ReviewVote"> | Date | string
    review?: XOR<ProductReviewScalarRelationFilter, ProductReviewWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "reviewId_userId">

  export type ReviewVoteOrderByWithAggregationInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    isHelpful?: SortOrder
    createdAt?: SortOrder
    _count?: ReviewVoteCountOrderByAggregateInput
    _max?: ReviewVoteMaxOrderByAggregateInput
    _min?: ReviewVoteMinOrderByAggregateInput
  }

  export type ReviewVoteScalarWhereWithAggregatesInput = {
    AND?: ReviewVoteScalarWhereWithAggregatesInput | ReviewVoteScalarWhereWithAggregatesInput[]
    OR?: ReviewVoteScalarWhereWithAggregatesInput[]
    NOT?: ReviewVoteScalarWhereWithAggregatesInput | ReviewVoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReviewVote"> | string
    reviewId?: StringWithAggregatesFilter<"ReviewVote"> | string
    userId?: StringWithAggregatesFilter<"ReviewVote"> | string
    isHelpful?: BoolWithAggregatesFilter<"ReviewVote"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ReviewVote"> | Date | string
  }

  export type ReviewReportWhereInput = {
    AND?: ReviewReportWhereInput | ReviewReportWhereInput[]
    OR?: ReviewReportWhereInput[]
    NOT?: ReviewReportWhereInput | ReviewReportWhereInput[]
    id?: StringFilter<"ReviewReport"> | string
    reviewId?: StringFilter<"ReviewReport"> | string
    userId?: StringFilter<"ReviewReport"> | string
    reason?: StringFilter<"ReviewReport"> | string
    createdAt?: DateTimeFilter<"ReviewReport"> | Date | string
    review?: XOR<ProductReviewScalarRelationFilter, ProductReviewWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReviewReportOrderByWithRelationInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    review?: ProductReviewOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ReviewReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReviewReportWhereInput | ReviewReportWhereInput[]
    OR?: ReviewReportWhereInput[]
    NOT?: ReviewReportWhereInput | ReviewReportWhereInput[]
    reviewId?: StringFilter<"ReviewReport"> | string
    userId?: StringFilter<"ReviewReport"> | string
    reason?: StringFilter<"ReviewReport"> | string
    createdAt?: DateTimeFilter<"ReviewReport"> | Date | string
    review?: XOR<ProductReviewScalarRelationFilter, ProductReviewWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ReviewReportOrderByWithAggregationInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    _count?: ReviewReportCountOrderByAggregateInput
    _max?: ReviewReportMaxOrderByAggregateInput
    _min?: ReviewReportMinOrderByAggregateInput
  }

  export type ReviewReportScalarWhereWithAggregatesInput = {
    AND?: ReviewReportScalarWhereWithAggregatesInput | ReviewReportScalarWhereWithAggregatesInput[]
    OR?: ReviewReportScalarWhereWithAggregatesInput[]
    NOT?: ReviewReportScalarWhereWithAggregatesInput | ReviewReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReviewReport"> | string
    reviewId?: StringWithAggregatesFilter<"ReviewReport"> | string
    userId?: StringWithAggregatesFilter<"ReviewReport"> | string
    reason?: StringWithAggregatesFilter<"ReviewReport"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ReviewReport"> | Date | string
  }

  export type VendorReviewWhereInput = {
    AND?: VendorReviewWhereInput | VendorReviewWhereInput[]
    OR?: VendorReviewWhereInput[]
    NOT?: VendorReviewWhereInput | VendorReviewWhereInput[]
    id?: StringFilter<"VendorReview"> | string
    vendorId?: StringFilter<"VendorReview"> | string
    customerId?: StringFilter<"VendorReview"> | string
    rating?: IntFilter<"VendorReview"> | number
    comment?: StringNullableFilter<"VendorReview"> | string | null
    createdAt?: DateTimeFilter<"VendorReview"> | Date | string
    vendor?: XOR<UserScalarRelationFilter, UserWhereInput>
    customer?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type VendorReviewOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    customerId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    vendor?: UserOrderByWithRelationInput
    customer?: UserOrderByWithRelationInput
  }

  export type VendorReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VendorReviewWhereInput | VendorReviewWhereInput[]
    OR?: VendorReviewWhereInput[]
    NOT?: VendorReviewWhereInput | VendorReviewWhereInput[]
    vendorId?: StringFilter<"VendorReview"> | string
    customerId?: StringFilter<"VendorReview"> | string
    rating?: IntFilter<"VendorReview"> | number
    comment?: StringNullableFilter<"VendorReview"> | string | null
    createdAt?: DateTimeFilter<"VendorReview"> | Date | string
    vendor?: XOR<UserScalarRelationFilter, UserWhereInput>
    customer?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type VendorReviewOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    customerId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: VendorReviewCountOrderByAggregateInput
    _avg?: VendorReviewAvgOrderByAggregateInput
    _max?: VendorReviewMaxOrderByAggregateInput
    _min?: VendorReviewMinOrderByAggregateInput
    _sum?: VendorReviewSumOrderByAggregateInput
  }

  export type VendorReviewScalarWhereWithAggregatesInput = {
    AND?: VendorReviewScalarWhereWithAggregatesInput | VendorReviewScalarWhereWithAggregatesInput[]
    OR?: VendorReviewScalarWhereWithAggregatesInput[]
    NOT?: VendorReviewScalarWhereWithAggregatesInput | VendorReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VendorReview"> | string
    vendorId?: StringWithAggregatesFilter<"VendorReview"> | string
    customerId?: StringWithAggregatesFilter<"VendorReview"> | string
    rating?: IntWithAggregatesFilter<"VendorReview"> | number
    comment?: StringNullableWithAggregatesFilter<"VendorReview"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VendorReview"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    metadata?: JsonNullableFilter<"Notification">
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    metadata?: SortOrderInput | SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    metadata?: JsonNullableFilter<"Notification">
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    metadata?: SortOrderInput | SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    metadata?: JsonNullableWithAggregatesFilter<"Notification">
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type LoginHistoryWhereInput = {
    AND?: LoginHistoryWhereInput | LoginHistoryWhereInput[]
    OR?: LoginHistoryWhereInput[]
    NOT?: LoginHistoryWhereInput | LoginHistoryWhereInput[]
    id?: StringFilter<"LoginHistory"> | string
    userId?: StringFilter<"LoginHistory"> | string
    method?: StringFilter<"LoginHistory"> | string
    deviceId?: StringNullableFilter<"LoginHistory"> | string | null
    location?: StringNullableFilter<"LoginHistory"> | string | null
    ip?: StringNullableFilter<"LoginHistory"> | string | null
    userAgent?: StringNullableFilter<"LoginHistory"> | string | null
    geoCity?: StringNullableFilter<"LoginHistory"> | string | null
    geoRegion?: StringNullableFilter<"LoginHistory"> | string | null
    geoCountry?: StringNullableFilter<"LoginHistory"> | string | null
    createdAt?: DateTimeFilter<"LoginHistory"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LoginHistoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    method?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    geoCity?: SortOrderInput | SortOrder
    geoRegion?: SortOrderInput | SortOrder
    geoCountry?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LoginHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LoginHistoryWhereInput | LoginHistoryWhereInput[]
    OR?: LoginHistoryWhereInput[]
    NOT?: LoginHistoryWhereInput | LoginHistoryWhereInput[]
    userId?: StringFilter<"LoginHistory"> | string
    method?: StringFilter<"LoginHistory"> | string
    deviceId?: StringNullableFilter<"LoginHistory"> | string | null
    location?: StringNullableFilter<"LoginHistory"> | string | null
    ip?: StringNullableFilter<"LoginHistory"> | string | null
    userAgent?: StringNullableFilter<"LoginHistory"> | string | null
    geoCity?: StringNullableFilter<"LoginHistory"> | string | null
    geoRegion?: StringNullableFilter<"LoginHistory"> | string | null
    geoCountry?: StringNullableFilter<"LoginHistory"> | string | null
    createdAt?: DateTimeFilter<"LoginHistory"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type LoginHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    method?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    geoCity?: SortOrderInput | SortOrder
    geoRegion?: SortOrderInput | SortOrder
    geoCountry?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LoginHistoryCountOrderByAggregateInput
    _max?: LoginHistoryMaxOrderByAggregateInput
    _min?: LoginHistoryMinOrderByAggregateInput
  }

  export type LoginHistoryScalarWhereWithAggregatesInput = {
    AND?: LoginHistoryScalarWhereWithAggregatesInput | LoginHistoryScalarWhereWithAggregatesInput[]
    OR?: LoginHistoryScalarWhereWithAggregatesInput[]
    NOT?: LoginHistoryScalarWhereWithAggregatesInput | LoginHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LoginHistory"> | string
    userId?: StringWithAggregatesFilter<"LoginHistory"> | string
    method?: StringWithAggregatesFilter<"LoginHistory"> | string
    deviceId?: StringNullableWithAggregatesFilter<"LoginHistory"> | string | null
    location?: StringNullableWithAggregatesFilter<"LoginHistory"> | string | null
    ip?: StringNullableWithAggregatesFilter<"LoginHistory"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"LoginHistory"> | string | null
    geoCity?: StringNullableWithAggregatesFilter<"LoginHistory"> | string | null
    geoRegion?: StringNullableWithAggregatesFilter<"LoginHistory"> | string | null
    geoCountry?: StringNullableWithAggregatesFilter<"LoginHistory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LoginHistory"> | Date | string
  }

  export type PasswordResetTokenWhereInput = {
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    userId?: StringFilter<"PasswordResetToken"> | string
    token?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PasswordResetTokenOrderByWithRelationInput = {
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PasswordResetTokenWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    token?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "userId">

  export type PasswordResetTokenOrderByWithAggregationInput = {
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    _count?: PasswordResetTokenCountOrderByAggregateInput
    _max?: PasswordResetTokenMaxOrderByAggregateInput
    _min?: PasswordResetTokenMinOrderByAggregateInput
  }

  export type PasswordResetTokenScalarWhereWithAggregatesInput = {
    AND?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    OR?: PasswordResetTokenScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    token?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    orderId?: StringFilter<"Payment"> | string
    amount?: IntFilter<"Payment"> | number
    reference?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    paystackData?: JsonNullableFilter<"Payment">
    channel?: StringNullableFilter<"Payment"> | string | null
    ipAddress?: StringFilter<"Payment"> | string
    userAgent?: StringFilter<"Payment"> | string
    deviceId?: StringNullableFilter<"Payment"> | string | null
    geoCity?: StringNullableFilter<"Payment"> | string | null
    geoCountry?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    metadata?: JsonNullableFilter<"Payment">
    startedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    Receipt?: ReceiptListRelationFilter
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    paystackData?: SortOrderInput | SortOrder
    channel?: SortOrderInput | SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    geoCity?: SortOrderInput | SortOrder
    geoCountry?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
    Receipt?: ReceiptOrderByRelationAggregateInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    reference?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    userId?: StringFilter<"Payment"> | string
    orderId?: StringFilter<"Payment"> | string
    amount?: IntFilter<"Payment"> | number
    status?: StringFilter<"Payment"> | string
    paystackData?: JsonNullableFilter<"Payment">
    channel?: StringNullableFilter<"Payment"> | string | null
    ipAddress?: StringFilter<"Payment"> | string
    userAgent?: StringFilter<"Payment"> | string
    deviceId?: StringNullableFilter<"Payment"> | string | null
    geoCity?: StringNullableFilter<"Payment"> | string | null
    geoCountry?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    metadata?: JsonNullableFilter<"Payment">
    startedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    Receipt?: ReceiptListRelationFilter
  }, "id" | "reference">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    paystackData?: SortOrderInput | SortOrder
    channel?: SortOrderInput | SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    geoCity?: SortOrderInput | SortOrder
    geoCountry?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    userId?: StringWithAggregatesFilter<"Payment"> | string
    orderId?: StringWithAggregatesFilter<"Payment"> | string
    amount?: IntWithAggregatesFilter<"Payment"> | number
    reference?: StringWithAggregatesFilter<"Payment"> | string
    status?: StringWithAggregatesFilter<"Payment"> | string
    paystackData?: JsonNullableWithAggregatesFilter<"Payment">
    channel?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    ipAddress?: StringWithAggregatesFilter<"Payment"> | string
    userAgent?: StringWithAggregatesFilter<"Payment"> | string
    deviceId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    geoCity?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    geoCountry?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"Payment">
    startedAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    ipAddress?: StringFilter<"AuditLog"> | string
    userAgent?: StringFilter<"AuditLog"> | string
    deviceId?: StringNullableFilter<"AuditLog"> | string | null
    geoCity?: StringNullableFilter<"AuditLog"> | string | null
    geoRegion?: StringNullableFilter<"AuditLog"> | string | null
    geoCountry?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    path?: StringFilter<"AuditLog"> | string
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    geoCity?: SortOrderInput | SortOrder
    geoRegion?: SortOrderInput | SortOrder
    geoCountry?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    path?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    ipAddress?: StringFilter<"AuditLog"> | string
    userAgent?: StringFilter<"AuditLog"> | string
    deviceId?: StringNullableFilter<"AuditLog"> | string | null
    geoCity?: StringNullableFilter<"AuditLog"> | string | null
    geoRegion?: StringNullableFilter<"AuditLog"> | string | null
    geoCountry?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    path?: StringFilter<"AuditLog"> | string
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    geoCity?: SortOrderInput | SortOrder
    geoRegion?: SortOrderInput | SortOrder
    geoCountry?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    path?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    ipAddress?: StringWithAggregatesFilter<"AuditLog"> | string
    userAgent?: StringWithAggregatesFilter<"AuditLog"> | string
    deviceId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    geoCity?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    geoRegion?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    geoCountry?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    details?: JsonNullableWithAggregatesFilter<"AuditLog">
    path?: StringWithAggregatesFilter<"AuditLog"> | string
    metadata?: JsonNullableWithAggregatesFilter<"AuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type RefundRequestWhereInput = {
    AND?: RefundRequestWhereInput | RefundRequestWhereInput[]
    OR?: RefundRequestWhereInput[]
    NOT?: RefundRequestWhereInput | RefundRequestWhereInput[]
    id?: StringFilter<"RefundRequest"> | string
    userId?: StringFilter<"RefundRequest"> | string
    paymentRef?: StringFilter<"RefundRequest"> | string
    reason?: StringFilter<"RefundRequest"> | string
    status?: EnumRefundStatusFilter<"RefundRequest"> | $Enums.RefundStatus
    createdAt?: DateTimeFilter<"RefundRequest"> | Date | string
    updatedAt?: DateTimeFilter<"RefundRequest"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RefundRequestOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    paymentRef?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefundRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RefundRequestWhereInput | RefundRequestWhereInput[]
    OR?: RefundRequestWhereInput[]
    NOT?: RefundRequestWhereInput | RefundRequestWhereInput[]
    userId?: StringFilter<"RefundRequest"> | string
    paymentRef?: StringFilter<"RefundRequest"> | string
    reason?: StringFilter<"RefundRequest"> | string
    status?: EnumRefundStatusFilter<"RefundRequest"> | $Enums.RefundStatus
    createdAt?: DateTimeFilter<"RefundRequest"> | Date | string
    updatedAt?: DateTimeFilter<"RefundRequest"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type RefundRequestOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    paymentRef?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RefundRequestCountOrderByAggregateInput
    _max?: RefundRequestMaxOrderByAggregateInput
    _min?: RefundRequestMinOrderByAggregateInput
  }

  export type RefundRequestScalarWhereWithAggregatesInput = {
    AND?: RefundRequestScalarWhereWithAggregatesInput | RefundRequestScalarWhereWithAggregatesInput[]
    OR?: RefundRequestScalarWhereWithAggregatesInput[]
    NOT?: RefundRequestScalarWhereWithAggregatesInput | RefundRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefundRequest"> | string
    userId?: StringWithAggregatesFilter<"RefundRequest"> | string
    paymentRef?: StringWithAggregatesFilter<"RefundRequest"> | string
    reason?: StringWithAggregatesFilter<"RefundRequest"> | string
    status?: EnumRefundStatusWithAggregatesFilter<"RefundRequest"> | $Enums.RefundStatus
    createdAt?: DateTimeWithAggregatesFilter<"RefundRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RefundRequest"> | Date | string
  }

  export type CartWhereInput = {
    AND?: CartWhereInput | CartWhereInput[]
    OR?: CartWhereInput[]
    NOT?: CartWhereInput | CartWhereInput[]
    id?: StringFilter<"Cart"> | string
    customerId?: StringFilter<"Cart"> | string
    basePrice?: FloatFilter<"Cart"> | number
    totalPrice?: FloatFilter<"Cart"> | number
    createdAt?: DateTimeFilter<"Cart"> | Date | string
    updatedAt?: DateTimeFilter<"Cart"> | Date | string
    customer?: XOR<UserScalarRelationFilter, UserWhereInput>
    items?: CartItemListRelationFilter
  }

  export type CartOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    basePrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: UserOrderByWithRelationInput
    items?: CartItemOrderByRelationAggregateInput
  }

  export type CartWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CartWhereInput | CartWhereInput[]
    OR?: CartWhereInput[]
    NOT?: CartWhereInput | CartWhereInput[]
    customerId?: StringFilter<"Cart"> | string
    basePrice?: FloatFilter<"Cart"> | number
    totalPrice?: FloatFilter<"Cart"> | number
    createdAt?: DateTimeFilter<"Cart"> | Date | string
    updatedAt?: DateTimeFilter<"Cart"> | Date | string
    customer?: XOR<UserScalarRelationFilter, UserWhereInput>
    items?: CartItemListRelationFilter
  }, "id">

  export type CartOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    basePrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CartCountOrderByAggregateInput
    _avg?: CartAvgOrderByAggregateInput
    _max?: CartMaxOrderByAggregateInput
    _min?: CartMinOrderByAggregateInput
    _sum?: CartSumOrderByAggregateInput
  }

  export type CartScalarWhereWithAggregatesInput = {
    AND?: CartScalarWhereWithAggregatesInput | CartScalarWhereWithAggregatesInput[]
    OR?: CartScalarWhereWithAggregatesInput[]
    NOT?: CartScalarWhereWithAggregatesInput | CartScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Cart"> | string
    customerId?: StringWithAggregatesFilter<"Cart"> | string
    basePrice?: FloatWithAggregatesFilter<"Cart"> | number
    totalPrice?: FloatWithAggregatesFilter<"Cart"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Cart"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Cart"> | Date | string
  }

  export type CartItemWhereInput = {
    AND?: CartItemWhereInput | CartItemWhereInput[]
    OR?: CartItemWhereInput[]
    NOT?: CartItemWhereInput | CartItemWhereInput[]
    id?: StringFilter<"CartItem"> | string
    cartId?: StringFilter<"CartItem"> | string
    productId?: StringFilter<"CartItem"> | string
    quantity?: IntFilter<"CartItem"> | number
    unitPrice?: FloatFilter<"CartItem"> | number
    subtotal?: FloatFilter<"CartItem"> | number
    specialRequest?: StringNullableFilter<"CartItem"> | string | null
    cart?: XOR<CartScalarRelationFilter, CartWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    options?: CartItemOptionListRelationFilter
  }

  export type CartItemOrderByWithRelationInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
    specialRequest?: SortOrderInput | SortOrder
    cart?: CartOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    options?: CartItemOptionOrderByRelationAggregateInput
  }

  export type CartItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CartItemWhereInput | CartItemWhereInput[]
    OR?: CartItemWhereInput[]
    NOT?: CartItemWhereInput | CartItemWhereInput[]
    cartId?: StringFilter<"CartItem"> | string
    productId?: StringFilter<"CartItem"> | string
    quantity?: IntFilter<"CartItem"> | number
    unitPrice?: FloatFilter<"CartItem"> | number
    subtotal?: FloatFilter<"CartItem"> | number
    specialRequest?: StringNullableFilter<"CartItem"> | string | null
    cart?: XOR<CartScalarRelationFilter, CartWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    options?: CartItemOptionListRelationFilter
  }, "id">

  export type CartItemOrderByWithAggregationInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
    specialRequest?: SortOrderInput | SortOrder
    _count?: CartItemCountOrderByAggregateInput
    _avg?: CartItemAvgOrderByAggregateInput
    _max?: CartItemMaxOrderByAggregateInput
    _min?: CartItemMinOrderByAggregateInput
    _sum?: CartItemSumOrderByAggregateInput
  }

  export type CartItemScalarWhereWithAggregatesInput = {
    AND?: CartItemScalarWhereWithAggregatesInput | CartItemScalarWhereWithAggregatesInput[]
    OR?: CartItemScalarWhereWithAggregatesInput[]
    NOT?: CartItemScalarWhereWithAggregatesInput | CartItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CartItem"> | string
    cartId?: StringWithAggregatesFilter<"CartItem"> | string
    productId?: StringWithAggregatesFilter<"CartItem"> | string
    quantity?: IntWithAggregatesFilter<"CartItem"> | number
    unitPrice?: FloatWithAggregatesFilter<"CartItem"> | number
    subtotal?: FloatWithAggregatesFilter<"CartItem"> | number
    specialRequest?: StringNullableWithAggregatesFilter<"CartItem"> | string | null
  }

  export type CartItemOptionWhereInput = {
    AND?: CartItemOptionWhereInput | CartItemOptionWhereInput[]
    OR?: CartItemOptionWhereInput[]
    NOT?: CartItemOptionWhereInput | CartItemOptionWhereInput[]
    id?: StringFilter<"CartItemOption"> | string
    cartItemId?: StringFilter<"CartItemOption"> | string
    productOptionId?: StringFilter<"CartItemOption"> | string
    name?: StringFilter<"CartItemOption"> | string
    price?: FloatFilter<"CartItemOption"> | number
    cartItem?: XOR<CartItemScalarRelationFilter, CartItemWhereInput>
    productOption?: XOR<ProductOptionScalarRelationFilter, ProductOptionWhereInput>
  }

  export type CartItemOptionOrderByWithRelationInput = {
    id?: SortOrder
    cartItemId?: SortOrder
    productOptionId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    cartItem?: CartItemOrderByWithRelationInput
    productOption?: ProductOptionOrderByWithRelationInput
  }

  export type CartItemOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CartItemOptionWhereInput | CartItemOptionWhereInput[]
    OR?: CartItemOptionWhereInput[]
    NOT?: CartItemOptionWhereInput | CartItemOptionWhereInput[]
    cartItemId?: StringFilter<"CartItemOption"> | string
    productOptionId?: StringFilter<"CartItemOption"> | string
    name?: StringFilter<"CartItemOption"> | string
    price?: FloatFilter<"CartItemOption"> | number
    cartItem?: XOR<CartItemScalarRelationFilter, CartItemWhereInput>
    productOption?: XOR<ProductOptionScalarRelationFilter, ProductOptionWhereInput>
  }, "id">

  export type CartItemOptionOrderByWithAggregationInput = {
    id?: SortOrder
    cartItemId?: SortOrder
    productOptionId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    _count?: CartItemOptionCountOrderByAggregateInput
    _avg?: CartItemOptionAvgOrderByAggregateInput
    _max?: CartItemOptionMaxOrderByAggregateInput
    _min?: CartItemOptionMinOrderByAggregateInput
    _sum?: CartItemOptionSumOrderByAggregateInput
  }

  export type CartItemOptionScalarWhereWithAggregatesInput = {
    AND?: CartItemOptionScalarWhereWithAggregatesInput | CartItemOptionScalarWhereWithAggregatesInput[]
    OR?: CartItemOptionScalarWhereWithAggregatesInput[]
    NOT?: CartItemOptionScalarWhereWithAggregatesInput | CartItemOptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CartItemOption"> | string
    cartItemId?: StringWithAggregatesFilter<"CartItemOption"> | string
    productOptionId?: StringWithAggregatesFilter<"CartItemOption"> | string
    name?: StringWithAggregatesFilter<"CartItemOption"> | string
    price?: FloatWithAggregatesFilter<"CartItemOption"> | number
  }

  export type UserPaymentMethodWhereInput = {
    AND?: UserPaymentMethodWhereInput | UserPaymentMethodWhereInput[]
    OR?: UserPaymentMethodWhereInput[]
    NOT?: UserPaymentMethodWhereInput | UserPaymentMethodWhereInput[]
    id?: StringFilter<"UserPaymentMethod"> | string
    userId?: StringFilter<"UserPaymentMethod"> | string
    cardToken?: StringFilter<"UserPaymentMethod"> | string
    last4?: StringFilter<"UserPaymentMethod"> | string
    brand?: StringFilter<"UserPaymentMethod"> | string
    isDefault?: BoolFilter<"UserPaymentMethod"> | boolean
    createdAt?: DateTimeFilter<"UserPaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"UserPaymentMethod"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserPaymentMethodOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    cardToken?: SortOrder
    last4?: SortOrder
    brand?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserPaymentMethodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cardToken?: string
    AND?: UserPaymentMethodWhereInput | UserPaymentMethodWhereInput[]
    OR?: UserPaymentMethodWhereInput[]
    NOT?: UserPaymentMethodWhereInput | UserPaymentMethodWhereInput[]
    userId?: StringFilter<"UserPaymentMethod"> | string
    last4?: StringFilter<"UserPaymentMethod"> | string
    brand?: StringFilter<"UserPaymentMethod"> | string
    isDefault?: BoolFilter<"UserPaymentMethod"> | boolean
    createdAt?: DateTimeFilter<"UserPaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"UserPaymentMethod"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "cardToken">

  export type UserPaymentMethodOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    cardToken?: SortOrder
    last4?: SortOrder
    brand?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserPaymentMethodCountOrderByAggregateInput
    _max?: UserPaymentMethodMaxOrderByAggregateInput
    _min?: UserPaymentMethodMinOrderByAggregateInput
  }

  export type UserPaymentMethodScalarWhereWithAggregatesInput = {
    AND?: UserPaymentMethodScalarWhereWithAggregatesInput | UserPaymentMethodScalarWhereWithAggregatesInput[]
    OR?: UserPaymentMethodScalarWhereWithAggregatesInput[]
    NOT?: UserPaymentMethodScalarWhereWithAggregatesInput | UserPaymentMethodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserPaymentMethod"> | string
    userId?: StringWithAggregatesFilter<"UserPaymentMethod"> | string
    cardToken?: StringWithAggregatesFilter<"UserPaymentMethod"> | string
    last4?: StringWithAggregatesFilter<"UserPaymentMethod"> | string
    brand?: StringWithAggregatesFilter<"UserPaymentMethod"> | string
    isDefault?: BoolWithAggregatesFilter<"UserPaymentMethod"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserPaymentMethod"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserPaymentMethod"> | Date | string
  }

  export type DeliveryPersonWhereInput = {
    AND?: DeliveryPersonWhereInput | DeliveryPersonWhereInput[]
    OR?: DeliveryPersonWhereInput[]
    NOT?: DeliveryPersonWhereInput | DeliveryPersonWhereInput[]
    id?: StringFilter<"DeliveryPerson"> | string
    userId?: StringFilter<"DeliveryPerson"> | string
    vehicleType?: StringNullableFilter<"DeliveryPerson"> | string | null
    licensePlate?: StringNullableFilter<"DeliveryPerson"> | string | null
    status?: StringFilter<"DeliveryPerson"> | string
    rating?: FloatFilter<"DeliveryPerson"> | number
    totalDeliveries?: IntFilter<"DeliveryPerson"> | number
    isOnline?: BoolFilter<"DeliveryPerson"> | boolean
    latitude?: FloatNullableFilter<"DeliveryPerson"> | number | null
    longitude?: FloatNullableFilter<"DeliveryPerson"> | number | null
    lastSeenAt?: DateTimeNullableFilter<"DeliveryPerson"> | Date | string | null
    walletBalance?: FloatFilter<"DeliveryPerson"> | number
    createdAt?: DateTimeFilter<"DeliveryPerson"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryPerson"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    assignedOrders?: DeliveryAssignmentListRelationFilter
    earnings?: DeliveryEarningListRelationFilter
    DriverLocationLog?: DriverLocationLogListRelationFilter
    Activity?: ActivityListRelationFilter
  }

  export type DeliveryPersonOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleType?: SortOrderInput | SortOrder
    licensePlate?: SortOrderInput | SortOrder
    status?: SortOrder
    rating?: SortOrder
    totalDeliveries?: SortOrder
    isOnline?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    lastSeenAt?: SortOrderInput | SortOrder
    walletBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    assignedOrders?: DeliveryAssignmentOrderByRelationAggregateInput
    earnings?: DeliveryEarningOrderByRelationAggregateInput
    DriverLocationLog?: DriverLocationLogOrderByRelationAggregateInput
    Activity?: ActivityOrderByRelationAggregateInput
  }

  export type DeliveryPersonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: DeliveryPersonWhereInput | DeliveryPersonWhereInput[]
    OR?: DeliveryPersonWhereInput[]
    NOT?: DeliveryPersonWhereInput | DeliveryPersonWhereInput[]
    vehicleType?: StringNullableFilter<"DeliveryPerson"> | string | null
    licensePlate?: StringNullableFilter<"DeliveryPerson"> | string | null
    status?: StringFilter<"DeliveryPerson"> | string
    rating?: FloatFilter<"DeliveryPerson"> | number
    totalDeliveries?: IntFilter<"DeliveryPerson"> | number
    isOnline?: BoolFilter<"DeliveryPerson"> | boolean
    latitude?: FloatNullableFilter<"DeliveryPerson"> | number | null
    longitude?: FloatNullableFilter<"DeliveryPerson"> | number | null
    lastSeenAt?: DateTimeNullableFilter<"DeliveryPerson"> | Date | string | null
    walletBalance?: FloatFilter<"DeliveryPerson"> | number
    createdAt?: DateTimeFilter<"DeliveryPerson"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryPerson"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    assignedOrders?: DeliveryAssignmentListRelationFilter
    earnings?: DeliveryEarningListRelationFilter
    DriverLocationLog?: DriverLocationLogListRelationFilter
    Activity?: ActivityListRelationFilter
  }, "id" | "userId">

  export type DeliveryPersonOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleType?: SortOrderInput | SortOrder
    licensePlate?: SortOrderInput | SortOrder
    status?: SortOrder
    rating?: SortOrder
    totalDeliveries?: SortOrder
    isOnline?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    lastSeenAt?: SortOrderInput | SortOrder
    walletBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DeliveryPersonCountOrderByAggregateInput
    _avg?: DeliveryPersonAvgOrderByAggregateInput
    _max?: DeliveryPersonMaxOrderByAggregateInput
    _min?: DeliveryPersonMinOrderByAggregateInput
    _sum?: DeliveryPersonSumOrderByAggregateInput
  }

  export type DeliveryPersonScalarWhereWithAggregatesInput = {
    AND?: DeliveryPersonScalarWhereWithAggregatesInput | DeliveryPersonScalarWhereWithAggregatesInput[]
    OR?: DeliveryPersonScalarWhereWithAggregatesInput[]
    NOT?: DeliveryPersonScalarWhereWithAggregatesInput | DeliveryPersonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeliveryPerson"> | string
    userId?: StringWithAggregatesFilter<"DeliveryPerson"> | string
    vehicleType?: StringNullableWithAggregatesFilter<"DeliveryPerson"> | string | null
    licensePlate?: StringNullableWithAggregatesFilter<"DeliveryPerson"> | string | null
    status?: StringWithAggregatesFilter<"DeliveryPerson"> | string
    rating?: FloatWithAggregatesFilter<"DeliveryPerson"> | number
    totalDeliveries?: IntWithAggregatesFilter<"DeliveryPerson"> | number
    isOnline?: BoolWithAggregatesFilter<"DeliveryPerson"> | boolean
    latitude?: FloatNullableWithAggregatesFilter<"DeliveryPerson"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"DeliveryPerson"> | number | null
    lastSeenAt?: DateTimeNullableWithAggregatesFilter<"DeliveryPerson"> | Date | string | null
    walletBalance?: FloatWithAggregatesFilter<"DeliveryPerson"> | number
    createdAt?: DateTimeWithAggregatesFilter<"DeliveryPerson"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DeliveryPerson"> | Date | string
  }

  export type DeliveryAssignmentWhereInput = {
    AND?: DeliveryAssignmentWhereInput | DeliveryAssignmentWhereInput[]
    OR?: DeliveryAssignmentWhereInput[]
    NOT?: DeliveryAssignmentWhereInput | DeliveryAssignmentWhereInput[]
    id?: StringFilter<"DeliveryAssignment"> | string
    orderId?: StringFilter<"DeliveryAssignment"> | string
    deliveryPersonId?: StringFilter<"DeliveryAssignment"> | string
    status?: EnumDeliveryStatusFilter<"DeliveryAssignment"> | $Enums.DeliveryStatus
    assignedAt?: DateTimeFilter<"DeliveryAssignment"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"DeliveryAssignment"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"DeliveryAssignment"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"DeliveryAssignment"> | Date | string | null
    declinedAt?: DateTimeNullableFilter<"DeliveryAssignment"> | Date | string | null
    timeoutSeconds?: IntFilter<"DeliveryAssignment"> | number
    attempts?: IntFilter<"DeliveryAssignment"> | number
    batchId?: StringNullableFilter<"DeliveryAssignment"> | string | null
    createdAt?: DateTimeFilter<"DeliveryAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryAssignment"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    deliveryPerson?: XOR<DeliveryPersonScalarRelationFilter, DeliveryPersonWhereInput>
  }

  export type DeliveryAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    deliveryPersonId?: SortOrder
    status?: SortOrder
    assignedAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    declinedAt?: SortOrderInput | SortOrder
    timeoutSeconds?: SortOrder
    attempts?: SortOrder
    batchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    deliveryPerson?: DeliveryPersonOrderByWithRelationInput
  }

  export type DeliveryAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeliveryAssignmentWhereInput | DeliveryAssignmentWhereInput[]
    OR?: DeliveryAssignmentWhereInput[]
    NOT?: DeliveryAssignmentWhereInput | DeliveryAssignmentWhereInput[]
    orderId?: StringFilter<"DeliveryAssignment"> | string
    deliveryPersonId?: StringFilter<"DeliveryAssignment"> | string
    status?: EnumDeliveryStatusFilter<"DeliveryAssignment"> | $Enums.DeliveryStatus
    assignedAt?: DateTimeFilter<"DeliveryAssignment"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"DeliveryAssignment"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"DeliveryAssignment"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"DeliveryAssignment"> | Date | string | null
    declinedAt?: DateTimeNullableFilter<"DeliveryAssignment"> | Date | string | null
    timeoutSeconds?: IntFilter<"DeliveryAssignment"> | number
    attempts?: IntFilter<"DeliveryAssignment"> | number
    batchId?: StringNullableFilter<"DeliveryAssignment"> | string | null
    createdAt?: DateTimeFilter<"DeliveryAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryAssignment"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    deliveryPerson?: XOR<DeliveryPersonScalarRelationFilter, DeliveryPersonWhereInput>
  }, "id">

  export type DeliveryAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    deliveryPersonId?: SortOrder
    status?: SortOrder
    assignedAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    declinedAt?: SortOrderInput | SortOrder
    timeoutSeconds?: SortOrder
    attempts?: SortOrder
    batchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DeliveryAssignmentCountOrderByAggregateInput
    _avg?: DeliveryAssignmentAvgOrderByAggregateInput
    _max?: DeliveryAssignmentMaxOrderByAggregateInput
    _min?: DeliveryAssignmentMinOrderByAggregateInput
    _sum?: DeliveryAssignmentSumOrderByAggregateInput
  }

  export type DeliveryAssignmentScalarWhereWithAggregatesInput = {
    AND?: DeliveryAssignmentScalarWhereWithAggregatesInput | DeliveryAssignmentScalarWhereWithAggregatesInput[]
    OR?: DeliveryAssignmentScalarWhereWithAggregatesInput[]
    NOT?: DeliveryAssignmentScalarWhereWithAggregatesInput | DeliveryAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeliveryAssignment"> | string
    orderId?: StringWithAggregatesFilter<"DeliveryAssignment"> | string
    deliveryPersonId?: StringWithAggregatesFilter<"DeliveryAssignment"> | string
    status?: EnumDeliveryStatusWithAggregatesFilter<"DeliveryAssignment"> | $Enums.DeliveryStatus
    assignedAt?: DateTimeWithAggregatesFilter<"DeliveryAssignment"> | Date | string
    acceptedAt?: DateTimeNullableWithAggregatesFilter<"DeliveryAssignment"> | Date | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"DeliveryAssignment"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"DeliveryAssignment"> | Date | string | null
    declinedAt?: DateTimeNullableWithAggregatesFilter<"DeliveryAssignment"> | Date | string | null
    timeoutSeconds?: IntWithAggregatesFilter<"DeliveryAssignment"> | number
    attempts?: IntWithAggregatesFilter<"DeliveryAssignment"> | number
    batchId?: StringNullableWithAggregatesFilter<"DeliveryAssignment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DeliveryAssignment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DeliveryAssignment"> | Date | string
  }

  export type DeliveryEarningWhereInput = {
    AND?: DeliveryEarningWhereInput | DeliveryEarningWhereInput[]
    OR?: DeliveryEarningWhereInput[]
    NOT?: DeliveryEarningWhereInput | DeliveryEarningWhereInput[]
    id?: StringFilter<"DeliveryEarning"> | string
    deliveryPersonId?: StringFilter<"DeliveryEarning"> | string
    orderId?: StringFilter<"DeliveryEarning"> | string
    baseFee?: FloatFilter<"DeliveryEarning"> | number
    distanceFee?: FloatFilter<"DeliveryEarning"> | number
    tip?: FloatFilter<"DeliveryEarning"> | number
    deductions?: FloatFilter<"DeliveryEarning"> | number
    totalEarned?: FloatFilter<"DeliveryEarning"> | number
    createdAt?: DateTimeFilter<"DeliveryEarning"> | Date | string
    deliveryPerson?: XOR<DeliveryPersonScalarRelationFilter, DeliveryPersonWhereInput>
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }

  export type DeliveryEarningOrderByWithRelationInput = {
    id?: SortOrder
    deliveryPersonId?: SortOrder
    orderId?: SortOrder
    baseFee?: SortOrder
    distanceFee?: SortOrder
    tip?: SortOrder
    deductions?: SortOrder
    totalEarned?: SortOrder
    createdAt?: SortOrder
    deliveryPerson?: DeliveryPersonOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
  }

  export type DeliveryEarningWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeliveryEarningWhereInput | DeliveryEarningWhereInput[]
    OR?: DeliveryEarningWhereInput[]
    NOT?: DeliveryEarningWhereInput | DeliveryEarningWhereInput[]
    deliveryPersonId?: StringFilter<"DeliveryEarning"> | string
    orderId?: StringFilter<"DeliveryEarning"> | string
    baseFee?: FloatFilter<"DeliveryEarning"> | number
    distanceFee?: FloatFilter<"DeliveryEarning"> | number
    tip?: FloatFilter<"DeliveryEarning"> | number
    deductions?: FloatFilter<"DeliveryEarning"> | number
    totalEarned?: FloatFilter<"DeliveryEarning"> | number
    createdAt?: DateTimeFilter<"DeliveryEarning"> | Date | string
    deliveryPerson?: XOR<DeliveryPersonScalarRelationFilter, DeliveryPersonWhereInput>
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }, "id">

  export type DeliveryEarningOrderByWithAggregationInput = {
    id?: SortOrder
    deliveryPersonId?: SortOrder
    orderId?: SortOrder
    baseFee?: SortOrder
    distanceFee?: SortOrder
    tip?: SortOrder
    deductions?: SortOrder
    totalEarned?: SortOrder
    createdAt?: SortOrder
    _count?: DeliveryEarningCountOrderByAggregateInput
    _avg?: DeliveryEarningAvgOrderByAggregateInput
    _max?: DeliveryEarningMaxOrderByAggregateInput
    _min?: DeliveryEarningMinOrderByAggregateInput
    _sum?: DeliveryEarningSumOrderByAggregateInput
  }

  export type DeliveryEarningScalarWhereWithAggregatesInput = {
    AND?: DeliveryEarningScalarWhereWithAggregatesInput | DeliveryEarningScalarWhereWithAggregatesInput[]
    OR?: DeliveryEarningScalarWhereWithAggregatesInput[]
    NOT?: DeliveryEarningScalarWhereWithAggregatesInput | DeliveryEarningScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeliveryEarning"> | string
    deliveryPersonId?: StringWithAggregatesFilter<"DeliveryEarning"> | string
    orderId?: StringWithAggregatesFilter<"DeliveryEarning"> | string
    baseFee?: FloatWithAggregatesFilter<"DeliveryEarning"> | number
    distanceFee?: FloatWithAggregatesFilter<"DeliveryEarning"> | number
    tip?: FloatWithAggregatesFilter<"DeliveryEarning"> | number
    deductions?: FloatWithAggregatesFilter<"DeliveryEarning"> | number
    totalEarned?: FloatWithAggregatesFilter<"DeliveryEarning"> | number
    createdAt?: DateTimeWithAggregatesFilter<"DeliveryEarning"> | Date | string
  }

  export type DriverLocationLogWhereInput = {
    AND?: DriverLocationLogWhereInput | DriverLocationLogWhereInput[]
    OR?: DriverLocationLogWhereInput[]
    NOT?: DriverLocationLogWhereInput | DriverLocationLogWhereInput[]
    id?: StringFilter<"DriverLocationLog"> | string
    driverId?: StringFilter<"DriverLocationLog"> | string
    latitude?: FloatFilter<"DriverLocationLog"> | number
    longitude?: FloatFilter<"DriverLocationLog"> | number
    timestamp?: DateTimeFilter<"DriverLocationLog"> | Date | string
    driver?: XOR<DeliveryPersonScalarRelationFilter, DeliveryPersonWhereInput>
  }

  export type DriverLocationLogOrderByWithRelationInput = {
    id?: SortOrder
    driverId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    timestamp?: SortOrder
    driver?: DeliveryPersonOrderByWithRelationInput
  }

  export type DriverLocationLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DriverLocationLogWhereInput | DriverLocationLogWhereInput[]
    OR?: DriverLocationLogWhereInput[]
    NOT?: DriverLocationLogWhereInput | DriverLocationLogWhereInput[]
    driverId?: StringFilter<"DriverLocationLog"> | string
    latitude?: FloatFilter<"DriverLocationLog"> | number
    longitude?: FloatFilter<"DriverLocationLog"> | number
    timestamp?: DateTimeFilter<"DriverLocationLog"> | Date | string
    driver?: XOR<DeliveryPersonScalarRelationFilter, DeliveryPersonWhereInput>
  }, "id">

  export type DriverLocationLogOrderByWithAggregationInput = {
    id?: SortOrder
    driverId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    timestamp?: SortOrder
    _count?: DriverLocationLogCountOrderByAggregateInput
    _avg?: DriverLocationLogAvgOrderByAggregateInput
    _max?: DriverLocationLogMaxOrderByAggregateInput
    _min?: DriverLocationLogMinOrderByAggregateInput
    _sum?: DriverLocationLogSumOrderByAggregateInput
  }

  export type DriverLocationLogScalarWhereWithAggregatesInput = {
    AND?: DriverLocationLogScalarWhereWithAggregatesInput | DriverLocationLogScalarWhereWithAggregatesInput[]
    OR?: DriverLocationLogScalarWhereWithAggregatesInput[]
    NOT?: DriverLocationLogScalarWhereWithAggregatesInput | DriverLocationLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DriverLocationLog"> | string
    driverId?: StringWithAggregatesFilter<"DriverLocationLog"> | string
    latitude?: FloatWithAggregatesFilter<"DriverLocationLog"> | number
    longitude?: FloatWithAggregatesFilter<"DriverLocationLog"> | number
    timestamp?: DateTimeWithAggregatesFilter<"DriverLocationLog"> | Date | string
  }

  export type ActivityWhereInput = {
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    id?: StringFilter<"Activity"> | string
    orderId?: StringNullableFilter<"Activity"> | string | null
    vendorId?: StringNullableFilter<"Activity"> | string | null
    customerId?: StringNullableFilter<"Activity"> | string | null
    deliveryId?: StringNullableFilter<"Activity"> | string | null
    type?: EnumActivityTypeFilter<"Activity"> | $Enums.ActivityType
    title?: StringFilter<"Activity"> | string
    message?: StringFilter<"Activity"> | string
    meta?: JsonNullableFilter<"Activity">
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    vendor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    customer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    delivery?: XOR<DeliveryPersonNullableScalarRelationFilter, DeliveryPersonWhereInput> | null
  }

  export type ActivityOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrderInput | SortOrder
    vendorId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    deliveryId?: SortOrderInput | SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    meta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    vendor?: UserOrderByWithRelationInput
    customer?: UserOrderByWithRelationInput
    delivery?: DeliveryPersonOrderByWithRelationInput
  }

  export type ActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    orderId?: StringNullableFilter<"Activity"> | string | null
    vendorId?: StringNullableFilter<"Activity"> | string | null
    customerId?: StringNullableFilter<"Activity"> | string | null
    deliveryId?: StringNullableFilter<"Activity"> | string | null
    type?: EnumActivityTypeFilter<"Activity"> | $Enums.ActivityType
    title?: StringFilter<"Activity"> | string
    message?: StringFilter<"Activity"> | string
    meta?: JsonNullableFilter<"Activity">
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    vendor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    customer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    delivery?: XOR<DeliveryPersonNullableScalarRelationFilter, DeliveryPersonWhereInput> | null
  }, "id">

  export type ActivityOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrderInput | SortOrder
    vendorId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    deliveryId?: SortOrderInput | SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    meta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ActivityCountOrderByAggregateInput
    _max?: ActivityMaxOrderByAggregateInput
    _min?: ActivityMinOrderByAggregateInput
  }

  export type ActivityScalarWhereWithAggregatesInput = {
    AND?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    OR?: ActivityScalarWhereWithAggregatesInput[]
    NOT?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Activity"> | string
    orderId?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    vendorId?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    customerId?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    deliveryId?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    type?: EnumActivityTypeWithAggregatesFilter<"Activity"> | $Enums.ActivityType
    title?: StringWithAggregatesFilter<"Activity"> | string
    message?: StringWithAggregatesFilter<"Activity"> | string
    meta?: JsonNullableWithAggregatesFilter<"Activity">
    createdAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
  }

  export type DeliveryBroadcastWhereInput = {
    AND?: DeliveryBroadcastWhereInput | DeliveryBroadcastWhereInput[]
    OR?: DeliveryBroadcastWhereInput[]
    NOT?: DeliveryBroadcastWhereInput | DeliveryBroadcastWhereInput[]
    id?: StringFilter<"DeliveryBroadcast"> | string
    orderId?: StringFilter<"DeliveryBroadcast"> | string
    driverIds?: StringNullableListFilter<"DeliveryBroadcast">
    acceptedDriverId?: StringNullableFilter<"DeliveryBroadcast"> | string | null
    status?: StringFilter<"DeliveryBroadcast"> | string
    expiresAt?: DateTimeFilter<"DeliveryBroadcast"> | Date | string
    createdAt?: DateTimeFilter<"DeliveryBroadcast"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryBroadcast"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }

  export type DeliveryBroadcastOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    driverIds?: SortOrder
    acceptedDriverId?: SortOrderInput | SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
  }

  export type DeliveryBroadcastWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeliveryBroadcastWhereInput | DeliveryBroadcastWhereInput[]
    OR?: DeliveryBroadcastWhereInput[]
    NOT?: DeliveryBroadcastWhereInput | DeliveryBroadcastWhereInput[]
    orderId?: StringFilter<"DeliveryBroadcast"> | string
    driverIds?: StringNullableListFilter<"DeliveryBroadcast">
    acceptedDriverId?: StringNullableFilter<"DeliveryBroadcast"> | string | null
    status?: StringFilter<"DeliveryBroadcast"> | string
    expiresAt?: DateTimeFilter<"DeliveryBroadcast"> | Date | string
    createdAt?: DateTimeFilter<"DeliveryBroadcast"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryBroadcast"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }, "id">

  export type DeliveryBroadcastOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    driverIds?: SortOrder
    acceptedDriverId?: SortOrderInput | SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DeliveryBroadcastCountOrderByAggregateInput
    _max?: DeliveryBroadcastMaxOrderByAggregateInput
    _min?: DeliveryBroadcastMinOrderByAggregateInput
  }

  export type DeliveryBroadcastScalarWhereWithAggregatesInput = {
    AND?: DeliveryBroadcastScalarWhereWithAggregatesInput | DeliveryBroadcastScalarWhereWithAggregatesInput[]
    OR?: DeliveryBroadcastScalarWhereWithAggregatesInput[]
    NOT?: DeliveryBroadcastScalarWhereWithAggregatesInput | DeliveryBroadcastScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeliveryBroadcast"> | string
    orderId?: StringWithAggregatesFilter<"DeliveryBroadcast"> | string
    driverIds?: StringNullableListFilter<"DeliveryBroadcast">
    acceptedDriverId?: StringNullableWithAggregatesFilter<"DeliveryBroadcast"> | string | null
    status?: StringWithAggregatesFilter<"DeliveryBroadcast"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"DeliveryBroadcast"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"DeliveryBroadcast"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DeliveryBroadcast"> | Date | string
  }

  export type WebhookEventWhereInput = {
    AND?: WebhookEventWhereInput | WebhookEventWhereInput[]
    OR?: WebhookEventWhereInput[]
    NOT?: WebhookEventWhereInput | WebhookEventWhereInput[]
    id?: StringFilter<"WebhookEvent"> | string
    reference?: StringFilter<"WebhookEvent"> | string
    event?: StringFilter<"WebhookEvent"> | string
    payload?: JsonFilter<"WebhookEvent">
    status?: StringFilter<"WebhookEvent"> | string
    createdAt?: DateTimeFilter<"WebhookEvent"> | Date | string
    processedAt?: DateTimeNullableFilter<"WebhookEvent"> | Date | string | null
  }

  export type WebhookEventOrderByWithRelationInput = {
    id?: SortOrder
    reference?: SortOrder
    event?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
  }

  export type WebhookEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    reference_event?: WebhookEventReferenceEventCompoundUniqueInput
    AND?: WebhookEventWhereInput | WebhookEventWhereInput[]
    OR?: WebhookEventWhereInput[]
    NOT?: WebhookEventWhereInput | WebhookEventWhereInput[]
    reference?: StringFilter<"WebhookEvent"> | string
    event?: StringFilter<"WebhookEvent"> | string
    payload?: JsonFilter<"WebhookEvent">
    status?: StringFilter<"WebhookEvent"> | string
    createdAt?: DateTimeFilter<"WebhookEvent"> | Date | string
    processedAt?: DateTimeNullableFilter<"WebhookEvent"> | Date | string | null
  }, "id" | "reference_event">

  export type WebhookEventOrderByWithAggregationInput = {
    id?: SortOrder
    reference?: SortOrder
    event?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    _count?: WebhookEventCountOrderByAggregateInput
    _max?: WebhookEventMaxOrderByAggregateInput
    _min?: WebhookEventMinOrderByAggregateInput
  }

  export type WebhookEventScalarWhereWithAggregatesInput = {
    AND?: WebhookEventScalarWhereWithAggregatesInput | WebhookEventScalarWhereWithAggregatesInput[]
    OR?: WebhookEventScalarWhereWithAggregatesInput[]
    NOT?: WebhookEventScalarWhereWithAggregatesInput | WebhookEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WebhookEvent"> | string
    reference?: StringWithAggregatesFilter<"WebhookEvent"> | string
    event?: StringWithAggregatesFilter<"WebhookEvent"> | string
    payload?: JsonWithAggregatesFilter<"WebhookEvent">
    status?: StringWithAggregatesFilter<"WebhookEvent"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WebhookEvent"> | Date | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"WebhookEvent"> | Date | string | null
  }

  export type ReceiptWhereInput = {
    AND?: ReceiptWhereInput | ReceiptWhereInput[]
    OR?: ReceiptWhereInput[]
    NOT?: ReceiptWhereInput | ReceiptWhereInput[]
    id?: StringFilter<"Receipt"> | string
    paymentId?: StringFilter<"Receipt"> | string
    pdfUrl?: StringNullableFilter<"Receipt"> | string | null
    createdAt?: DateTimeFilter<"Receipt"> | Date | string
    payment?: XOR<PaymentScalarRelationFilter, PaymentWhereInput>
  }

  export type ReceiptOrderByWithRelationInput = {
    id?: SortOrder
    paymentId?: SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    payment?: PaymentOrderByWithRelationInput
  }

  export type ReceiptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReceiptWhereInput | ReceiptWhereInput[]
    OR?: ReceiptWhereInput[]
    NOT?: ReceiptWhereInput | ReceiptWhereInput[]
    paymentId?: StringFilter<"Receipt"> | string
    pdfUrl?: StringNullableFilter<"Receipt"> | string | null
    createdAt?: DateTimeFilter<"Receipt"> | Date | string
    payment?: XOR<PaymentScalarRelationFilter, PaymentWhereInput>
  }, "id">

  export type ReceiptOrderByWithAggregationInput = {
    id?: SortOrder
    paymentId?: SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ReceiptCountOrderByAggregateInput
    _max?: ReceiptMaxOrderByAggregateInput
    _min?: ReceiptMinOrderByAggregateInput
  }

  export type ReceiptScalarWhereWithAggregatesInput = {
    AND?: ReceiptScalarWhereWithAggregatesInput | ReceiptScalarWhereWithAggregatesInput[]
    OR?: ReceiptScalarWhereWithAggregatesInput[]
    NOT?: ReceiptScalarWhereWithAggregatesInput | ReceiptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Receipt"> | string
    paymentId?: StringWithAggregatesFilter<"Receipt"> | string
    pdfUrl?: StringNullableWithAggregatesFilter<"Receipt"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Receipt"> | Date | string
  }

  export type VendorFollowerWhereInput = {
    AND?: VendorFollowerWhereInput | VendorFollowerWhereInput[]
    OR?: VendorFollowerWhereInput[]
    NOT?: VendorFollowerWhereInput | VendorFollowerWhereInput[]
    id?: StringFilter<"VendorFollower"> | string
    vendorId?: StringFilter<"VendorFollower"> | string
    customerId?: StringFilter<"VendorFollower"> | string
    createdAt?: DateTimeFilter<"VendorFollower"> | Date | string
    vendor?: XOR<UserScalarRelationFilter, UserWhereInput>
    customer?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type VendorFollowerOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    vendor?: UserOrderByWithRelationInput
    customer?: UserOrderByWithRelationInput
  }

  export type VendorFollowerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    vendorId_customerId?: VendorFollowerVendorIdCustomerIdCompoundUniqueInput
    AND?: VendorFollowerWhereInput | VendorFollowerWhereInput[]
    OR?: VendorFollowerWhereInput[]
    NOT?: VendorFollowerWhereInput | VendorFollowerWhereInput[]
    vendorId?: StringFilter<"VendorFollower"> | string
    customerId?: StringFilter<"VendorFollower"> | string
    createdAt?: DateTimeFilter<"VendorFollower"> | Date | string
    vendor?: XOR<UserScalarRelationFilter, UserWhereInput>
    customer?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "vendorId_customerId">

  export type VendorFollowerOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    _count?: VendorFollowerCountOrderByAggregateInput
    _max?: VendorFollowerMaxOrderByAggregateInput
    _min?: VendorFollowerMinOrderByAggregateInput
  }

  export type VendorFollowerScalarWhereWithAggregatesInput = {
    AND?: VendorFollowerScalarWhereWithAggregatesInput | VendorFollowerScalarWhereWithAggregatesInput[]
    OR?: VendorFollowerScalarWhereWithAggregatesInput[]
    NOT?: VendorFollowerScalarWhereWithAggregatesInput | VendorFollowerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VendorFollower"> | string
    vendorId?: StringWithAggregatesFilter<"VendorFollower"> | string
    customerId?: StringWithAggregatesFilter<"VendorFollower"> | string
    createdAt?: DateTimeWithAggregatesFilter<"VendorFollower"> | Date | string
  }

  export type SpecialOrderRequestWhereInput = {
    AND?: SpecialOrderRequestWhereInput | SpecialOrderRequestWhereInput[]
    OR?: SpecialOrderRequestWhereInput[]
    NOT?: SpecialOrderRequestWhereInput | SpecialOrderRequestWhereInput[]
    id?: StringFilter<"SpecialOrderRequest"> | string
    customerId?: StringFilter<"SpecialOrderRequest"> | string
    vendorId?: StringNullableFilter<"SpecialOrderRequest"> | string | null
    productId?: StringFilter<"SpecialOrderRequest"> | string
    quantity?: IntFilter<"SpecialOrderRequest"> | number
    message?: StringFilter<"SpecialOrderRequest"> | string
    status?: StringFilter<"SpecialOrderRequest"> | string
    createdAt?: DateTimeFilter<"SpecialOrderRequest"> | Date | string
    updatedAt?: DateTimeFilter<"SpecialOrderRequest"> | Date | string
    customer?: XOR<UserScalarRelationFilter, UserWhereInput>
    vendor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    offers?: SpecialOrderOfferListRelationFilter
  }

  export type SpecialOrderRequestOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    vendorId?: SortOrderInput | SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: UserOrderByWithRelationInput
    vendor?: UserOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    offers?: SpecialOrderOfferOrderByRelationAggregateInput
  }

  export type SpecialOrderRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SpecialOrderRequestWhereInput | SpecialOrderRequestWhereInput[]
    OR?: SpecialOrderRequestWhereInput[]
    NOT?: SpecialOrderRequestWhereInput | SpecialOrderRequestWhereInput[]
    customerId?: StringFilter<"SpecialOrderRequest"> | string
    vendorId?: StringNullableFilter<"SpecialOrderRequest"> | string | null
    productId?: StringFilter<"SpecialOrderRequest"> | string
    quantity?: IntFilter<"SpecialOrderRequest"> | number
    message?: StringFilter<"SpecialOrderRequest"> | string
    status?: StringFilter<"SpecialOrderRequest"> | string
    createdAt?: DateTimeFilter<"SpecialOrderRequest"> | Date | string
    updatedAt?: DateTimeFilter<"SpecialOrderRequest"> | Date | string
    customer?: XOR<UserScalarRelationFilter, UserWhereInput>
    vendor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    offers?: SpecialOrderOfferListRelationFilter
  }, "id">

  export type SpecialOrderRequestOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    vendorId?: SortOrderInput | SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SpecialOrderRequestCountOrderByAggregateInput
    _avg?: SpecialOrderRequestAvgOrderByAggregateInput
    _max?: SpecialOrderRequestMaxOrderByAggregateInput
    _min?: SpecialOrderRequestMinOrderByAggregateInput
    _sum?: SpecialOrderRequestSumOrderByAggregateInput
  }

  export type SpecialOrderRequestScalarWhereWithAggregatesInput = {
    AND?: SpecialOrderRequestScalarWhereWithAggregatesInput | SpecialOrderRequestScalarWhereWithAggregatesInput[]
    OR?: SpecialOrderRequestScalarWhereWithAggregatesInput[]
    NOT?: SpecialOrderRequestScalarWhereWithAggregatesInput | SpecialOrderRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SpecialOrderRequest"> | string
    customerId?: StringWithAggregatesFilter<"SpecialOrderRequest"> | string
    vendorId?: StringNullableWithAggregatesFilter<"SpecialOrderRequest"> | string | null
    productId?: StringWithAggregatesFilter<"SpecialOrderRequest"> | string
    quantity?: IntWithAggregatesFilter<"SpecialOrderRequest"> | number
    message?: StringWithAggregatesFilter<"SpecialOrderRequest"> | string
    status?: StringWithAggregatesFilter<"SpecialOrderRequest"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SpecialOrderRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SpecialOrderRequest"> | Date | string
  }

  export type SpecialOrderOfferWhereInput = {
    AND?: SpecialOrderOfferWhereInput | SpecialOrderOfferWhereInput[]
    OR?: SpecialOrderOfferWhereInput[]
    NOT?: SpecialOrderOfferWhereInput | SpecialOrderOfferWhereInput[]
    id?: StringFilter<"SpecialOrderOffer"> | string
    requestId?: StringFilter<"SpecialOrderOffer"> | string
    vendorId?: StringFilter<"SpecialOrderOffer"> | string
    price?: FloatFilter<"SpecialOrderOffer"> | number
    message?: StringNullableFilter<"SpecialOrderOffer"> | string | null
    status?: StringFilter<"SpecialOrderOffer"> | string
    createdAt?: DateTimeFilter<"SpecialOrderOffer"> | Date | string
    updatedAt?: DateTimeFilter<"SpecialOrderOffer"> | Date | string
    request?: XOR<SpecialOrderRequestScalarRelationFilter, SpecialOrderRequestWhereInput>
    vendor?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SpecialOrderOfferOrderByWithRelationInput = {
    id?: SortOrder
    requestId?: SortOrder
    vendorId?: SortOrder
    price?: SortOrder
    message?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    request?: SpecialOrderRequestOrderByWithRelationInput
    vendor?: UserOrderByWithRelationInput
  }

  export type SpecialOrderOfferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SpecialOrderOfferWhereInput | SpecialOrderOfferWhereInput[]
    OR?: SpecialOrderOfferWhereInput[]
    NOT?: SpecialOrderOfferWhereInput | SpecialOrderOfferWhereInput[]
    requestId?: StringFilter<"SpecialOrderOffer"> | string
    vendorId?: StringFilter<"SpecialOrderOffer"> | string
    price?: FloatFilter<"SpecialOrderOffer"> | number
    message?: StringNullableFilter<"SpecialOrderOffer"> | string | null
    status?: StringFilter<"SpecialOrderOffer"> | string
    createdAt?: DateTimeFilter<"SpecialOrderOffer"> | Date | string
    updatedAt?: DateTimeFilter<"SpecialOrderOffer"> | Date | string
    request?: XOR<SpecialOrderRequestScalarRelationFilter, SpecialOrderRequestWhereInput>
    vendor?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SpecialOrderOfferOrderByWithAggregationInput = {
    id?: SortOrder
    requestId?: SortOrder
    vendorId?: SortOrder
    price?: SortOrder
    message?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SpecialOrderOfferCountOrderByAggregateInput
    _avg?: SpecialOrderOfferAvgOrderByAggregateInput
    _max?: SpecialOrderOfferMaxOrderByAggregateInput
    _min?: SpecialOrderOfferMinOrderByAggregateInput
    _sum?: SpecialOrderOfferSumOrderByAggregateInput
  }

  export type SpecialOrderOfferScalarWhereWithAggregatesInput = {
    AND?: SpecialOrderOfferScalarWhereWithAggregatesInput | SpecialOrderOfferScalarWhereWithAggregatesInput[]
    OR?: SpecialOrderOfferScalarWhereWithAggregatesInput[]
    NOT?: SpecialOrderOfferScalarWhereWithAggregatesInput | SpecialOrderOfferScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SpecialOrderOffer"> | string
    requestId?: StringWithAggregatesFilter<"SpecialOrderOffer"> | string
    vendorId?: StringWithAggregatesFilter<"SpecialOrderOffer"> | string
    price?: FloatWithAggregatesFilter<"SpecialOrderOffer"> | number
    message?: StringNullableWithAggregatesFilter<"SpecialOrderOffer"> | string | null
    status?: StringWithAggregatesFilter<"SpecialOrderOffer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SpecialOrderOffer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SpecialOrderOffer"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerCreateNestedManyWithoutVendorInput
    following?: VendorFollowerCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewUncheckedCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewUncheckedCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderUncheckedCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyUncheckedCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonUncheckedCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestUncheckedCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityUncheckedCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityUncheckedCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerUncheckedCreateNestedManyWithoutVendorInput
    following?: VendorFollowerUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUncheckedUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUncheckedUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUncheckedUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUncheckedUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUncheckedUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUncheckedUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUncheckedUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUncheckedUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUncheckedUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AddressCreateInput = {
    id?: string
    label: string
    street: string
    city: string
    state?: string | null
    country: string
    zipCode?: string | null
    landmark?: string | null
    latitude?: number | null
    longitude?: number | null
    isDefault?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAddressesInput
    orders?: OrderCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateInput = {
    id?: string
    userId: string
    label: string
    street: string
    city: string
    state?: string | null
    country: string
    zipCode?: string | null
    landmark?: string | null
    latitude?: number | null
    longitude?: number | null
    isDefault?: boolean
    createdAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAddressesNestedInput
    orders?: OrderUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type AddressCreateManyInput = {
    id?: string
    userId: string
    label: string
    street: string
    city: string
    state?: string | null
    country: string
    zipCode?: string | null
    landmark?: string | null
    latitude?: number | null
    longitude?: number | null
    isDefault?: boolean
    createdAt?: Date | string
  }

  export type AddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    name: string
    description: string
    price: number
    archived?: boolean
    category: $Enums.Category
    images?: ProductCreateimagesInput | string[]
    thumbnail?: string | null
    video?: ProductCreatevideoInput | string[]
    averageRating?: number | null
    reviewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    totalViews?: number
    popularityScore?: number
    popularityUpdatedAt?: Date | string | null
    popularityPercent?: number
    isNew?: boolean
    isLive?: boolean
    liveUntil?: Date | string | null
    vendor: UserCreateNestedOneWithoutProductsInput
    reviews?: ProductReviewCreateNestedManyWithoutProductInput
    orders?: OrderCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    options?: ProductOptionCreateNestedManyWithoutProductInput
    CartItem?: CartItemCreateNestedManyWithoutProductInput
    specialRequests?: SpecialOrderRequestCreateNestedManyWithoutProductInput
    productSchedule?: ProductScheduleCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    price: number
    archived?: boolean
    category: $Enums.Category
    images?: ProductCreateimagesInput | string[]
    thumbnail?: string | null
    video?: ProductCreatevideoInput | string[]
    vendorId: string
    averageRating?: number | null
    reviewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    totalViews?: number
    popularityScore?: number
    popularityUpdatedAt?: Date | string | null
    popularityPercent?: number
    isNew?: boolean
    isLive?: boolean
    liveUntil?: Date | string | null
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    orders?: OrderUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    options?: ProductOptionUncheckedCreateNestedManyWithoutProductInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductInput
    specialRequests?: SpecialOrderRequestUncheckedCreateNestedManyWithoutProductInput
    productSchedule?: ProductScheduleUncheckedCreateNestedOneWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    images?: ProductUpdateimagesInput | string[]
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    video?: ProductUpdatevideoInput | string[]
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalViews?: IntFieldUpdateOperationsInput | number
    popularityScore?: FloatFieldUpdateOperationsInput | number
    popularityUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    popularityPercent?: FloatFieldUpdateOperationsInput | number
    isNew?: BoolFieldUpdateOperationsInput | boolean
    isLive?: BoolFieldUpdateOperationsInput | boolean
    liveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendor?: UserUpdateOneRequiredWithoutProductsNestedInput
    reviews?: ProductReviewUpdateManyWithoutProductNestedInput
    orders?: OrderUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    options?: ProductOptionUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUpdateManyWithoutProductNestedInput
    specialRequests?: SpecialOrderRequestUpdateManyWithoutProductNestedInput
    productSchedule?: ProductScheduleUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    images?: ProductUpdateimagesInput | string[]
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    video?: ProductUpdatevideoInput | string[]
    vendorId?: StringFieldUpdateOperationsInput | string
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalViews?: IntFieldUpdateOperationsInput | number
    popularityScore?: FloatFieldUpdateOperationsInput | number
    popularityUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    popularityPercent?: FloatFieldUpdateOperationsInput | number
    isNew?: BoolFieldUpdateOperationsInput | boolean
    isLive?: BoolFieldUpdateOperationsInput | boolean
    liveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviews?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    options?: ProductOptionUncheckedUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    specialRequests?: SpecialOrderRequestUncheckedUpdateManyWithoutProductNestedInput
    productSchedule?: ProductScheduleUncheckedUpdateOneWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    name: string
    description: string
    price: number
    archived?: boolean
    category: $Enums.Category
    images?: ProductCreateimagesInput | string[]
    thumbnail?: string | null
    video?: ProductCreatevideoInput | string[]
    vendorId: string
    averageRating?: number | null
    reviewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    totalViews?: number
    popularityScore?: number
    popularityUpdatedAt?: Date | string | null
    popularityPercent?: number
    isNew?: boolean
    isLive?: boolean
    liveUntil?: Date | string | null
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    images?: ProductUpdateimagesInput | string[]
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    video?: ProductUpdatevideoInput | string[]
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalViews?: IntFieldUpdateOperationsInput | number
    popularityScore?: FloatFieldUpdateOperationsInput | number
    popularityUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    popularityPercent?: FloatFieldUpdateOperationsInput | number
    isNew?: BoolFieldUpdateOperationsInput | boolean
    isLive?: BoolFieldUpdateOperationsInput | boolean
    liveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    images?: ProductUpdateimagesInput | string[]
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    video?: ProductUpdatevideoInput | string[]
    vendorId?: StringFieldUpdateOperationsInput | string
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalViews?: IntFieldUpdateOperationsInput | number
    popularityScore?: FloatFieldUpdateOperationsInput | number
    popularityUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    popularityPercent?: FloatFieldUpdateOperationsInput | number
    isNew?: BoolFieldUpdateOperationsInput | boolean
    isLive?: BoolFieldUpdateOperationsInput | boolean
    liveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductScheduleCreateInput = {
    id?: string
    goLiveAt?: Date | string | null
    takeDownAt?: Date | string | null
    isLive?: boolean
    graceMinutes?: number | null
    autoGraceEnabled?: boolean
    manualGraceEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductScheduleInput
  }

  export type ProductScheduleUncheckedCreateInput = {
    id?: string
    productId: string
    goLiveAt?: Date | string | null
    takeDownAt?: Date | string | null
    isLive?: boolean
    graceMinutes?: number | null
    autoGraceEnabled?: boolean
    manualGraceEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    goLiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    takeDownAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLive?: BoolFieldUpdateOperationsInput | boolean
    graceMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    autoGraceEnabled?: BoolFieldUpdateOperationsInput | boolean
    manualGraceEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductScheduleNestedInput
  }

  export type ProductScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    goLiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    takeDownAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLive?: BoolFieldUpdateOperationsInput | boolean
    graceMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    autoGraceEnabled?: BoolFieldUpdateOperationsInput | boolean
    manualGraceEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductScheduleCreateManyInput = {
    id?: string
    productId: string
    goLiveAt?: Date | string | null
    takeDownAt?: Date | string | null
    isLive?: boolean
    graceMinutes?: number | null
    autoGraceEnabled?: boolean
    manualGraceEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    goLiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    takeDownAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLive?: BoolFieldUpdateOperationsInput | boolean
    graceMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    autoGraceEnabled?: BoolFieldUpdateOperationsInput | boolean
    manualGraceEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    goLiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    takeDownAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLive?: BoolFieldUpdateOperationsInput | boolean
    graceMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    autoGraceEnabled?: BoolFieldUpdateOperationsInput | boolean
    manualGraceEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductOptionCreateInput = {
    id?: string
    name: string
    price: number
    product: ProductCreateNestedOneWithoutOptionsInput
    OrderItemOption?: OrderItemOptionCreateNestedManyWithoutProductOptionInput
    CartItemOption?: CartItemOptionCreateNestedManyWithoutProductOptionInput
  }

  export type ProductOptionUncheckedCreateInput = {
    id?: string
    productId: string
    name: string
    price: number
    OrderItemOption?: OrderItemOptionUncheckedCreateNestedManyWithoutProductOptionInput
    CartItemOption?: CartItemOptionUncheckedCreateNestedManyWithoutProductOptionInput
  }

  export type ProductOptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutOptionsNestedInput
    OrderItemOption?: OrderItemOptionUpdateManyWithoutProductOptionNestedInput
    CartItemOption?: CartItemOptionUpdateManyWithoutProductOptionNestedInput
  }

  export type ProductOptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    OrderItemOption?: OrderItemOptionUncheckedUpdateManyWithoutProductOptionNestedInput
    CartItemOption?: CartItemOptionUncheckedUpdateManyWithoutProductOptionNestedInput
  }

  export type ProductOptionCreateManyInput = {
    id?: string
    productId: string
    name: string
    price: number
  }

  export type ProductOptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type ProductOptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type OrderCreateInput = {
    id?: string
    basePrice: number
    extraCharge?: number
    totalPrice: number
    vendorNote?: string | null
    customerApproval?: boolean
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentInitiatedAt?: Date | string | null
    paymentStartedAt?: Date | string | null
    paidAt?: Date | string | null
    paymentStatus?: $Enums.PaymentStatus | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    protectedUntil?: Date | string | null
    paymentGraceMinutes?: number | null
    customer: UserCreateNestedOneWithoutCustomerOrdersInput
    vendor: UserCreateNestedOneWithoutVendorOrdersInput
    address?: AddressCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    Product?: ProductCreateNestedManyWithoutOrdersInput
    assignments?: DeliveryAssignmentCreateNestedManyWithoutOrderInput
    earnings?: DeliveryEarningCreateNestedManyWithoutOrderInput
    Activity?: ActivityCreateNestedManyWithoutOrderInput
    DeliveryBroadcast?: DeliveryBroadcastCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    customerId: string
    vendorId: string
    addressId?: string | null
    basePrice: number
    extraCharge?: number
    totalPrice: number
    vendorNote?: string | null
    customerApproval?: boolean
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentInitiatedAt?: Date | string | null
    paymentStartedAt?: Date | string | null
    paidAt?: Date | string | null
    paymentStatus?: $Enums.PaymentStatus | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    protectedUntil?: Date | string | null
    paymentGraceMinutes?: number | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    Product?: ProductUncheckedCreateNestedManyWithoutOrdersInput
    assignments?: DeliveryAssignmentUncheckedCreateNestedManyWithoutOrderInput
    earnings?: DeliveryEarningUncheckedCreateNestedManyWithoutOrderInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutOrderInput
    DeliveryBroadcast?: DeliveryBroadcastUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraCharge?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    vendorNote?: NullableStringFieldUpdateOperationsInput | string | null
    customerApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentInitiatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    protectedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGraceMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    customer?: UserUpdateOneRequiredWithoutCustomerOrdersNestedInput
    vendor?: UserUpdateOneRequiredWithoutVendorOrdersNestedInput
    address?: AddressUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    Product?: ProductUpdateManyWithoutOrdersNestedInput
    assignments?: DeliveryAssignmentUpdateManyWithoutOrderNestedInput
    earnings?: DeliveryEarningUpdateManyWithoutOrderNestedInput
    Activity?: ActivityUpdateManyWithoutOrderNestedInput
    DeliveryBroadcast?: DeliveryBroadcastUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraCharge?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    vendorNote?: NullableStringFieldUpdateOperationsInput | string | null
    customerApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentInitiatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    protectedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGraceMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    Product?: ProductUncheckedUpdateManyWithoutOrdersNestedInput
    assignments?: DeliveryAssignmentUncheckedUpdateManyWithoutOrderNestedInput
    earnings?: DeliveryEarningUncheckedUpdateManyWithoutOrderNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutOrderNestedInput
    DeliveryBroadcast?: DeliveryBroadcastUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    customerId: string
    vendorId: string
    addressId?: string | null
    basePrice: number
    extraCharge?: number
    totalPrice: number
    vendorNote?: string | null
    customerApproval?: boolean
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentInitiatedAt?: Date | string | null
    paymentStartedAt?: Date | string | null
    paidAt?: Date | string | null
    paymentStatus?: $Enums.PaymentStatus | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    protectedUntil?: Date | string | null
    paymentGraceMinutes?: number | null
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraCharge?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    vendorNote?: NullableStringFieldUpdateOperationsInput | string | null
    customerApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentInitiatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    protectedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGraceMinutes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraCharge?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    vendorNote?: NullableStringFieldUpdateOperationsInput | string | null
    customerApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentInitiatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    protectedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGraceMinutes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OrderItemCreateInput = {
    id?: string
    quantity: number
    unitPrice: number
    subtotal: number
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutOrderItemsInput
    options?: OrderItemOptionCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: string
    orderId: string
    productId: string
    quantity: number
    unitPrice: number
    subtotal: number
    createdAt?: Date | string
    options?: OrderItemOptionUncheckedCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
    options?: OrderItemOptionUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: OrderItemOptionUncheckedUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemCreateManyInput = {
    id?: string
    orderId: string
    productId: string
    quantity: number
    unitPrice: number
    subtotal: number
    createdAt?: Date | string
  }

  export type OrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemOptionCreateInput = {
    id?: string
    name: string
    price: number
    orderItem: OrderItemCreateNestedOneWithoutOptionsInput
    productOption: ProductOptionCreateNestedOneWithoutOrderItemOptionInput
  }

  export type OrderItemOptionUncheckedCreateInput = {
    id?: string
    optionId: string
    name: string
    price: number
    orderItemId: string
  }

  export type OrderItemOptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    orderItem?: OrderItemUpdateOneRequiredWithoutOptionsNestedInput
    productOption?: ProductOptionUpdateOneRequiredWithoutOrderItemOptionNestedInput
  }

  export type OrderItemOptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    orderItemId?: StringFieldUpdateOperationsInput | string
  }

  export type OrderItemOptionCreateManyInput = {
    id?: string
    optionId: string
    name: string
    price: number
    orderItemId: string
  }

  export type OrderItemOptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type OrderItemOptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    orderItemId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductReviewCreateInput = {
    id?: string
    rating: number
    comment?: string | null
    images?: ProductReviewCreateimagesInput | string[]
    createdAt?: Date | string
    verifiedPurchase?: boolean
    product: ProductCreateNestedOneWithoutReviewsInput
    customer: UserCreateNestedOneWithoutProductReviewsGivenInput
    reply?: VendorReplyCreateNestedOneWithoutReviewInput
    votes?: ReviewVoteCreateNestedManyWithoutReviewInput
    reports?: ReviewReportCreateNestedManyWithoutReviewInput
  }

  export type ProductReviewUncheckedCreateInput = {
    id?: string
    productId: string
    customerId: string
    rating: number
    comment?: string | null
    images?: ProductReviewCreateimagesInput | string[]
    createdAt?: Date | string
    verifiedPurchase?: boolean
    reply?: VendorReplyUncheckedCreateNestedOneWithoutReviewInput
    votes?: ReviewVoteUncheckedCreateNestedManyWithoutReviewInput
    reports?: ReviewReportUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ProductReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProductReviewUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedPurchase?: BoolFieldUpdateOperationsInput | boolean
    product?: ProductUpdateOneRequiredWithoutReviewsNestedInput
    customer?: UserUpdateOneRequiredWithoutProductReviewsGivenNestedInput
    reply?: VendorReplyUpdateOneWithoutReviewNestedInput
    votes?: ReviewVoteUpdateManyWithoutReviewNestedInput
    reports?: ReviewReportUpdateManyWithoutReviewNestedInput
  }

  export type ProductReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProductReviewUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedPurchase?: BoolFieldUpdateOperationsInput | boolean
    reply?: VendorReplyUncheckedUpdateOneWithoutReviewNestedInput
    votes?: ReviewVoteUncheckedUpdateManyWithoutReviewNestedInput
    reports?: ReviewReportUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ProductReviewCreateManyInput = {
    id?: string
    productId: string
    customerId: string
    rating: number
    comment?: string | null
    images?: ProductReviewCreateimagesInput | string[]
    createdAt?: Date | string
    verifiedPurchase?: boolean
  }

  export type ProductReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProductReviewUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedPurchase?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProductReviewUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedPurchase?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VendorReplyCreateInput = {
    id?: string
    message: string
    createdAt?: Date | string
    review: ProductReviewCreateNestedOneWithoutReplyInput
    vendor: UserCreateNestedOneWithoutVendorRepliesSentInput
  }

  export type VendorReplyUncheckedCreateInput = {
    id?: string
    reviewId: string
    vendorId: string
    message: string
    createdAt?: Date | string
  }

  export type VendorReplyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ProductReviewUpdateOneRequiredWithoutReplyNestedInput
    vendor?: UserUpdateOneRequiredWithoutVendorRepliesSentNestedInput
  }

  export type VendorReplyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorReplyCreateManyInput = {
    id?: string
    reviewId: string
    vendorId: string
    message: string
    createdAt?: Date | string
  }

  export type VendorReplyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorReplyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewVoteCreateInput = {
    id?: string
    isHelpful: boolean
    createdAt?: Date | string
    review: ProductReviewCreateNestedOneWithoutVotesInput
    user: UserCreateNestedOneWithoutReviewVotesInput
  }

  export type ReviewVoteUncheckedCreateInput = {
    id?: string
    reviewId: string
    userId: string
    isHelpful: boolean
    createdAt?: Date | string
  }

  export type ReviewVoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isHelpful?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ProductReviewUpdateOneRequiredWithoutVotesNestedInput
    user?: UserUpdateOneRequiredWithoutReviewVotesNestedInput
  }

  export type ReviewVoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isHelpful?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewVoteCreateManyInput = {
    id?: string
    reviewId: string
    userId: string
    isHelpful: boolean
    createdAt?: Date | string
  }

  export type ReviewVoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isHelpful?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewVoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isHelpful?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewReportCreateInput = {
    id?: string
    reason: string
    createdAt?: Date | string
    review: ProductReviewCreateNestedOneWithoutReportsInput
    user: UserCreateNestedOneWithoutReviewReportsInput
  }

  export type ReviewReportUncheckedCreateInput = {
    id?: string
    reviewId: string
    userId: string
    reason: string
    createdAt?: Date | string
  }

  export type ReviewReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ProductReviewUpdateOneRequiredWithoutReportsNestedInput
    user?: UserUpdateOneRequiredWithoutReviewReportsNestedInput
  }

  export type ReviewReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewReportCreateManyInput = {
    id?: string
    reviewId: string
    userId: string
    reason: string
    createdAt?: Date | string
  }

  export type ReviewReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorReviewCreateInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    vendor: UserCreateNestedOneWithoutVendorReviewsReceivedInput
    customer: UserCreateNestedOneWithoutVendorReviewsGivenInput
  }

  export type VendorReviewUncheckedCreateInput = {
    id?: string
    vendorId: string
    customerId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type VendorReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: UserUpdateOneRequiredWithoutVendorReviewsReceivedNestedInput
    customer?: UserUpdateOneRequiredWithoutVendorReviewsGivenNestedInput
  }

  export type VendorReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorReviewCreateManyInput = {
    id?: string
    vendorId: string
    customerId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type VendorReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    message: string
    type: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    message: string
    type: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    title: string
    message: string
    type: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginHistoryCreateInput = {
    id?: string
    method: string
    deviceId?: string | null
    location?: string | null
    ip?: string | null
    userAgent?: string | null
    geoCity?: string | null
    geoRegion?: string | null
    geoCountry?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutLoginHistoryInput
  }

  export type LoginHistoryUncheckedCreateInput = {
    id?: string
    userId: string
    method: string
    deviceId?: string | null
    location?: string | null
    ip?: string | null
    userAgent?: string | null
    geoCity?: string | null
    geoRegion?: string | null
    geoCountry?: string | null
    createdAt?: Date | string
  }

  export type LoginHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLoginHistoryNestedInput
  }

  export type LoginHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginHistoryCreateManyInput = {
    id?: string
    userId: string
    method: string
    deviceId?: string | null
    location?: string | null
    ip?: string | null
    userAgent?: string | null
    geoCity?: string | null
    geoRegion?: string | null
    geoCountry?: string | null
    createdAt?: Date | string
  }

  export type LoginHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateInput = {
    token: string
    expiresAt: Date | string
    user: UserCreateNestedOneWithoutPasswordResetTokenInput
  }

  export type PasswordResetTokenUncheckedCreateInput = {
    userId: string
    token: string
    expiresAt: Date | string
  }

  export type PasswordResetTokenUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPasswordResetTokenNestedInput
  }

  export type PasswordResetTokenUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateManyInput = {
    userId: string
    token: string
    expiresAt: Date | string
  }

  export type PasswordResetTokenUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    amount: number
    reference: string
    status: string
    paystackData?: NullableJsonNullValueInput | InputJsonValue
    channel?: string | null
    ipAddress?: string
    userAgent?: string
    deviceId?: string | null
    geoCity?: string | null
    geoCountry?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    user: UserCreateNestedOneWithoutPaymentsInput
    order: OrderCreateNestedOneWithoutPaymentsInput
    Receipt?: ReceiptCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    userId: string
    orderId: string
    amount: number
    reference: string
    status: string
    paystackData?: NullableJsonNullValueInput | InputJsonValue
    channel?: string | null
    ipAddress?: string
    userAgent?: string
    deviceId?: string | null
    geoCity?: string | null
    geoCountry?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    Receipt?: ReceiptUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paystackData?: NullableJsonNullValueInput | InputJsonValue
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
    order?: OrderUpdateOneRequiredWithoutPaymentsNestedInput
    Receipt?: ReceiptUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paystackData?: NullableJsonNullValueInput | InputJsonValue
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Receipt?: ReceiptUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentCreateManyInput = {
    id?: string
    userId: string
    orderId: string
    amount: number
    reference: string
    status: string
    paystackData?: NullableJsonNullValueInput | InputJsonValue
    channel?: string | null
    ipAddress?: string
    userAgent?: string
    deviceId?: string | null
    geoCity?: string | null
    geoCountry?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paystackData?: NullableJsonNullValueInput | InputJsonValue
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paystackData?: NullableJsonNullValueInput | InputJsonValue
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogCreateInput = {
    id?: string
    userId?: string | null
    action: string
    ipAddress: string
    userAgent: string
    deviceId?: string | null
    geoCity?: string | null
    geoRegion?: string | null
    geoCountry?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    path: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    action: string
    ipAddress: string
    userAgent: string
    deviceId?: string | null
    geoCity?: string | null
    geoRegion?: string | null
    geoCountry?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    path: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    path?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    path?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId?: string | null
    action: string
    ipAddress: string
    userAgent: string
    deviceId?: string | null
    geoCity?: string | null
    geoRegion?: string | null
    geoCountry?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    path: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    path?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    path?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundRequestCreateInput = {
    id?: string
    paymentRef: string
    reason: string
    status?: $Enums.RefundStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRefundRequestInput
  }

  export type RefundRequestUncheckedCreateInput = {
    id?: string
    userId: string
    paymentRef: string
    reason: string
    status?: $Enums.RefundStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefundRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRef?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRefundRequestNestedInput
  }

  export type RefundRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    paymentRef?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundRequestCreateManyInput = {
    id?: string
    userId: string
    paymentRef: string
    reason: string
    status?: $Enums.RefundStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefundRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRef?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    paymentRef?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartCreateInput = {
    id?: string
    basePrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: UserCreateNestedOneWithoutCartsInput
    items?: CartItemCreateNestedManyWithoutCartInput
  }

  export type CartUncheckedCreateInput = {
    id?: string
    customerId: string
    basePrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CartItemUncheckedCreateNestedManyWithoutCartInput
  }

  export type CartUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutCartsNestedInput
    items?: CartItemUpdateManyWithoutCartNestedInput
  }

  export type CartUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CartItemUncheckedUpdateManyWithoutCartNestedInput
  }

  export type CartCreateManyInput = {
    id?: string
    customerId: string
    basePrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemCreateInput = {
    id?: string
    quantity: number
    unitPrice: number
    subtotal: number
    specialRequest?: string | null
    cart: CartCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutCartItemInput
    options?: CartItemOptionCreateNestedManyWithoutCartItemInput
  }

  export type CartItemUncheckedCreateInput = {
    id?: string
    cartId: string
    productId: string
    quantity: number
    unitPrice: number
    subtotal: number
    specialRequest?: string | null
    options?: CartItemOptionUncheckedCreateNestedManyWithoutCartItemInput
  }

  export type CartItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    specialRequest?: NullableStringFieldUpdateOperationsInput | string | null
    cart?: CartUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutCartItemNestedInput
    options?: CartItemOptionUpdateManyWithoutCartItemNestedInput
  }

  export type CartItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    specialRequest?: NullableStringFieldUpdateOperationsInput | string | null
    options?: CartItemOptionUncheckedUpdateManyWithoutCartItemNestedInput
  }

  export type CartItemCreateManyInput = {
    id?: string
    cartId: string
    productId: string
    quantity: number
    unitPrice: number
    subtotal: number
    specialRequest?: string | null
  }

  export type CartItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    specialRequest?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CartItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    specialRequest?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CartItemOptionCreateInput = {
    id?: string
    name: string
    price: number
    cartItem: CartItemCreateNestedOneWithoutOptionsInput
    productOption: ProductOptionCreateNestedOneWithoutCartItemOptionInput
  }

  export type CartItemOptionUncheckedCreateInput = {
    id?: string
    cartItemId: string
    productOptionId: string
    name: string
    price: number
  }

  export type CartItemOptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    cartItem?: CartItemUpdateOneRequiredWithoutOptionsNestedInput
    productOption?: ProductOptionUpdateOneRequiredWithoutCartItemOptionNestedInput
  }

  export type CartItemOptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartItemId?: StringFieldUpdateOperationsInput | string
    productOptionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type CartItemOptionCreateManyInput = {
    id?: string
    cartItemId: string
    productOptionId: string
    name: string
    price: number
  }

  export type CartItemOptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type CartItemOptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartItemId?: StringFieldUpdateOperationsInput | string
    productOptionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type UserPaymentMethodCreateInput = {
    id?: string
    cardToken: string
    last4: string
    brand: string
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserPaymentMethodInput
  }

  export type UserPaymentMethodUncheckedCreateInput = {
    id?: string
    userId: string
    cardToken: string
    last4: string
    brand: string
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPaymentMethodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardToken?: StringFieldUpdateOperationsInput | string
    last4?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserPaymentMethodNestedInput
  }

  export type UserPaymentMethodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cardToken?: StringFieldUpdateOperationsInput | string
    last4?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPaymentMethodCreateManyInput = {
    id?: string
    userId: string
    cardToken: string
    last4: string
    brand: string
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPaymentMethodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardToken?: StringFieldUpdateOperationsInput | string
    last4?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPaymentMethodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cardToken?: StringFieldUpdateOperationsInput | string
    last4?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryPersonCreateInput = {
    id?: string
    vehicleType?: string | null
    licensePlate?: string | null
    status?: string
    rating?: number
    totalDeliveries?: number
    isOnline?: boolean
    latitude?: number | null
    longitude?: number | null
    lastSeenAt?: Date | string | null
    walletBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDeliveryPersonInput
    assignedOrders?: DeliveryAssignmentCreateNestedManyWithoutDeliveryPersonInput
    earnings?: DeliveryEarningCreateNestedManyWithoutDeliveryPersonInput
    DriverLocationLog?: DriverLocationLogCreateNestedManyWithoutDriverInput
    Activity?: ActivityCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryPersonUncheckedCreateInput = {
    id?: string
    userId: string
    vehicleType?: string | null
    licensePlate?: string | null
    status?: string
    rating?: number
    totalDeliveries?: number
    isOnline?: boolean
    latitude?: number | null
    longitude?: number | null
    lastSeenAt?: Date | string | null
    walletBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedOrders?: DeliveryAssignmentUncheckedCreateNestedManyWithoutDeliveryPersonInput
    earnings?: DeliveryEarningUncheckedCreateNestedManyWithoutDeliveryPersonInput
    DriverLocationLog?: DriverLocationLogUncheckedCreateNestedManyWithoutDriverInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryPersonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    totalDeliveries?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDeliveryPersonNestedInput
    assignedOrders?: DeliveryAssignmentUpdateManyWithoutDeliveryPersonNestedInput
    earnings?: DeliveryEarningUpdateManyWithoutDeliveryPersonNestedInput
    DriverLocationLog?: DriverLocationLogUpdateManyWithoutDriverNestedInput
    Activity?: ActivityUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryPersonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    totalDeliveries?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedOrders?: DeliveryAssignmentUncheckedUpdateManyWithoutDeliveryPersonNestedInput
    earnings?: DeliveryEarningUncheckedUpdateManyWithoutDeliveryPersonNestedInput
    DriverLocationLog?: DriverLocationLogUncheckedUpdateManyWithoutDriverNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryPersonCreateManyInput = {
    id?: string
    userId: string
    vehicleType?: string | null
    licensePlate?: string | null
    status?: string
    rating?: number
    totalDeliveries?: number
    isOnline?: boolean
    latitude?: number | null
    longitude?: number | null
    lastSeenAt?: Date | string | null
    walletBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryPersonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    totalDeliveries?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryPersonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    totalDeliveries?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryAssignmentCreateInput = {
    id?: string
    status?: $Enums.DeliveryStatus
    assignedAt?: Date | string
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    declinedAt?: Date | string | null
    timeoutSeconds?: number
    attempts?: number
    batchId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutAssignmentsInput
    deliveryPerson: DeliveryPersonCreateNestedOneWithoutAssignedOrdersInput
  }

  export type DeliveryAssignmentUncheckedCreateInput = {
    id?: string
    orderId: string
    deliveryPersonId: string
    status?: $Enums.DeliveryStatus
    assignedAt?: Date | string
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    declinedAt?: Date | string | null
    timeoutSeconds?: number
    attempts?: number
    batchId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeoutSeconds?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutAssignmentsNestedInput
    deliveryPerson?: DeliveryPersonUpdateOneRequiredWithoutAssignedOrdersNestedInput
  }

  export type DeliveryAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    deliveryPersonId?: StringFieldUpdateOperationsInput | string
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeoutSeconds?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryAssignmentCreateManyInput = {
    id?: string
    orderId: string
    deliveryPersonId: string
    status?: $Enums.DeliveryStatus
    assignedAt?: Date | string
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    declinedAt?: Date | string | null
    timeoutSeconds?: number
    attempts?: number
    batchId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeoutSeconds?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    deliveryPersonId?: StringFieldUpdateOperationsInput | string
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeoutSeconds?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryEarningCreateInput = {
    id?: string
    baseFee: number
    distanceFee: number
    tip?: number
    deductions?: number
    totalEarned: number
    createdAt?: Date | string
    deliveryPerson: DeliveryPersonCreateNestedOneWithoutEarningsInput
    order: OrderCreateNestedOneWithoutEarningsInput
  }

  export type DeliveryEarningUncheckedCreateInput = {
    id?: string
    deliveryPersonId: string
    orderId: string
    baseFee: number
    distanceFee: number
    tip?: number
    deductions?: number
    totalEarned: number
    createdAt?: Date | string
  }

  export type DeliveryEarningUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    baseFee?: FloatFieldUpdateOperationsInput | number
    distanceFee?: FloatFieldUpdateOperationsInput | number
    tip?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    totalEarned?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryPerson?: DeliveryPersonUpdateOneRequiredWithoutEarningsNestedInput
    order?: OrderUpdateOneRequiredWithoutEarningsNestedInput
  }

  export type DeliveryEarningUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryPersonId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    baseFee?: FloatFieldUpdateOperationsInput | number
    distanceFee?: FloatFieldUpdateOperationsInput | number
    tip?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    totalEarned?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryEarningCreateManyInput = {
    id?: string
    deliveryPersonId: string
    orderId: string
    baseFee: number
    distanceFee: number
    tip?: number
    deductions?: number
    totalEarned: number
    createdAt?: Date | string
  }

  export type DeliveryEarningUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    baseFee?: FloatFieldUpdateOperationsInput | number
    distanceFee?: FloatFieldUpdateOperationsInput | number
    tip?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    totalEarned?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryEarningUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryPersonId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    baseFee?: FloatFieldUpdateOperationsInput | number
    distanceFee?: FloatFieldUpdateOperationsInput | number
    tip?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    totalEarned?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverLocationLogCreateInput = {
    id?: string
    latitude: number
    longitude: number
    timestamp?: Date | string
    driver: DeliveryPersonCreateNestedOneWithoutDriverLocationLogInput
  }

  export type DriverLocationLogUncheckedCreateInput = {
    id?: string
    driverId: string
    latitude: number
    longitude: number
    timestamp?: Date | string
  }

  export type DriverLocationLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    driver?: DeliveryPersonUpdateOneRequiredWithoutDriverLocationLogNestedInput
  }

  export type DriverLocationLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverLocationLogCreateManyInput = {
    id?: string
    driverId: string
    latitude: number
    longitude: number
    timestamp?: Date | string
  }

  export type DriverLocationLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverLocationLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateInput = {
    id?: string
    type: $Enums.ActivityType
    title: string
    message: string
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    order?: OrderCreateNestedOneWithoutActivityInput
    vendor?: UserCreateNestedOneWithoutVendorActivitiesInput
    customer?: UserCreateNestedOneWithoutCustomerActivitiesInput
    delivery?: DeliveryPersonCreateNestedOneWithoutActivityInput
  }

  export type ActivityUncheckedCreateInput = {
    id?: string
    orderId?: string | null
    vendorId?: string | null
    customerId?: string | null
    deliveryId?: string | null
    type: $Enums.ActivityType
    title: string
    message: string
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneWithoutActivityNestedInput
    vendor?: UserUpdateOneWithoutVendorActivitiesNestedInput
    customer?: UserUpdateOneWithoutCustomerActivitiesNestedInput
    delivery?: DeliveryPersonUpdateOneWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateManyInput = {
    id?: string
    orderId?: string | null
    vendorId?: string | null
    customerId?: string | null
    deliveryId?: string | null
    type: $Enums.ActivityType
    title: string
    message: string
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryBroadcastCreateInput = {
    id?: string
    driverIds?: DeliveryBroadcastCreatedriverIdsInput | string[]
    acceptedDriverId?: string | null
    status: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutDeliveryBroadcastInput
  }

  export type DeliveryBroadcastUncheckedCreateInput = {
    id?: string
    orderId: string
    driverIds?: DeliveryBroadcastCreatedriverIdsInput | string[]
    acceptedDriverId?: string | null
    status: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryBroadcastUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverIds?: DeliveryBroadcastUpdatedriverIdsInput | string[]
    acceptedDriverId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutDeliveryBroadcastNestedInput
  }

  export type DeliveryBroadcastUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    driverIds?: DeliveryBroadcastUpdatedriverIdsInput | string[]
    acceptedDriverId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryBroadcastCreateManyInput = {
    id?: string
    orderId: string
    driverIds?: DeliveryBroadcastCreatedriverIdsInput | string[]
    acceptedDriverId?: string | null
    status: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryBroadcastUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverIds?: DeliveryBroadcastUpdatedriverIdsInput | string[]
    acceptedDriverId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryBroadcastUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    driverIds?: DeliveryBroadcastUpdatedriverIdsInput | string[]
    acceptedDriverId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookEventCreateInput = {
    id?: string
    reference: string
    event: string
    payload: JsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    processedAt?: Date | string | null
  }

  export type WebhookEventUncheckedCreateInput = {
    id?: string
    reference: string
    event: string
    payload: JsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    processedAt?: Date | string | null
  }

  export type WebhookEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WebhookEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WebhookEventCreateManyInput = {
    id?: string
    reference: string
    event: string
    payload: JsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    processedAt?: Date | string | null
  }

  export type WebhookEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WebhookEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReceiptCreateInput = {
    id?: string
    pdfUrl?: string | null
    createdAt?: Date | string
    payment: PaymentCreateNestedOneWithoutReceiptInput
  }

  export type ReceiptUncheckedCreateInput = {
    id?: string
    paymentId: string
    pdfUrl?: string | null
    createdAt?: Date | string
  }

  export type ReceiptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUpdateOneRequiredWithoutReceiptNestedInput
  }

  export type ReceiptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceiptCreateManyInput = {
    id?: string
    paymentId: string
    pdfUrl?: string | null
    createdAt?: Date | string
  }

  export type ReceiptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceiptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorFollowerCreateInput = {
    id?: string
    createdAt?: Date | string
    vendor: UserCreateNestedOneWithoutFollowersInput
    customer: UserCreateNestedOneWithoutFollowingInput
  }

  export type VendorFollowerUncheckedCreateInput = {
    id?: string
    vendorId: string
    customerId: string
    createdAt?: Date | string
  }

  export type VendorFollowerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: UserUpdateOneRequiredWithoutFollowersNestedInput
    customer?: UserUpdateOneRequiredWithoutFollowingNestedInput
  }

  export type VendorFollowerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorFollowerCreateManyInput = {
    id?: string
    vendorId: string
    customerId: string
    createdAt?: Date | string
  }

  export type VendorFollowerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorFollowerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialOrderRequestCreateInput = {
    id?: string
    quantity: number
    message: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: UserCreateNestedOneWithoutSpecialRequestsMadeInput
    vendor?: UserCreateNestedOneWithoutSpecialRequestsReceivedInput
    product: ProductCreateNestedOneWithoutSpecialRequestsInput
    offers?: SpecialOrderOfferCreateNestedManyWithoutRequestInput
  }

  export type SpecialOrderRequestUncheckedCreateInput = {
    id?: string
    customerId: string
    vendorId?: string | null
    productId: string
    quantity: number
    message: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    offers?: SpecialOrderOfferUncheckedCreateNestedManyWithoutRequestInput
  }

  export type SpecialOrderRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutSpecialRequestsMadeNestedInput
    vendor?: UserUpdateOneWithoutSpecialRequestsReceivedNestedInput
    product?: ProductUpdateOneRequiredWithoutSpecialRequestsNestedInput
    offers?: SpecialOrderOfferUpdateManyWithoutRequestNestedInput
  }

  export type SpecialOrderRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offers?: SpecialOrderOfferUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type SpecialOrderRequestCreateManyInput = {
    id?: string
    customerId: string
    vendorId?: string | null
    productId: string
    quantity: number
    message: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpecialOrderRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialOrderRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialOrderOfferCreateInput = {
    id?: string
    price: number
    message?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    request: SpecialOrderRequestCreateNestedOneWithoutOffersInput
    vendor: UserCreateNestedOneWithoutSpecialOffersSentInput
  }

  export type SpecialOrderOfferUncheckedCreateInput = {
    id?: string
    requestId: string
    vendorId: string
    price: number
    message?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpecialOrderOfferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: SpecialOrderRequestUpdateOneRequiredWithoutOffersNestedInput
    vendor?: UserUpdateOneRequiredWithoutSpecialOffersSentNestedInput
  }

  export type SpecialOrderOfferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialOrderOfferCreateManyInput = {
    id?: string
    requestId: string
    vendorId: string
    price: number
    message?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpecialOrderOfferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialOrderOfferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableFilter<$PrismaModel> | $Enums.Role | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type VendorReviewListRelationFilter = {
    every?: VendorReviewWhereInput
    some?: VendorReviewWhereInput
    none?: VendorReviewWhereInput
  }

  export type ProductReviewListRelationFilter = {
    every?: ProductReviewWhereInput
    some?: ProductReviewWhereInput
    none?: ProductReviewWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type VendorReplyListRelationFilter = {
    every?: VendorReplyWhereInput
    some?: VendorReplyWhereInput
    none?: VendorReplyWhereInput
  }

  export type ReviewVoteListRelationFilter = {
    every?: ReviewVoteWhereInput
    some?: ReviewVoteWhereInput
    none?: ReviewVoteWhereInput
  }

  export type ReviewReportListRelationFilter = {
    every?: ReviewReportWhereInput
    some?: ReviewReportWhereInput
    none?: ReviewReportWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type LoginHistoryListRelationFilter = {
    every?: LoginHistoryWhereInput
    some?: LoginHistoryWhereInput
    none?: LoginHistoryWhereInput
  }

  export type AddressListRelationFilter = {
    every?: AddressWhereInput
    some?: AddressWhereInput
    none?: AddressWhereInput
  }

  export type CartListRelationFilter = {
    every?: CartWhereInput
    some?: CartWhereInput
    none?: CartWhereInput
  }

  export type UserPaymentMethodListRelationFilter = {
    every?: UserPaymentMethodWhereInput
    some?: UserPaymentMethodWhereInput
    none?: UserPaymentMethodWhereInput
  }

  export type DeliveryPersonNullableScalarRelationFilter = {
    is?: DeliveryPersonWhereInput | null
    isNot?: DeliveryPersonWhereInput | null
  }

  export type PasswordResetTokenNullableScalarRelationFilter = {
    is?: PasswordResetTokenWhereInput | null
    isNot?: PasswordResetTokenWhereInput | null
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type RefundRequestListRelationFilter = {
    every?: RefundRequestWhereInput
    some?: RefundRequestWhereInput
    none?: RefundRequestWhereInput
  }

  export type ActivityListRelationFilter = {
    every?: ActivityWhereInput
    some?: ActivityWhereInput
    none?: ActivityWhereInput
  }

  export type VendorFollowerListRelationFilter = {
    every?: VendorFollowerWhereInput
    some?: VendorFollowerWhereInput
    none?: VendorFollowerWhereInput
  }

  export type SpecialOrderRequestListRelationFilter = {
    every?: SpecialOrderRequestWhereInput
    some?: SpecialOrderRequestWhereInput
    none?: SpecialOrderRequestWhereInput
  }

  export type SpecialOrderOfferListRelationFilter = {
    every?: SpecialOrderOfferWhereInput
    some?: SpecialOrderOfferWhereInput
    none?: SpecialOrderOfferWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorReplyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewVoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LoginHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CartOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserPaymentMethodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefundRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorFollowerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpecialOrderRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpecialOrderOfferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    password?: SortOrder
    avatarUrl?: SortOrder
    preferences?: SortOrder
    bio?: SortOrder
    role?: SortOrder
    brandName?: SortOrder
    brandLogo?: SortOrder
    googleId?: SortOrder
    tokenVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authProviders?: SortOrder
    lastLoginAt?: SortOrder
    loginMethod?: SortOrder
    isEmailVerified?: SortOrder
    emailVerificationToken?: SortOrder
    emailVerificationExpiresAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    tokenVersion?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    password?: SortOrder
    avatarUrl?: SortOrder
    bio?: SortOrder
    role?: SortOrder
    brandName?: SortOrder
    brandLogo?: SortOrder
    googleId?: SortOrder
    tokenVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
    loginMethod?: SortOrder
    isEmailVerified?: SortOrder
    emailVerificationToken?: SortOrder
    emailVerificationExpiresAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    password?: SortOrder
    avatarUrl?: SortOrder
    bio?: SortOrder
    role?: SortOrder
    brandName?: SortOrder
    brandLogo?: SortOrder
    googleId?: SortOrder
    tokenVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
    loginMethod?: SortOrder
    isEmailVerified?: SortOrder
    emailVerificationToken?: SortOrder
    emailVerificationExpiresAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    tokenVersion?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.Role | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumRoleNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    label?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    zipCode?: SortOrder
    landmark?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
  }

  export type AddressAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    label?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    zipCode?: SortOrder
    landmark?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    label?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    zipCode?: SortOrder
    landmark?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
  }

  export type AddressSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryFilter<$PrismaModel> | $Enums.Category
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type ProductOptionListRelationFilter = {
    every?: ProductOptionWhereInput
    some?: ProductOptionWhereInput
    none?: ProductOptionWhereInput
  }

  export type CartItemListRelationFilter = {
    every?: CartItemWhereInput
    some?: CartItemWhereInput
    none?: CartItemWhereInput
  }

  export type ProductScheduleNullableScalarRelationFilter = {
    is?: ProductScheduleWhereInput | null
    isNot?: ProductScheduleWhereInput | null
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CartItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    archived?: SortOrder
    category?: SortOrder
    images?: SortOrder
    thumbnail?: SortOrder
    video?: SortOrder
    vendorId?: SortOrder
    averageRating?: SortOrder
    reviewCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    totalViews?: SortOrder
    popularityScore?: SortOrder
    popularityUpdatedAt?: SortOrder
    popularityPercent?: SortOrder
    isNew?: SortOrder
    isLive?: SortOrder
    liveUntil?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    price?: SortOrder
    averageRating?: SortOrder
    reviewCount?: SortOrder
    totalViews?: SortOrder
    popularityScore?: SortOrder
    popularityPercent?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    archived?: SortOrder
    category?: SortOrder
    thumbnail?: SortOrder
    vendorId?: SortOrder
    averageRating?: SortOrder
    reviewCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    totalViews?: SortOrder
    popularityScore?: SortOrder
    popularityUpdatedAt?: SortOrder
    popularityPercent?: SortOrder
    isNew?: SortOrder
    isLive?: SortOrder
    liveUntil?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    archived?: SortOrder
    category?: SortOrder
    thumbnail?: SortOrder
    vendorId?: SortOrder
    averageRating?: SortOrder
    reviewCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    totalViews?: SortOrder
    popularityScore?: SortOrder
    popularityUpdatedAt?: SortOrder
    popularityPercent?: SortOrder
    isNew?: SortOrder
    isLive?: SortOrder
    liveUntil?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    price?: SortOrder
    averageRating?: SortOrder
    reviewCount?: SortOrder
    totalViews?: SortOrder
    popularityScore?: SortOrder
    popularityPercent?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryWithAggregatesFilter<$PrismaModel> | $Enums.Category
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategoryFilter<$PrismaModel>
    _max?: NestedEnumCategoryFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type ProductScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    goLiveAt?: SortOrder
    takeDownAt?: SortOrder
    isLive?: SortOrder
    graceMinutes?: SortOrder
    autoGraceEnabled?: SortOrder
    manualGraceEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductScheduleAvgOrderByAggregateInput = {
    graceMinutes?: SortOrder
  }

  export type ProductScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    goLiveAt?: SortOrder
    takeDownAt?: SortOrder
    isLive?: SortOrder
    graceMinutes?: SortOrder
    autoGraceEnabled?: SortOrder
    manualGraceEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    goLiveAt?: SortOrder
    takeDownAt?: SortOrder
    isLive?: SortOrder
    graceMinutes?: SortOrder
    autoGraceEnabled?: SortOrder
    manualGraceEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductScheduleSumOrderByAggregateInput = {
    graceMinutes?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type OrderItemOptionListRelationFilter = {
    every?: OrderItemOptionWhereInput
    some?: OrderItemOptionWhereInput
    none?: OrderItemOptionWhereInput
  }

  export type CartItemOptionListRelationFilter = {
    every?: CartItemOptionWhereInput
    some?: CartItemOptionWhereInput
    none?: CartItemOptionWhereInput
  }

  export type OrderItemOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CartItemOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOptionCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    price?: SortOrder
  }

  export type ProductOptionAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type ProductOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    price?: SortOrder
  }

  export type ProductOptionMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    price?: SortOrder
  }

  export type ProductOptionSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type EnumPaymentStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentStatusNullableFilter<$PrismaModel> | $Enums.PaymentStatus | null
  }

  export type AddressNullableScalarRelationFilter = {
    is?: AddressWhereInput | null
    isNot?: AddressWhereInput | null
  }

  export type DeliveryAssignmentListRelationFilter = {
    every?: DeliveryAssignmentWhereInput
    some?: DeliveryAssignmentWhereInput
    none?: DeliveryAssignmentWhereInput
  }

  export type DeliveryEarningListRelationFilter = {
    every?: DeliveryEarningWhereInput
    some?: DeliveryEarningWhereInput
    none?: DeliveryEarningWhereInput
  }

  export type DeliveryBroadcastListRelationFilter = {
    every?: DeliveryBroadcastWhereInput
    some?: DeliveryBroadcastWhereInput
    none?: DeliveryBroadcastWhereInput
  }

  export type DeliveryAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeliveryEarningOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeliveryBroadcastOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    vendorId?: SortOrder
    addressId?: SortOrder
    basePrice?: SortOrder
    extraCharge?: SortOrder
    totalPrice?: SortOrder
    vendorNote?: SortOrder
    customerApproval?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentInitiatedAt?: SortOrder
    paymentStartedAt?: SortOrder
    paidAt?: SortOrder
    paymentStatus?: SortOrder
    cancelledAt?: SortOrder
    cancellationReason?: SortOrder
    protectedUntil?: SortOrder
    paymentGraceMinutes?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    basePrice?: SortOrder
    extraCharge?: SortOrder
    totalPrice?: SortOrder
    paymentGraceMinutes?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    vendorId?: SortOrder
    addressId?: SortOrder
    basePrice?: SortOrder
    extraCharge?: SortOrder
    totalPrice?: SortOrder
    vendorNote?: SortOrder
    customerApproval?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentInitiatedAt?: SortOrder
    paymentStartedAt?: SortOrder
    paidAt?: SortOrder
    paymentStatus?: SortOrder
    cancelledAt?: SortOrder
    cancellationReason?: SortOrder
    protectedUntil?: SortOrder
    paymentGraceMinutes?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    vendorId?: SortOrder
    addressId?: SortOrder
    basePrice?: SortOrder
    extraCharge?: SortOrder
    totalPrice?: SortOrder
    vendorNote?: SortOrder
    customerApproval?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentInitiatedAt?: SortOrder
    paymentStartedAt?: SortOrder
    paidAt?: SortOrder
    paymentStatus?: SortOrder
    cancelledAt?: SortOrder
    cancellationReason?: SortOrder
    protectedUntil?: SortOrder
    paymentGraceMinutes?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    basePrice?: SortOrder
    extraCharge?: SortOrder
    totalPrice?: SortOrder
    paymentGraceMinutes?: SortOrder
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type EnumPaymentStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusNullableFilter<$PrismaModel>
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
  }

  export type OrderItemScalarRelationFilter = {
    is?: OrderItemWhereInput
    isNot?: OrderItemWhereInput
  }

  export type ProductOptionScalarRelationFilter = {
    is?: ProductOptionWhereInput
    isNot?: ProductOptionWhereInput
  }

  export type OrderItemOptionCountOrderByAggregateInput = {
    id?: SortOrder
    optionId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    orderItemId?: SortOrder
  }

  export type OrderItemOptionAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type OrderItemOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    optionId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    orderItemId?: SortOrder
  }

  export type OrderItemOptionMinOrderByAggregateInput = {
    id?: SortOrder
    optionId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    orderItemId?: SortOrder
  }

  export type OrderItemOptionSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type VendorReplyNullableScalarRelationFilter = {
    is?: VendorReplyWhereInput | null
    isNot?: VendorReplyWhereInput | null
  }

  export type ProductReviewCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    customerId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    images?: SortOrder
    createdAt?: SortOrder
    verifiedPurchase?: SortOrder
  }

  export type ProductReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ProductReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    customerId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    verifiedPurchase?: SortOrder
  }

  export type ProductReviewMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    customerId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    verifiedPurchase?: SortOrder
  }

  export type ProductReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ProductReviewScalarRelationFilter = {
    is?: ProductReviewWhereInput
    isNot?: ProductReviewWhereInput
  }

  export type VendorReplyCountOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    vendorId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type VendorReplyMaxOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    vendorId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type VendorReplyMinOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    vendorId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewVoteReviewIdUserIdCompoundUniqueInput = {
    reviewId: string
    userId: string
  }

  export type ReviewVoteCountOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    isHelpful?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewVoteMaxOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    isHelpful?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewVoteMinOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    isHelpful?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewReportCountOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewReportMaxOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewReportMinOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type VendorReviewCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    customerId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type VendorReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type VendorReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    customerId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type VendorReviewMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    customerId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type VendorReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    metadata?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type LoginHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    method?: SortOrder
    deviceId?: SortOrder
    location?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    geoCity?: SortOrder
    geoRegion?: SortOrder
    geoCountry?: SortOrder
    createdAt?: SortOrder
  }

  export type LoginHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    method?: SortOrder
    deviceId?: SortOrder
    location?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    geoCity?: SortOrder
    geoRegion?: SortOrder
    geoCountry?: SortOrder
    createdAt?: SortOrder
  }

  export type LoginHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    method?: SortOrder
    deviceId?: SortOrder
    location?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    geoCity?: SortOrder
    geoRegion?: SortOrder
    geoCountry?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenCountOrderByAggregateInput = {
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
  }

  export type PasswordResetTokenMaxOrderByAggregateInput = {
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
  }

  export type PasswordResetTokenMinOrderByAggregateInput = {
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
  }

  export type ReceiptListRelationFilter = {
    every?: ReceiptWhereInput
    some?: ReceiptWhereInput
    none?: ReceiptWhereInput
  }

  export type ReceiptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    paystackData?: SortOrder
    channel?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceId?: SortOrder
    geoCity?: SortOrder
    geoCountry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metadata?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    channel?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceId?: SortOrder
    geoCity?: SortOrder
    geoCountry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    channel?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceId?: SortOrder
    geoCity?: SortOrder
    geoCountry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceId?: SortOrder
    geoCity?: SortOrder
    geoRegion?: SortOrder
    geoCountry?: SortOrder
    details?: SortOrder
    path?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceId?: SortOrder
    geoCity?: SortOrder
    geoRegion?: SortOrder
    geoCountry?: SortOrder
    path?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    deviceId?: SortOrder
    geoCity?: SortOrder
    geoRegion?: SortOrder
    geoCountry?: SortOrder
    path?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumRefundStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundStatus | EnumRefundStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRefundStatusFilter<$PrismaModel> | $Enums.RefundStatus
  }

  export type RefundRequestCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    paymentRef?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RefundRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    paymentRef?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RefundRequestMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    paymentRef?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRefundStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundStatus | EnumRefundStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRefundStatusWithAggregatesFilter<$PrismaModel> | $Enums.RefundStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRefundStatusFilter<$PrismaModel>
    _max?: NestedEnumRefundStatusFilter<$PrismaModel>
  }

  export type CartCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    basePrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartAvgOrderByAggregateInput = {
    basePrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type CartMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    basePrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    basePrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartSumOrderByAggregateInput = {
    basePrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type CartScalarRelationFilter = {
    is?: CartWhereInput
    isNot?: CartWhereInput
  }

  export type CartItemCountOrderByAggregateInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
    specialRequest?: SortOrder
  }

  export type CartItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
  }

  export type CartItemMaxOrderByAggregateInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
    specialRequest?: SortOrder
  }

  export type CartItemMinOrderByAggregateInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
    specialRequest?: SortOrder
  }

  export type CartItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
  }

  export type CartItemScalarRelationFilter = {
    is?: CartItemWhereInput
    isNot?: CartItemWhereInput
  }

  export type CartItemOptionCountOrderByAggregateInput = {
    id?: SortOrder
    cartItemId?: SortOrder
    productOptionId?: SortOrder
    name?: SortOrder
    price?: SortOrder
  }

  export type CartItemOptionAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type CartItemOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    cartItemId?: SortOrder
    productOptionId?: SortOrder
    name?: SortOrder
    price?: SortOrder
  }

  export type CartItemOptionMinOrderByAggregateInput = {
    id?: SortOrder
    cartItemId?: SortOrder
    productOptionId?: SortOrder
    name?: SortOrder
    price?: SortOrder
  }

  export type CartItemOptionSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type UserPaymentMethodCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cardToken?: SortOrder
    last4?: SortOrder
    brand?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPaymentMethodMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cardToken?: SortOrder
    last4?: SortOrder
    brand?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPaymentMethodMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cardToken?: SortOrder
    last4?: SortOrder
    brand?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DriverLocationLogListRelationFilter = {
    every?: DriverLocationLogWhereInput
    some?: DriverLocationLogWhereInput
    none?: DriverLocationLogWhereInput
  }

  export type DriverLocationLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeliveryPersonCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleType?: SortOrder
    licensePlate?: SortOrder
    status?: SortOrder
    rating?: SortOrder
    totalDeliveries?: SortOrder
    isOnline?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    lastSeenAt?: SortOrder
    walletBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliveryPersonAvgOrderByAggregateInput = {
    rating?: SortOrder
    totalDeliveries?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    walletBalance?: SortOrder
  }

  export type DeliveryPersonMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleType?: SortOrder
    licensePlate?: SortOrder
    status?: SortOrder
    rating?: SortOrder
    totalDeliveries?: SortOrder
    isOnline?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    lastSeenAt?: SortOrder
    walletBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliveryPersonMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleType?: SortOrder
    licensePlate?: SortOrder
    status?: SortOrder
    rating?: SortOrder
    totalDeliveries?: SortOrder
    isOnline?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    lastSeenAt?: SortOrder
    walletBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliveryPersonSumOrderByAggregateInput = {
    rating?: SortOrder
    totalDeliveries?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    walletBalance?: SortOrder
  }

  export type EnumDeliveryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryStatus | EnumDeliveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryStatusFilter<$PrismaModel> | $Enums.DeliveryStatus
  }

  export type DeliveryPersonScalarRelationFilter = {
    is?: DeliveryPersonWhereInput
    isNot?: DeliveryPersonWhereInput
  }

  export type DeliveryAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    deliveryPersonId?: SortOrder
    status?: SortOrder
    assignedAt?: SortOrder
    acceptedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    declinedAt?: SortOrder
    timeoutSeconds?: SortOrder
    attempts?: SortOrder
    batchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliveryAssignmentAvgOrderByAggregateInput = {
    timeoutSeconds?: SortOrder
    attempts?: SortOrder
  }

  export type DeliveryAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    deliveryPersonId?: SortOrder
    status?: SortOrder
    assignedAt?: SortOrder
    acceptedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    declinedAt?: SortOrder
    timeoutSeconds?: SortOrder
    attempts?: SortOrder
    batchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliveryAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    deliveryPersonId?: SortOrder
    status?: SortOrder
    assignedAt?: SortOrder
    acceptedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    declinedAt?: SortOrder
    timeoutSeconds?: SortOrder
    attempts?: SortOrder
    batchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliveryAssignmentSumOrderByAggregateInput = {
    timeoutSeconds?: SortOrder
    attempts?: SortOrder
  }

  export type EnumDeliveryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryStatus | EnumDeliveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeliveryStatusFilter<$PrismaModel>
    _max?: NestedEnumDeliveryStatusFilter<$PrismaModel>
  }

  export type DeliveryEarningCountOrderByAggregateInput = {
    id?: SortOrder
    deliveryPersonId?: SortOrder
    orderId?: SortOrder
    baseFee?: SortOrder
    distanceFee?: SortOrder
    tip?: SortOrder
    deductions?: SortOrder
    totalEarned?: SortOrder
    createdAt?: SortOrder
  }

  export type DeliveryEarningAvgOrderByAggregateInput = {
    baseFee?: SortOrder
    distanceFee?: SortOrder
    tip?: SortOrder
    deductions?: SortOrder
    totalEarned?: SortOrder
  }

  export type DeliveryEarningMaxOrderByAggregateInput = {
    id?: SortOrder
    deliveryPersonId?: SortOrder
    orderId?: SortOrder
    baseFee?: SortOrder
    distanceFee?: SortOrder
    tip?: SortOrder
    deductions?: SortOrder
    totalEarned?: SortOrder
    createdAt?: SortOrder
  }

  export type DeliveryEarningMinOrderByAggregateInput = {
    id?: SortOrder
    deliveryPersonId?: SortOrder
    orderId?: SortOrder
    baseFee?: SortOrder
    distanceFee?: SortOrder
    tip?: SortOrder
    deductions?: SortOrder
    totalEarned?: SortOrder
    createdAt?: SortOrder
  }

  export type DeliveryEarningSumOrderByAggregateInput = {
    baseFee?: SortOrder
    distanceFee?: SortOrder
    tip?: SortOrder
    deductions?: SortOrder
    totalEarned?: SortOrder
  }

  export type DriverLocationLogCountOrderByAggregateInput = {
    id?: SortOrder
    driverId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    timestamp?: SortOrder
  }

  export type DriverLocationLogAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type DriverLocationLogMaxOrderByAggregateInput = {
    id?: SortOrder
    driverId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    timestamp?: SortOrder
  }

  export type DriverLocationLogMinOrderByAggregateInput = {
    id?: SortOrder
    driverId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    timestamp?: SortOrder
  }

  export type DriverLocationLogSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type EnumActivityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeFilter<$PrismaModel> | $Enums.ActivityType
  }

  export type OrderNullableScalarRelationFilter = {
    is?: OrderWhereInput | null
    isNot?: OrderWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ActivityCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    vendorId?: SortOrder
    customerId?: SortOrder
    deliveryId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    vendorId?: SortOrder
    customerId?: SortOrder
    deliveryId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    vendorId?: SortOrder
    customerId?: SortOrder
    deliveryId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumActivityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTypeFilter<$PrismaModel>
  }

  export type DeliveryBroadcastCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    driverIds?: SortOrder
    acceptedDriverId?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliveryBroadcastMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    acceptedDriverId?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliveryBroadcastMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    acceptedDriverId?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type WebhookEventReferenceEventCompoundUniqueInput = {
    reference: string
    event: string
  }

  export type WebhookEventCountOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    event?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
  }

  export type WebhookEventMaxOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    event?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
  }

  export type WebhookEventMinOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    event?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type PaymentScalarRelationFilter = {
    is?: PaymentWhereInput
    isNot?: PaymentWhereInput
  }

  export type ReceiptCountOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    pdfUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type ReceiptMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    pdfUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type ReceiptMinOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    pdfUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type VendorFollowerVendorIdCustomerIdCompoundUniqueInput = {
    vendorId: string
    customerId: string
  }

  export type VendorFollowerCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
  }

  export type VendorFollowerMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
  }

  export type VendorFollowerMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
  }

  export type SpecialOrderRequestCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    vendorId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpecialOrderRequestAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type SpecialOrderRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    vendorId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpecialOrderRequestMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    vendorId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpecialOrderRequestSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type SpecialOrderRequestScalarRelationFilter = {
    is?: SpecialOrderRequestWhereInput
    isNot?: SpecialOrderRequestWhereInput
  }

  export type SpecialOrderOfferCountOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    vendorId?: SortOrder
    price?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpecialOrderOfferAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type SpecialOrderOfferMaxOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    vendorId?: SortOrder
    price?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpecialOrderOfferMinOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    vendorId?: SortOrder
    price?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpecialOrderOfferSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type UserCreatepreferencesInput = {
    set: string[]
  }

  export type UserCreateauthProvidersInput = {
    set: string[]
  }

  export type ProductCreateNestedManyWithoutVendorInput = {
    create?: XOR<ProductCreateWithoutVendorInput, ProductUncheckedCreateWithoutVendorInput> | ProductCreateWithoutVendorInput[] | ProductUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutVendorInput | ProductCreateOrConnectWithoutVendorInput[]
    createMany?: ProductCreateManyVendorInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type VendorReviewCreateNestedManyWithoutVendorInput = {
    create?: XOR<VendorReviewCreateWithoutVendorInput, VendorReviewUncheckedCreateWithoutVendorInput> | VendorReviewCreateWithoutVendorInput[] | VendorReviewUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorReviewCreateOrConnectWithoutVendorInput | VendorReviewCreateOrConnectWithoutVendorInput[]
    createMany?: VendorReviewCreateManyVendorInputEnvelope
    connect?: VendorReviewWhereUniqueInput | VendorReviewWhereUniqueInput[]
  }

  export type VendorReviewCreateNestedManyWithoutCustomerInput = {
    create?: XOR<VendorReviewCreateWithoutCustomerInput, VendorReviewUncheckedCreateWithoutCustomerInput> | VendorReviewCreateWithoutCustomerInput[] | VendorReviewUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: VendorReviewCreateOrConnectWithoutCustomerInput | VendorReviewCreateOrConnectWithoutCustomerInput[]
    createMany?: VendorReviewCreateManyCustomerInputEnvelope
    connect?: VendorReviewWhereUniqueInput | VendorReviewWhereUniqueInput[]
  }

  export type ProductReviewCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ProductReviewCreateWithoutCustomerInput, ProductReviewUncheckedCreateWithoutCustomerInput> | ProductReviewCreateWithoutCustomerInput[] | ProductReviewUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ProductReviewCreateOrConnectWithoutCustomerInput | ProductReviewCreateOrConnectWithoutCustomerInput[]
    createMany?: ProductReviewCreateManyCustomerInputEnvelope
    connect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutVendorInput = {
    create?: XOR<OrderCreateWithoutVendorInput, OrderUncheckedCreateWithoutVendorInput> | OrderCreateWithoutVendorInput[] | OrderUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutVendorInput | OrderCreateOrConnectWithoutVendorInput[]
    createMany?: OrderCreateManyVendorInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type VendorReplyCreateNestedManyWithoutVendorInput = {
    create?: XOR<VendorReplyCreateWithoutVendorInput, VendorReplyUncheckedCreateWithoutVendorInput> | VendorReplyCreateWithoutVendorInput[] | VendorReplyUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorReplyCreateOrConnectWithoutVendorInput | VendorReplyCreateOrConnectWithoutVendorInput[]
    createMany?: VendorReplyCreateManyVendorInputEnvelope
    connect?: VendorReplyWhereUniqueInput | VendorReplyWhereUniqueInput[]
  }

  export type ReviewVoteCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewVoteCreateWithoutUserInput, ReviewVoteUncheckedCreateWithoutUserInput> | ReviewVoteCreateWithoutUserInput[] | ReviewVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewVoteCreateOrConnectWithoutUserInput | ReviewVoteCreateOrConnectWithoutUserInput[]
    createMany?: ReviewVoteCreateManyUserInputEnvelope
    connect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
  }

  export type ReviewReportCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewReportCreateWithoutUserInput, ReviewReportUncheckedCreateWithoutUserInput> | ReviewReportCreateWithoutUserInput[] | ReviewReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewReportCreateOrConnectWithoutUserInput | ReviewReportCreateOrConnectWithoutUserInput[]
    createMany?: ReviewReportCreateManyUserInputEnvelope
    connect?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type LoginHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<LoginHistoryCreateWithoutUserInput, LoginHistoryUncheckedCreateWithoutUserInput> | LoginHistoryCreateWithoutUserInput[] | LoginHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LoginHistoryCreateOrConnectWithoutUserInput | LoginHistoryCreateOrConnectWithoutUserInput[]
    createMany?: LoginHistoryCreateManyUserInputEnvelope
    connect?: LoginHistoryWhereUniqueInput | LoginHistoryWhereUniqueInput[]
  }

  export type AddressCreateNestedManyWithoutUserInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput> | AddressCreateWithoutUserInput[] | AddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput | AddressCreateOrConnectWithoutUserInput[]
    createMany?: AddressCreateManyUserInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type CartCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CartCreateWithoutCustomerInput, CartUncheckedCreateWithoutCustomerInput> | CartCreateWithoutCustomerInput[] | CartUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CartCreateOrConnectWithoutCustomerInput | CartCreateOrConnectWithoutCustomerInput[]
    createMany?: CartCreateManyCustomerInputEnvelope
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
  }

  export type UserPaymentMethodCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPaymentMethodCreateWithoutUserInput, UserPaymentMethodUncheckedCreateWithoutUserInput> | UserPaymentMethodCreateWithoutUserInput[] | UserPaymentMethodUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPaymentMethodCreateOrConnectWithoutUserInput | UserPaymentMethodCreateOrConnectWithoutUserInput[]
    createMany?: UserPaymentMethodCreateManyUserInputEnvelope
    connect?: UserPaymentMethodWhereUniqueInput | UserPaymentMethodWhereUniqueInput[]
  }

  export type DeliveryPersonCreateNestedOneWithoutUserInput = {
    create?: XOR<DeliveryPersonCreateWithoutUserInput, DeliveryPersonUncheckedCreateWithoutUserInput>
    connectOrCreate?: DeliveryPersonCreateOrConnectWithoutUserInput
    connect?: DeliveryPersonWhereUniqueInput
  }

  export type PasswordResetTokenCreateNestedOneWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput
    connect?: PasswordResetTokenWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type RefundRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<RefundRequestCreateWithoutUserInput, RefundRequestUncheckedCreateWithoutUserInput> | RefundRequestCreateWithoutUserInput[] | RefundRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefundRequestCreateOrConnectWithoutUserInput | RefundRequestCreateOrConnectWithoutUserInput[]
    createMany?: RefundRequestCreateManyUserInputEnvelope
    connect?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutVendorInput = {
    create?: XOR<ActivityCreateWithoutVendorInput, ActivityUncheckedCreateWithoutVendorInput> | ActivityCreateWithoutVendorInput[] | ActivityUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutVendorInput | ActivityCreateOrConnectWithoutVendorInput[]
    createMany?: ActivityCreateManyVendorInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ActivityCreateWithoutCustomerInput, ActivityUncheckedCreateWithoutCustomerInput> | ActivityCreateWithoutCustomerInput[] | ActivityUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutCustomerInput | ActivityCreateOrConnectWithoutCustomerInput[]
    createMany?: ActivityCreateManyCustomerInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type VendorFollowerCreateNestedManyWithoutVendorInput = {
    create?: XOR<VendorFollowerCreateWithoutVendorInput, VendorFollowerUncheckedCreateWithoutVendorInput> | VendorFollowerCreateWithoutVendorInput[] | VendorFollowerUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorFollowerCreateOrConnectWithoutVendorInput | VendorFollowerCreateOrConnectWithoutVendorInput[]
    createMany?: VendorFollowerCreateManyVendorInputEnvelope
    connect?: VendorFollowerWhereUniqueInput | VendorFollowerWhereUniqueInput[]
  }

  export type VendorFollowerCreateNestedManyWithoutCustomerInput = {
    create?: XOR<VendorFollowerCreateWithoutCustomerInput, VendorFollowerUncheckedCreateWithoutCustomerInput> | VendorFollowerCreateWithoutCustomerInput[] | VendorFollowerUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: VendorFollowerCreateOrConnectWithoutCustomerInput | VendorFollowerCreateOrConnectWithoutCustomerInput[]
    createMany?: VendorFollowerCreateManyCustomerInputEnvelope
    connect?: VendorFollowerWhereUniqueInput | VendorFollowerWhereUniqueInput[]
  }

  export type SpecialOrderRequestCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SpecialOrderRequestCreateWithoutCustomerInput, SpecialOrderRequestUncheckedCreateWithoutCustomerInput> | SpecialOrderRequestCreateWithoutCustomerInput[] | SpecialOrderRequestUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SpecialOrderRequestCreateOrConnectWithoutCustomerInput | SpecialOrderRequestCreateOrConnectWithoutCustomerInput[]
    createMany?: SpecialOrderRequestCreateManyCustomerInputEnvelope
    connect?: SpecialOrderRequestWhereUniqueInput | SpecialOrderRequestWhereUniqueInput[]
  }

  export type SpecialOrderRequestCreateNestedManyWithoutVendorInput = {
    create?: XOR<SpecialOrderRequestCreateWithoutVendorInput, SpecialOrderRequestUncheckedCreateWithoutVendorInput> | SpecialOrderRequestCreateWithoutVendorInput[] | SpecialOrderRequestUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: SpecialOrderRequestCreateOrConnectWithoutVendorInput | SpecialOrderRequestCreateOrConnectWithoutVendorInput[]
    createMany?: SpecialOrderRequestCreateManyVendorInputEnvelope
    connect?: SpecialOrderRequestWhereUniqueInput | SpecialOrderRequestWhereUniqueInput[]
  }

  export type SpecialOrderOfferCreateNestedManyWithoutVendorInput = {
    create?: XOR<SpecialOrderOfferCreateWithoutVendorInput, SpecialOrderOfferUncheckedCreateWithoutVendorInput> | SpecialOrderOfferCreateWithoutVendorInput[] | SpecialOrderOfferUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: SpecialOrderOfferCreateOrConnectWithoutVendorInput | SpecialOrderOfferCreateOrConnectWithoutVendorInput[]
    createMany?: SpecialOrderOfferCreateManyVendorInputEnvelope
    connect?: SpecialOrderOfferWhereUniqueInput | SpecialOrderOfferWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<ProductCreateWithoutVendorInput, ProductUncheckedCreateWithoutVendorInput> | ProductCreateWithoutVendorInput[] | ProductUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutVendorInput | ProductCreateOrConnectWithoutVendorInput[]
    createMany?: ProductCreateManyVendorInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type VendorReviewUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<VendorReviewCreateWithoutVendorInput, VendorReviewUncheckedCreateWithoutVendorInput> | VendorReviewCreateWithoutVendorInput[] | VendorReviewUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorReviewCreateOrConnectWithoutVendorInput | VendorReviewCreateOrConnectWithoutVendorInput[]
    createMany?: VendorReviewCreateManyVendorInputEnvelope
    connect?: VendorReviewWhereUniqueInput | VendorReviewWhereUniqueInput[]
  }

  export type VendorReviewUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<VendorReviewCreateWithoutCustomerInput, VendorReviewUncheckedCreateWithoutCustomerInput> | VendorReviewCreateWithoutCustomerInput[] | VendorReviewUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: VendorReviewCreateOrConnectWithoutCustomerInput | VendorReviewCreateOrConnectWithoutCustomerInput[]
    createMany?: VendorReviewCreateManyCustomerInputEnvelope
    connect?: VendorReviewWhereUniqueInput | VendorReviewWhereUniqueInput[]
  }

  export type ProductReviewUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ProductReviewCreateWithoutCustomerInput, ProductReviewUncheckedCreateWithoutCustomerInput> | ProductReviewCreateWithoutCustomerInput[] | ProductReviewUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ProductReviewCreateOrConnectWithoutCustomerInput | ProductReviewCreateOrConnectWithoutCustomerInput[]
    createMany?: ProductReviewCreateManyCustomerInputEnvelope
    connect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<OrderCreateWithoutVendorInput, OrderUncheckedCreateWithoutVendorInput> | OrderCreateWithoutVendorInput[] | OrderUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutVendorInput | OrderCreateOrConnectWithoutVendorInput[]
    createMany?: OrderCreateManyVendorInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type VendorReplyUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<VendorReplyCreateWithoutVendorInput, VendorReplyUncheckedCreateWithoutVendorInput> | VendorReplyCreateWithoutVendorInput[] | VendorReplyUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorReplyCreateOrConnectWithoutVendorInput | VendorReplyCreateOrConnectWithoutVendorInput[]
    createMany?: VendorReplyCreateManyVendorInputEnvelope
    connect?: VendorReplyWhereUniqueInput | VendorReplyWhereUniqueInput[]
  }

  export type ReviewVoteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewVoteCreateWithoutUserInput, ReviewVoteUncheckedCreateWithoutUserInput> | ReviewVoteCreateWithoutUserInput[] | ReviewVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewVoteCreateOrConnectWithoutUserInput | ReviewVoteCreateOrConnectWithoutUserInput[]
    createMany?: ReviewVoteCreateManyUserInputEnvelope
    connect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
  }

  export type ReviewReportUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewReportCreateWithoutUserInput, ReviewReportUncheckedCreateWithoutUserInput> | ReviewReportCreateWithoutUserInput[] | ReviewReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewReportCreateOrConnectWithoutUserInput | ReviewReportCreateOrConnectWithoutUserInput[]
    createMany?: ReviewReportCreateManyUserInputEnvelope
    connect?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type LoginHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LoginHistoryCreateWithoutUserInput, LoginHistoryUncheckedCreateWithoutUserInput> | LoginHistoryCreateWithoutUserInput[] | LoginHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LoginHistoryCreateOrConnectWithoutUserInput | LoginHistoryCreateOrConnectWithoutUserInput[]
    createMany?: LoginHistoryCreateManyUserInputEnvelope
    connect?: LoginHistoryWhereUniqueInput | LoginHistoryWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput> | AddressCreateWithoutUserInput[] | AddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput | AddressCreateOrConnectWithoutUserInput[]
    createMany?: AddressCreateManyUserInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type CartUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CartCreateWithoutCustomerInput, CartUncheckedCreateWithoutCustomerInput> | CartCreateWithoutCustomerInput[] | CartUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CartCreateOrConnectWithoutCustomerInput | CartCreateOrConnectWithoutCustomerInput[]
    createMany?: CartCreateManyCustomerInputEnvelope
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
  }

  export type UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPaymentMethodCreateWithoutUserInput, UserPaymentMethodUncheckedCreateWithoutUserInput> | UserPaymentMethodCreateWithoutUserInput[] | UserPaymentMethodUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPaymentMethodCreateOrConnectWithoutUserInput | UserPaymentMethodCreateOrConnectWithoutUserInput[]
    createMany?: UserPaymentMethodCreateManyUserInputEnvelope
    connect?: UserPaymentMethodWhereUniqueInput | UserPaymentMethodWhereUniqueInput[]
  }

  export type DeliveryPersonUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<DeliveryPersonCreateWithoutUserInput, DeliveryPersonUncheckedCreateWithoutUserInput>
    connectOrCreate?: DeliveryPersonCreateOrConnectWithoutUserInput
    connect?: DeliveryPersonWhereUniqueInput
  }

  export type PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput
    connect?: PasswordResetTokenWhereUniqueInput
  }

  export type PaymentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type RefundRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefundRequestCreateWithoutUserInput, RefundRequestUncheckedCreateWithoutUserInput> | RefundRequestCreateWithoutUserInput[] | RefundRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefundRequestCreateOrConnectWithoutUserInput | RefundRequestCreateOrConnectWithoutUserInput[]
    createMany?: RefundRequestCreateManyUserInputEnvelope
    connect?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<ActivityCreateWithoutVendorInput, ActivityUncheckedCreateWithoutVendorInput> | ActivityCreateWithoutVendorInput[] | ActivityUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutVendorInput | ActivityCreateOrConnectWithoutVendorInput[]
    createMany?: ActivityCreateManyVendorInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ActivityCreateWithoutCustomerInput, ActivityUncheckedCreateWithoutCustomerInput> | ActivityCreateWithoutCustomerInput[] | ActivityUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutCustomerInput | ActivityCreateOrConnectWithoutCustomerInput[]
    createMany?: ActivityCreateManyCustomerInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type VendorFollowerUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<VendorFollowerCreateWithoutVendorInput, VendorFollowerUncheckedCreateWithoutVendorInput> | VendorFollowerCreateWithoutVendorInput[] | VendorFollowerUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorFollowerCreateOrConnectWithoutVendorInput | VendorFollowerCreateOrConnectWithoutVendorInput[]
    createMany?: VendorFollowerCreateManyVendorInputEnvelope
    connect?: VendorFollowerWhereUniqueInput | VendorFollowerWhereUniqueInput[]
  }

  export type VendorFollowerUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<VendorFollowerCreateWithoutCustomerInput, VendorFollowerUncheckedCreateWithoutCustomerInput> | VendorFollowerCreateWithoutCustomerInput[] | VendorFollowerUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: VendorFollowerCreateOrConnectWithoutCustomerInput | VendorFollowerCreateOrConnectWithoutCustomerInput[]
    createMany?: VendorFollowerCreateManyCustomerInputEnvelope
    connect?: VendorFollowerWhereUniqueInput | VendorFollowerWhereUniqueInput[]
  }

  export type SpecialOrderRequestUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SpecialOrderRequestCreateWithoutCustomerInput, SpecialOrderRequestUncheckedCreateWithoutCustomerInput> | SpecialOrderRequestCreateWithoutCustomerInput[] | SpecialOrderRequestUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SpecialOrderRequestCreateOrConnectWithoutCustomerInput | SpecialOrderRequestCreateOrConnectWithoutCustomerInput[]
    createMany?: SpecialOrderRequestCreateManyCustomerInputEnvelope
    connect?: SpecialOrderRequestWhereUniqueInput | SpecialOrderRequestWhereUniqueInput[]
  }

  export type SpecialOrderRequestUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<SpecialOrderRequestCreateWithoutVendorInput, SpecialOrderRequestUncheckedCreateWithoutVendorInput> | SpecialOrderRequestCreateWithoutVendorInput[] | SpecialOrderRequestUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: SpecialOrderRequestCreateOrConnectWithoutVendorInput | SpecialOrderRequestCreateOrConnectWithoutVendorInput[]
    createMany?: SpecialOrderRequestCreateManyVendorInputEnvelope
    connect?: SpecialOrderRequestWhereUniqueInput | SpecialOrderRequestWhereUniqueInput[]
  }

  export type SpecialOrderOfferUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<SpecialOrderOfferCreateWithoutVendorInput, SpecialOrderOfferUncheckedCreateWithoutVendorInput> | SpecialOrderOfferCreateWithoutVendorInput[] | SpecialOrderOfferUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: SpecialOrderOfferCreateOrConnectWithoutVendorInput | SpecialOrderOfferCreateOrConnectWithoutVendorInput[]
    createMany?: SpecialOrderOfferCreateManyVendorInputEnvelope
    connect?: SpecialOrderOfferWhereUniqueInput | SpecialOrderOfferWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserUpdatepreferencesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableEnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateauthProvidersInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ProductUpdateManyWithoutVendorNestedInput = {
    create?: XOR<ProductCreateWithoutVendorInput, ProductUncheckedCreateWithoutVendorInput> | ProductCreateWithoutVendorInput[] | ProductUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutVendorInput | ProductCreateOrConnectWithoutVendorInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutVendorInput | ProductUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: ProductCreateManyVendorInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutVendorInput | ProductUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutVendorInput | ProductUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type VendorReviewUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VendorReviewCreateWithoutVendorInput, VendorReviewUncheckedCreateWithoutVendorInput> | VendorReviewCreateWithoutVendorInput[] | VendorReviewUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorReviewCreateOrConnectWithoutVendorInput | VendorReviewCreateOrConnectWithoutVendorInput[]
    upsert?: VendorReviewUpsertWithWhereUniqueWithoutVendorInput | VendorReviewUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VendorReviewCreateManyVendorInputEnvelope
    set?: VendorReviewWhereUniqueInput | VendorReviewWhereUniqueInput[]
    disconnect?: VendorReviewWhereUniqueInput | VendorReviewWhereUniqueInput[]
    delete?: VendorReviewWhereUniqueInput | VendorReviewWhereUniqueInput[]
    connect?: VendorReviewWhereUniqueInput | VendorReviewWhereUniqueInput[]
    update?: VendorReviewUpdateWithWhereUniqueWithoutVendorInput | VendorReviewUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VendorReviewUpdateManyWithWhereWithoutVendorInput | VendorReviewUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VendorReviewScalarWhereInput | VendorReviewScalarWhereInput[]
  }

  export type VendorReviewUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<VendorReviewCreateWithoutCustomerInput, VendorReviewUncheckedCreateWithoutCustomerInput> | VendorReviewCreateWithoutCustomerInput[] | VendorReviewUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: VendorReviewCreateOrConnectWithoutCustomerInput | VendorReviewCreateOrConnectWithoutCustomerInput[]
    upsert?: VendorReviewUpsertWithWhereUniqueWithoutCustomerInput | VendorReviewUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: VendorReviewCreateManyCustomerInputEnvelope
    set?: VendorReviewWhereUniqueInput | VendorReviewWhereUniqueInput[]
    disconnect?: VendorReviewWhereUniqueInput | VendorReviewWhereUniqueInput[]
    delete?: VendorReviewWhereUniqueInput | VendorReviewWhereUniqueInput[]
    connect?: VendorReviewWhereUniqueInput | VendorReviewWhereUniqueInput[]
    update?: VendorReviewUpdateWithWhereUniqueWithoutCustomerInput | VendorReviewUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: VendorReviewUpdateManyWithWhereWithoutCustomerInput | VendorReviewUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: VendorReviewScalarWhereInput | VendorReviewScalarWhereInput[]
  }

  export type ProductReviewUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ProductReviewCreateWithoutCustomerInput, ProductReviewUncheckedCreateWithoutCustomerInput> | ProductReviewCreateWithoutCustomerInput[] | ProductReviewUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ProductReviewCreateOrConnectWithoutCustomerInput | ProductReviewCreateOrConnectWithoutCustomerInput[]
    upsert?: ProductReviewUpsertWithWhereUniqueWithoutCustomerInput | ProductReviewUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ProductReviewCreateManyCustomerInputEnvelope
    set?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    disconnect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    delete?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    connect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    update?: ProductReviewUpdateWithWhereUniqueWithoutCustomerInput | ProductReviewUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ProductReviewUpdateManyWithWhereWithoutCustomerInput | ProductReviewUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ProductReviewScalarWhereInput | ProductReviewScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutVendorNestedInput = {
    create?: XOR<OrderCreateWithoutVendorInput, OrderUncheckedCreateWithoutVendorInput> | OrderCreateWithoutVendorInput[] | OrderUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutVendorInput | OrderCreateOrConnectWithoutVendorInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutVendorInput | OrderUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: OrderCreateManyVendorInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutVendorInput | OrderUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutVendorInput | OrderUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type VendorReplyUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VendorReplyCreateWithoutVendorInput, VendorReplyUncheckedCreateWithoutVendorInput> | VendorReplyCreateWithoutVendorInput[] | VendorReplyUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorReplyCreateOrConnectWithoutVendorInput | VendorReplyCreateOrConnectWithoutVendorInput[]
    upsert?: VendorReplyUpsertWithWhereUniqueWithoutVendorInput | VendorReplyUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VendorReplyCreateManyVendorInputEnvelope
    set?: VendorReplyWhereUniqueInput | VendorReplyWhereUniqueInput[]
    disconnect?: VendorReplyWhereUniqueInput | VendorReplyWhereUniqueInput[]
    delete?: VendorReplyWhereUniqueInput | VendorReplyWhereUniqueInput[]
    connect?: VendorReplyWhereUniqueInput | VendorReplyWhereUniqueInput[]
    update?: VendorReplyUpdateWithWhereUniqueWithoutVendorInput | VendorReplyUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VendorReplyUpdateManyWithWhereWithoutVendorInput | VendorReplyUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VendorReplyScalarWhereInput | VendorReplyScalarWhereInput[]
  }

  export type ReviewVoteUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewVoteCreateWithoutUserInput, ReviewVoteUncheckedCreateWithoutUserInput> | ReviewVoteCreateWithoutUserInput[] | ReviewVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewVoteCreateOrConnectWithoutUserInput | ReviewVoteCreateOrConnectWithoutUserInput[]
    upsert?: ReviewVoteUpsertWithWhereUniqueWithoutUserInput | ReviewVoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewVoteCreateManyUserInputEnvelope
    set?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    disconnect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    delete?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    connect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    update?: ReviewVoteUpdateWithWhereUniqueWithoutUserInput | ReviewVoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewVoteUpdateManyWithWhereWithoutUserInput | ReviewVoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewVoteScalarWhereInput | ReviewVoteScalarWhereInput[]
  }

  export type ReviewReportUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewReportCreateWithoutUserInput, ReviewReportUncheckedCreateWithoutUserInput> | ReviewReportCreateWithoutUserInput[] | ReviewReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewReportCreateOrConnectWithoutUserInput | ReviewReportCreateOrConnectWithoutUserInput[]
    upsert?: ReviewReportUpsertWithWhereUniqueWithoutUserInput | ReviewReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewReportCreateManyUserInputEnvelope
    set?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
    disconnect?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
    delete?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
    connect?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
    update?: ReviewReportUpdateWithWhereUniqueWithoutUserInput | ReviewReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewReportUpdateManyWithWhereWithoutUserInput | ReviewReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewReportScalarWhereInput | ReviewReportScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type LoginHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<LoginHistoryCreateWithoutUserInput, LoginHistoryUncheckedCreateWithoutUserInput> | LoginHistoryCreateWithoutUserInput[] | LoginHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LoginHistoryCreateOrConnectWithoutUserInput | LoginHistoryCreateOrConnectWithoutUserInput[]
    upsert?: LoginHistoryUpsertWithWhereUniqueWithoutUserInput | LoginHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LoginHistoryCreateManyUserInputEnvelope
    set?: LoginHistoryWhereUniqueInput | LoginHistoryWhereUniqueInput[]
    disconnect?: LoginHistoryWhereUniqueInput | LoginHistoryWhereUniqueInput[]
    delete?: LoginHistoryWhereUniqueInput | LoginHistoryWhereUniqueInput[]
    connect?: LoginHistoryWhereUniqueInput | LoginHistoryWhereUniqueInput[]
    update?: LoginHistoryUpdateWithWhereUniqueWithoutUserInput | LoginHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LoginHistoryUpdateManyWithWhereWithoutUserInput | LoginHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LoginHistoryScalarWhereInput | LoginHistoryScalarWhereInput[]
  }

  export type AddressUpdateManyWithoutUserNestedInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput> | AddressCreateWithoutUserInput[] | AddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput | AddressCreateOrConnectWithoutUserInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutUserInput | AddressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AddressCreateManyUserInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutUserInput | AddressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutUserInput | AddressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type CartUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CartCreateWithoutCustomerInput, CartUncheckedCreateWithoutCustomerInput> | CartCreateWithoutCustomerInput[] | CartUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CartCreateOrConnectWithoutCustomerInput | CartCreateOrConnectWithoutCustomerInput[]
    upsert?: CartUpsertWithWhereUniqueWithoutCustomerInput | CartUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CartCreateManyCustomerInputEnvelope
    set?: CartWhereUniqueInput | CartWhereUniqueInput[]
    disconnect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    delete?: CartWhereUniqueInput | CartWhereUniqueInput[]
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    update?: CartUpdateWithWhereUniqueWithoutCustomerInput | CartUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CartUpdateManyWithWhereWithoutCustomerInput | CartUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CartScalarWhereInput | CartScalarWhereInput[]
  }

  export type UserPaymentMethodUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPaymentMethodCreateWithoutUserInput, UserPaymentMethodUncheckedCreateWithoutUserInput> | UserPaymentMethodCreateWithoutUserInput[] | UserPaymentMethodUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPaymentMethodCreateOrConnectWithoutUserInput | UserPaymentMethodCreateOrConnectWithoutUserInput[]
    upsert?: UserPaymentMethodUpsertWithWhereUniqueWithoutUserInput | UserPaymentMethodUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPaymentMethodCreateManyUserInputEnvelope
    set?: UserPaymentMethodWhereUniqueInput | UserPaymentMethodWhereUniqueInput[]
    disconnect?: UserPaymentMethodWhereUniqueInput | UserPaymentMethodWhereUniqueInput[]
    delete?: UserPaymentMethodWhereUniqueInput | UserPaymentMethodWhereUniqueInput[]
    connect?: UserPaymentMethodWhereUniqueInput | UserPaymentMethodWhereUniqueInput[]
    update?: UserPaymentMethodUpdateWithWhereUniqueWithoutUserInput | UserPaymentMethodUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPaymentMethodUpdateManyWithWhereWithoutUserInput | UserPaymentMethodUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPaymentMethodScalarWhereInput | UserPaymentMethodScalarWhereInput[]
  }

  export type DeliveryPersonUpdateOneWithoutUserNestedInput = {
    create?: XOR<DeliveryPersonCreateWithoutUserInput, DeliveryPersonUncheckedCreateWithoutUserInput>
    connectOrCreate?: DeliveryPersonCreateOrConnectWithoutUserInput
    upsert?: DeliveryPersonUpsertWithoutUserInput
    disconnect?: DeliveryPersonWhereInput | boolean
    delete?: DeliveryPersonWhereInput | boolean
    connect?: DeliveryPersonWhereUniqueInput
    update?: XOR<XOR<DeliveryPersonUpdateToOneWithWhereWithoutUserInput, DeliveryPersonUpdateWithoutUserInput>, DeliveryPersonUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateOneWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput
    upsert?: PasswordResetTokenUpsertWithoutUserInput
    disconnect?: PasswordResetTokenWhereInput | boolean
    delete?: PasswordResetTokenWhereInput | boolean
    connect?: PasswordResetTokenWhereUniqueInput
    update?: XOR<XOR<PasswordResetTokenUpdateToOneWithWhereWithoutUserInput, PasswordResetTokenUpdateWithoutUserInput>, PasswordResetTokenUncheckedUpdateWithoutUserInput>
  }

  export type PaymentUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type RefundRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefundRequestCreateWithoutUserInput, RefundRequestUncheckedCreateWithoutUserInput> | RefundRequestCreateWithoutUserInput[] | RefundRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefundRequestCreateOrConnectWithoutUserInput | RefundRequestCreateOrConnectWithoutUserInput[]
    upsert?: RefundRequestUpsertWithWhereUniqueWithoutUserInput | RefundRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefundRequestCreateManyUserInputEnvelope
    set?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
    disconnect?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
    delete?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
    connect?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
    update?: RefundRequestUpdateWithWhereUniqueWithoutUserInput | RefundRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefundRequestUpdateManyWithWhereWithoutUserInput | RefundRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefundRequestScalarWhereInput | RefundRequestScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutVendorNestedInput = {
    create?: XOR<ActivityCreateWithoutVendorInput, ActivityUncheckedCreateWithoutVendorInput> | ActivityCreateWithoutVendorInput[] | ActivityUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutVendorInput | ActivityCreateOrConnectWithoutVendorInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutVendorInput | ActivityUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: ActivityCreateManyVendorInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutVendorInput | ActivityUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutVendorInput | ActivityUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ActivityCreateWithoutCustomerInput, ActivityUncheckedCreateWithoutCustomerInput> | ActivityCreateWithoutCustomerInput[] | ActivityUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutCustomerInput | ActivityCreateOrConnectWithoutCustomerInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutCustomerInput | ActivityUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ActivityCreateManyCustomerInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutCustomerInput | ActivityUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutCustomerInput | ActivityUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type VendorFollowerUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VendorFollowerCreateWithoutVendorInput, VendorFollowerUncheckedCreateWithoutVendorInput> | VendorFollowerCreateWithoutVendorInput[] | VendorFollowerUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorFollowerCreateOrConnectWithoutVendorInput | VendorFollowerCreateOrConnectWithoutVendorInput[]
    upsert?: VendorFollowerUpsertWithWhereUniqueWithoutVendorInput | VendorFollowerUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VendorFollowerCreateManyVendorInputEnvelope
    set?: VendorFollowerWhereUniqueInput | VendorFollowerWhereUniqueInput[]
    disconnect?: VendorFollowerWhereUniqueInput | VendorFollowerWhereUniqueInput[]
    delete?: VendorFollowerWhereUniqueInput | VendorFollowerWhereUniqueInput[]
    connect?: VendorFollowerWhereUniqueInput | VendorFollowerWhereUniqueInput[]
    update?: VendorFollowerUpdateWithWhereUniqueWithoutVendorInput | VendorFollowerUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VendorFollowerUpdateManyWithWhereWithoutVendorInput | VendorFollowerUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VendorFollowerScalarWhereInput | VendorFollowerScalarWhereInput[]
  }

  export type VendorFollowerUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<VendorFollowerCreateWithoutCustomerInput, VendorFollowerUncheckedCreateWithoutCustomerInput> | VendorFollowerCreateWithoutCustomerInput[] | VendorFollowerUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: VendorFollowerCreateOrConnectWithoutCustomerInput | VendorFollowerCreateOrConnectWithoutCustomerInput[]
    upsert?: VendorFollowerUpsertWithWhereUniqueWithoutCustomerInput | VendorFollowerUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: VendorFollowerCreateManyCustomerInputEnvelope
    set?: VendorFollowerWhereUniqueInput | VendorFollowerWhereUniqueInput[]
    disconnect?: VendorFollowerWhereUniqueInput | VendorFollowerWhereUniqueInput[]
    delete?: VendorFollowerWhereUniqueInput | VendorFollowerWhereUniqueInput[]
    connect?: VendorFollowerWhereUniqueInput | VendorFollowerWhereUniqueInput[]
    update?: VendorFollowerUpdateWithWhereUniqueWithoutCustomerInput | VendorFollowerUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: VendorFollowerUpdateManyWithWhereWithoutCustomerInput | VendorFollowerUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: VendorFollowerScalarWhereInput | VendorFollowerScalarWhereInput[]
  }

  export type SpecialOrderRequestUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SpecialOrderRequestCreateWithoutCustomerInput, SpecialOrderRequestUncheckedCreateWithoutCustomerInput> | SpecialOrderRequestCreateWithoutCustomerInput[] | SpecialOrderRequestUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SpecialOrderRequestCreateOrConnectWithoutCustomerInput | SpecialOrderRequestCreateOrConnectWithoutCustomerInput[]
    upsert?: SpecialOrderRequestUpsertWithWhereUniqueWithoutCustomerInput | SpecialOrderRequestUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SpecialOrderRequestCreateManyCustomerInputEnvelope
    set?: SpecialOrderRequestWhereUniqueInput | SpecialOrderRequestWhereUniqueInput[]
    disconnect?: SpecialOrderRequestWhereUniqueInput | SpecialOrderRequestWhereUniqueInput[]
    delete?: SpecialOrderRequestWhereUniqueInput | SpecialOrderRequestWhereUniqueInput[]
    connect?: SpecialOrderRequestWhereUniqueInput | SpecialOrderRequestWhereUniqueInput[]
    update?: SpecialOrderRequestUpdateWithWhereUniqueWithoutCustomerInput | SpecialOrderRequestUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SpecialOrderRequestUpdateManyWithWhereWithoutCustomerInput | SpecialOrderRequestUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SpecialOrderRequestScalarWhereInput | SpecialOrderRequestScalarWhereInput[]
  }

  export type SpecialOrderRequestUpdateManyWithoutVendorNestedInput = {
    create?: XOR<SpecialOrderRequestCreateWithoutVendorInput, SpecialOrderRequestUncheckedCreateWithoutVendorInput> | SpecialOrderRequestCreateWithoutVendorInput[] | SpecialOrderRequestUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: SpecialOrderRequestCreateOrConnectWithoutVendorInput | SpecialOrderRequestCreateOrConnectWithoutVendorInput[]
    upsert?: SpecialOrderRequestUpsertWithWhereUniqueWithoutVendorInput | SpecialOrderRequestUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: SpecialOrderRequestCreateManyVendorInputEnvelope
    set?: SpecialOrderRequestWhereUniqueInput | SpecialOrderRequestWhereUniqueInput[]
    disconnect?: SpecialOrderRequestWhereUniqueInput | SpecialOrderRequestWhereUniqueInput[]
    delete?: SpecialOrderRequestWhereUniqueInput | SpecialOrderRequestWhereUniqueInput[]
    connect?: SpecialOrderRequestWhereUniqueInput | SpecialOrderRequestWhereUniqueInput[]
    update?: SpecialOrderRequestUpdateWithWhereUniqueWithoutVendorInput | SpecialOrderRequestUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: SpecialOrderRequestUpdateManyWithWhereWithoutVendorInput | SpecialOrderRequestUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: SpecialOrderRequestScalarWhereInput | SpecialOrderRequestScalarWhereInput[]
  }

  export type SpecialOrderOfferUpdateManyWithoutVendorNestedInput = {
    create?: XOR<SpecialOrderOfferCreateWithoutVendorInput, SpecialOrderOfferUncheckedCreateWithoutVendorInput> | SpecialOrderOfferCreateWithoutVendorInput[] | SpecialOrderOfferUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: SpecialOrderOfferCreateOrConnectWithoutVendorInput | SpecialOrderOfferCreateOrConnectWithoutVendorInput[]
    upsert?: SpecialOrderOfferUpsertWithWhereUniqueWithoutVendorInput | SpecialOrderOfferUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: SpecialOrderOfferCreateManyVendorInputEnvelope
    set?: SpecialOrderOfferWhereUniqueInput | SpecialOrderOfferWhereUniqueInput[]
    disconnect?: SpecialOrderOfferWhereUniqueInput | SpecialOrderOfferWhereUniqueInput[]
    delete?: SpecialOrderOfferWhereUniqueInput | SpecialOrderOfferWhereUniqueInput[]
    connect?: SpecialOrderOfferWhereUniqueInput | SpecialOrderOfferWhereUniqueInput[]
    update?: SpecialOrderOfferUpdateWithWhereUniqueWithoutVendorInput | SpecialOrderOfferUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: SpecialOrderOfferUpdateManyWithWhereWithoutVendorInput | SpecialOrderOfferUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: SpecialOrderOfferScalarWhereInput | SpecialOrderOfferScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<ProductCreateWithoutVendorInput, ProductUncheckedCreateWithoutVendorInput> | ProductCreateWithoutVendorInput[] | ProductUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutVendorInput | ProductCreateOrConnectWithoutVendorInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutVendorInput | ProductUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: ProductCreateManyVendorInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutVendorInput | ProductUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutVendorInput | ProductUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type VendorReviewUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VendorReviewCreateWithoutVendorInput, VendorReviewUncheckedCreateWithoutVendorInput> | VendorReviewCreateWithoutVendorInput[] | VendorReviewUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorReviewCreateOrConnectWithoutVendorInput | VendorReviewCreateOrConnectWithoutVendorInput[]
    upsert?: VendorReviewUpsertWithWhereUniqueWithoutVendorInput | VendorReviewUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VendorReviewCreateManyVendorInputEnvelope
    set?: VendorReviewWhereUniqueInput | VendorReviewWhereUniqueInput[]
    disconnect?: VendorReviewWhereUniqueInput | VendorReviewWhereUniqueInput[]
    delete?: VendorReviewWhereUniqueInput | VendorReviewWhereUniqueInput[]
    connect?: VendorReviewWhereUniqueInput | VendorReviewWhereUniqueInput[]
    update?: VendorReviewUpdateWithWhereUniqueWithoutVendorInput | VendorReviewUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VendorReviewUpdateManyWithWhereWithoutVendorInput | VendorReviewUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VendorReviewScalarWhereInput | VendorReviewScalarWhereInput[]
  }

  export type VendorReviewUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<VendorReviewCreateWithoutCustomerInput, VendorReviewUncheckedCreateWithoutCustomerInput> | VendorReviewCreateWithoutCustomerInput[] | VendorReviewUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: VendorReviewCreateOrConnectWithoutCustomerInput | VendorReviewCreateOrConnectWithoutCustomerInput[]
    upsert?: VendorReviewUpsertWithWhereUniqueWithoutCustomerInput | VendorReviewUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: VendorReviewCreateManyCustomerInputEnvelope
    set?: VendorReviewWhereUniqueInput | VendorReviewWhereUniqueInput[]
    disconnect?: VendorReviewWhereUniqueInput | VendorReviewWhereUniqueInput[]
    delete?: VendorReviewWhereUniqueInput | VendorReviewWhereUniqueInput[]
    connect?: VendorReviewWhereUniqueInput | VendorReviewWhereUniqueInput[]
    update?: VendorReviewUpdateWithWhereUniqueWithoutCustomerInput | VendorReviewUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: VendorReviewUpdateManyWithWhereWithoutCustomerInput | VendorReviewUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: VendorReviewScalarWhereInput | VendorReviewScalarWhereInput[]
  }

  export type ProductReviewUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ProductReviewCreateWithoutCustomerInput, ProductReviewUncheckedCreateWithoutCustomerInput> | ProductReviewCreateWithoutCustomerInput[] | ProductReviewUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ProductReviewCreateOrConnectWithoutCustomerInput | ProductReviewCreateOrConnectWithoutCustomerInput[]
    upsert?: ProductReviewUpsertWithWhereUniqueWithoutCustomerInput | ProductReviewUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ProductReviewCreateManyCustomerInputEnvelope
    set?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    disconnect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    delete?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    connect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    update?: ProductReviewUpdateWithWhereUniqueWithoutCustomerInput | ProductReviewUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ProductReviewUpdateManyWithWhereWithoutCustomerInput | ProductReviewUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ProductReviewScalarWhereInput | ProductReviewScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<OrderCreateWithoutVendorInput, OrderUncheckedCreateWithoutVendorInput> | OrderCreateWithoutVendorInput[] | OrderUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutVendorInput | OrderCreateOrConnectWithoutVendorInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutVendorInput | OrderUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: OrderCreateManyVendorInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutVendorInput | OrderUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutVendorInput | OrderUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type VendorReplyUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VendorReplyCreateWithoutVendorInput, VendorReplyUncheckedCreateWithoutVendorInput> | VendorReplyCreateWithoutVendorInput[] | VendorReplyUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorReplyCreateOrConnectWithoutVendorInput | VendorReplyCreateOrConnectWithoutVendorInput[]
    upsert?: VendorReplyUpsertWithWhereUniqueWithoutVendorInput | VendorReplyUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VendorReplyCreateManyVendorInputEnvelope
    set?: VendorReplyWhereUniqueInput | VendorReplyWhereUniqueInput[]
    disconnect?: VendorReplyWhereUniqueInput | VendorReplyWhereUniqueInput[]
    delete?: VendorReplyWhereUniqueInput | VendorReplyWhereUniqueInput[]
    connect?: VendorReplyWhereUniqueInput | VendorReplyWhereUniqueInput[]
    update?: VendorReplyUpdateWithWhereUniqueWithoutVendorInput | VendorReplyUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VendorReplyUpdateManyWithWhereWithoutVendorInput | VendorReplyUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VendorReplyScalarWhereInput | VendorReplyScalarWhereInput[]
  }

  export type ReviewVoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewVoteCreateWithoutUserInput, ReviewVoteUncheckedCreateWithoutUserInput> | ReviewVoteCreateWithoutUserInput[] | ReviewVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewVoteCreateOrConnectWithoutUserInput | ReviewVoteCreateOrConnectWithoutUserInput[]
    upsert?: ReviewVoteUpsertWithWhereUniqueWithoutUserInput | ReviewVoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewVoteCreateManyUserInputEnvelope
    set?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    disconnect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    delete?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    connect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    update?: ReviewVoteUpdateWithWhereUniqueWithoutUserInput | ReviewVoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewVoteUpdateManyWithWhereWithoutUserInput | ReviewVoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewVoteScalarWhereInput | ReviewVoteScalarWhereInput[]
  }

  export type ReviewReportUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewReportCreateWithoutUserInput, ReviewReportUncheckedCreateWithoutUserInput> | ReviewReportCreateWithoutUserInput[] | ReviewReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewReportCreateOrConnectWithoutUserInput | ReviewReportCreateOrConnectWithoutUserInput[]
    upsert?: ReviewReportUpsertWithWhereUniqueWithoutUserInput | ReviewReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewReportCreateManyUserInputEnvelope
    set?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
    disconnect?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
    delete?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
    connect?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
    update?: ReviewReportUpdateWithWhereUniqueWithoutUserInput | ReviewReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewReportUpdateManyWithWhereWithoutUserInput | ReviewReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewReportScalarWhereInput | ReviewReportScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type LoginHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LoginHistoryCreateWithoutUserInput, LoginHistoryUncheckedCreateWithoutUserInput> | LoginHistoryCreateWithoutUserInput[] | LoginHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LoginHistoryCreateOrConnectWithoutUserInput | LoginHistoryCreateOrConnectWithoutUserInput[]
    upsert?: LoginHistoryUpsertWithWhereUniqueWithoutUserInput | LoginHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LoginHistoryCreateManyUserInputEnvelope
    set?: LoginHistoryWhereUniqueInput | LoginHistoryWhereUniqueInput[]
    disconnect?: LoginHistoryWhereUniqueInput | LoginHistoryWhereUniqueInput[]
    delete?: LoginHistoryWhereUniqueInput | LoginHistoryWhereUniqueInput[]
    connect?: LoginHistoryWhereUniqueInput | LoginHistoryWhereUniqueInput[]
    update?: LoginHistoryUpdateWithWhereUniqueWithoutUserInput | LoginHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LoginHistoryUpdateManyWithWhereWithoutUserInput | LoginHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LoginHistoryScalarWhereInput | LoginHistoryScalarWhereInput[]
  }

  export type AddressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput> | AddressCreateWithoutUserInput[] | AddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput | AddressCreateOrConnectWithoutUserInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutUserInput | AddressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AddressCreateManyUserInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutUserInput | AddressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutUserInput | AddressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type CartUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CartCreateWithoutCustomerInput, CartUncheckedCreateWithoutCustomerInput> | CartCreateWithoutCustomerInput[] | CartUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CartCreateOrConnectWithoutCustomerInput | CartCreateOrConnectWithoutCustomerInput[]
    upsert?: CartUpsertWithWhereUniqueWithoutCustomerInput | CartUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CartCreateManyCustomerInputEnvelope
    set?: CartWhereUniqueInput | CartWhereUniqueInput[]
    disconnect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    delete?: CartWhereUniqueInput | CartWhereUniqueInput[]
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    update?: CartUpdateWithWhereUniqueWithoutCustomerInput | CartUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CartUpdateManyWithWhereWithoutCustomerInput | CartUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CartScalarWhereInput | CartScalarWhereInput[]
  }

  export type UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPaymentMethodCreateWithoutUserInput, UserPaymentMethodUncheckedCreateWithoutUserInput> | UserPaymentMethodCreateWithoutUserInput[] | UserPaymentMethodUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPaymentMethodCreateOrConnectWithoutUserInput | UserPaymentMethodCreateOrConnectWithoutUserInput[]
    upsert?: UserPaymentMethodUpsertWithWhereUniqueWithoutUserInput | UserPaymentMethodUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPaymentMethodCreateManyUserInputEnvelope
    set?: UserPaymentMethodWhereUniqueInput | UserPaymentMethodWhereUniqueInput[]
    disconnect?: UserPaymentMethodWhereUniqueInput | UserPaymentMethodWhereUniqueInput[]
    delete?: UserPaymentMethodWhereUniqueInput | UserPaymentMethodWhereUniqueInput[]
    connect?: UserPaymentMethodWhereUniqueInput | UserPaymentMethodWhereUniqueInput[]
    update?: UserPaymentMethodUpdateWithWhereUniqueWithoutUserInput | UserPaymentMethodUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPaymentMethodUpdateManyWithWhereWithoutUserInput | UserPaymentMethodUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPaymentMethodScalarWhereInput | UserPaymentMethodScalarWhereInput[]
  }

  export type DeliveryPersonUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<DeliveryPersonCreateWithoutUserInput, DeliveryPersonUncheckedCreateWithoutUserInput>
    connectOrCreate?: DeliveryPersonCreateOrConnectWithoutUserInput
    upsert?: DeliveryPersonUpsertWithoutUserInput
    disconnect?: DeliveryPersonWhereInput | boolean
    delete?: DeliveryPersonWhereInput | boolean
    connect?: DeliveryPersonWhereUniqueInput
    update?: XOR<XOR<DeliveryPersonUpdateToOneWithWhereWithoutUserInput, DeliveryPersonUpdateWithoutUserInput>, DeliveryPersonUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput
    upsert?: PasswordResetTokenUpsertWithoutUserInput
    disconnect?: PasswordResetTokenWhereInput | boolean
    delete?: PasswordResetTokenWhereInput | boolean
    connect?: PasswordResetTokenWhereUniqueInput
    update?: XOR<XOR<PasswordResetTokenUpdateToOneWithWhereWithoutUserInput, PasswordResetTokenUpdateWithoutUserInput>, PasswordResetTokenUncheckedUpdateWithoutUserInput>
  }

  export type PaymentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type RefundRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefundRequestCreateWithoutUserInput, RefundRequestUncheckedCreateWithoutUserInput> | RefundRequestCreateWithoutUserInput[] | RefundRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefundRequestCreateOrConnectWithoutUserInput | RefundRequestCreateOrConnectWithoutUserInput[]
    upsert?: RefundRequestUpsertWithWhereUniqueWithoutUserInput | RefundRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefundRequestCreateManyUserInputEnvelope
    set?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
    disconnect?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
    delete?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
    connect?: RefundRequestWhereUniqueInput | RefundRequestWhereUniqueInput[]
    update?: RefundRequestUpdateWithWhereUniqueWithoutUserInput | RefundRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefundRequestUpdateManyWithWhereWithoutUserInput | RefundRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefundRequestScalarWhereInput | RefundRequestScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<ActivityCreateWithoutVendorInput, ActivityUncheckedCreateWithoutVendorInput> | ActivityCreateWithoutVendorInput[] | ActivityUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutVendorInput | ActivityCreateOrConnectWithoutVendorInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutVendorInput | ActivityUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: ActivityCreateManyVendorInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutVendorInput | ActivityUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutVendorInput | ActivityUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ActivityCreateWithoutCustomerInput, ActivityUncheckedCreateWithoutCustomerInput> | ActivityCreateWithoutCustomerInput[] | ActivityUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutCustomerInput | ActivityCreateOrConnectWithoutCustomerInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutCustomerInput | ActivityUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ActivityCreateManyCustomerInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutCustomerInput | ActivityUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutCustomerInput | ActivityUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type VendorFollowerUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VendorFollowerCreateWithoutVendorInput, VendorFollowerUncheckedCreateWithoutVendorInput> | VendorFollowerCreateWithoutVendorInput[] | VendorFollowerUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorFollowerCreateOrConnectWithoutVendorInput | VendorFollowerCreateOrConnectWithoutVendorInput[]
    upsert?: VendorFollowerUpsertWithWhereUniqueWithoutVendorInput | VendorFollowerUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VendorFollowerCreateManyVendorInputEnvelope
    set?: VendorFollowerWhereUniqueInput | VendorFollowerWhereUniqueInput[]
    disconnect?: VendorFollowerWhereUniqueInput | VendorFollowerWhereUniqueInput[]
    delete?: VendorFollowerWhereUniqueInput | VendorFollowerWhereUniqueInput[]
    connect?: VendorFollowerWhereUniqueInput | VendorFollowerWhereUniqueInput[]
    update?: VendorFollowerUpdateWithWhereUniqueWithoutVendorInput | VendorFollowerUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VendorFollowerUpdateManyWithWhereWithoutVendorInput | VendorFollowerUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VendorFollowerScalarWhereInput | VendorFollowerScalarWhereInput[]
  }

  export type VendorFollowerUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<VendorFollowerCreateWithoutCustomerInput, VendorFollowerUncheckedCreateWithoutCustomerInput> | VendorFollowerCreateWithoutCustomerInput[] | VendorFollowerUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: VendorFollowerCreateOrConnectWithoutCustomerInput | VendorFollowerCreateOrConnectWithoutCustomerInput[]
    upsert?: VendorFollowerUpsertWithWhereUniqueWithoutCustomerInput | VendorFollowerUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: VendorFollowerCreateManyCustomerInputEnvelope
    set?: VendorFollowerWhereUniqueInput | VendorFollowerWhereUniqueInput[]
    disconnect?: VendorFollowerWhereUniqueInput | VendorFollowerWhereUniqueInput[]
    delete?: VendorFollowerWhereUniqueInput | VendorFollowerWhereUniqueInput[]
    connect?: VendorFollowerWhereUniqueInput | VendorFollowerWhereUniqueInput[]
    update?: VendorFollowerUpdateWithWhereUniqueWithoutCustomerInput | VendorFollowerUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: VendorFollowerUpdateManyWithWhereWithoutCustomerInput | VendorFollowerUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: VendorFollowerScalarWhereInput | VendorFollowerScalarWhereInput[]
  }

  export type SpecialOrderRequestUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SpecialOrderRequestCreateWithoutCustomerInput, SpecialOrderRequestUncheckedCreateWithoutCustomerInput> | SpecialOrderRequestCreateWithoutCustomerInput[] | SpecialOrderRequestUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SpecialOrderRequestCreateOrConnectWithoutCustomerInput | SpecialOrderRequestCreateOrConnectWithoutCustomerInput[]
    upsert?: SpecialOrderRequestUpsertWithWhereUniqueWithoutCustomerInput | SpecialOrderRequestUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SpecialOrderRequestCreateManyCustomerInputEnvelope
    set?: SpecialOrderRequestWhereUniqueInput | SpecialOrderRequestWhereUniqueInput[]
    disconnect?: SpecialOrderRequestWhereUniqueInput | SpecialOrderRequestWhereUniqueInput[]
    delete?: SpecialOrderRequestWhereUniqueInput | SpecialOrderRequestWhereUniqueInput[]
    connect?: SpecialOrderRequestWhereUniqueInput | SpecialOrderRequestWhereUniqueInput[]
    update?: SpecialOrderRequestUpdateWithWhereUniqueWithoutCustomerInput | SpecialOrderRequestUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SpecialOrderRequestUpdateManyWithWhereWithoutCustomerInput | SpecialOrderRequestUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SpecialOrderRequestScalarWhereInput | SpecialOrderRequestScalarWhereInput[]
  }

  export type SpecialOrderRequestUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<SpecialOrderRequestCreateWithoutVendorInput, SpecialOrderRequestUncheckedCreateWithoutVendorInput> | SpecialOrderRequestCreateWithoutVendorInput[] | SpecialOrderRequestUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: SpecialOrderRequestCreateOrConnectWithoutVendorInput | SpecialOrderRequestCreateOrConnectWithoutVendorInput[]
    upsert?: SpecialOrderRequestUpsertWithWhereUniqueWithoutVendorInput | SpecialOrderRequestUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: SpecialOrderRequestCreateManyVendorInputEnvelope
    set?: SpecialOrderRequestWhereUniqueInput | SpecialOrderRequestWhereUniqueInput[]
    disconnect?: SpecialOrderRequestWhereUniqueInput | SpecialOrderRequestWhereUniqueInput[]
    delete?: SpecialOrderRequestWhereUniqueInput | SpecialOrderRequestWhereUniqueInput[]
    connect?: SpecialOrderRequestWhereUniqueInput | SpecialOrderRequestWhereUniqueInput[]
    update?: SpecialOrderRequestUpdateWithWhereUniqueWithoutVendorInput | SpecialOrderRequestUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: SpecialOrderRequestUpdateManyWithWhereWithoutVendorInput | SpecialOrderRequestUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: SpecialOrderRequestScalarWhereInput | SpecialOrderRequestScalarWhereInput[]
  }

  export type SpecialOrderOfferUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<SpecialOrderOfferCreateWithoutVendorInput, SpecialOrderOfferUncheckedCreateWithoutVendorInput> | SpecialOrderOfferCreateWithoutVendorInput[] | SpecialOrderOfferUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: SpecialOrderOfferCreateOrConnectWithoutVendorInput | SpecialOrderOfferCreateOrConnectWithoutVendorInput[]
    upsert?: SpecialOrderOfferUpsertWithWhereUniqueWithoutVendorInput | SpecialOrderOfferUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: SpecialOrderOfferCreateManyVendorInputEnvelope
    set?: SpecialOrderOfferWhereUniqueInput | SpecialOrderOfferWhereUniqueInput[]
    disconnect?: SpecialOrderOfferWhereUniqueInput | SpecialOrderOfferWhereUniqueInput[]
    delete?: SpecialOrderOfferWhereUniqueInput | SpecialOrderOfferWhereUniqueInput[]
    connect?: SpecialOrderOfferWhereUniqueInput | SpecialOrderOfferWhereUniqueInput[]
    update?: SpecialOrderOfferUpdateWithWhereUniqueWithoutVendorInput | SpecialOrderOfferUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: SpecialOrderOfferUpdateManyWithWhereWithoutVendorInput | SpecialOrderOfferUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: SpecialOrderOfferScalarWhereInput | SpecialOrderOfferScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAddressesInput = {
    create?: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressesInput
    connect?: UserWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutAddressInput = {
    create?: XOR<OrderCreateWithoutAddressInput, OrderUncheckedCreateWithoutAddressInput> | OrderCreateWithoutAddressInput[] | OrderUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutAddressInput | OrderCreateOrConnectWithoutAddressInput[]
    createMany?: OrderCreateManyAddressInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutAddressInput = {
    create?: XOR<OrderCreateWithoutAddressInput, OrderUncheckedCreateWithoutAddressInput> | OrderCreateWithoutAddressInput[] | OrderUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutAddressInput | OrderCreateOrConnectWithoutAddressInput[]
    createMany?: OrderCreateManyAddressInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAddressesNestedInput = {
    create?: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressesInput
    upsert?: UserUpsertWithoutAddressesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAddressesInput, UserUpdateWithoutAddressesInput>, UserUncheckedUpdateWithoutAddressesInput>
  }

  export type OrderUpdateManyWithoutAddressNestedInput = {
    create?: XOR<OrderCreateWithoutAddressInput, OrderUncheckedCreateWithoutAddressInput> | OrderCreateWithoutAddressInput[] | OrderUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutAddressInput | OrderCreateOrConnectWithoutAddressInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutAddressInput | OrderUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: OrderCreateManyAddressInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutAddressInput | OrderUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutAddressInput | OrderUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutAddressNestedInput = {
    create?: XOR<OrderCreateWithoutAddressInput, OrderUncheckedCreateWithoutAddressInput> | OrderCreateWithoutAddressInput[] | OrderUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutAddressInput | OrderCreateOrConnectWithoutAddressInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutAddressInput | OrderUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: OrderCreateManyAddressInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutAddressInput | OrderUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutAddressInput | OrderUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ProductCreateimagesInput = {
    set: string[]
  }

  export type ProductCreatevideoInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutProductsInput = {
    create?: XOR<UserCreateWithoutProductsInput, UserUncheckedCreateWithoutProductsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductsInput
    connect?: UserWhereUniqueInput
  }

  export type ProductReviewCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductReviewCreateWithoutProductInput, ProductReviewUncheckedCreateWithoutProductInput> | ProductReviewCreateWithoutProductInput[] | ProductReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductReviewCreateOrConnectWithoutProductInput | ProductReviewCreateOrConnectWithoutProductInput[]
    createMany?: ProductReviewCreateManyProductInputEnvelope
    connect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderCreateWithoutProductInput, OrderUncheckedCreateWithoutProductInput> | OrderCreateWithoutProductInput[] | OrderUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutProductInput | OrderCreateOrConnectWithoutProductInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderItemCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ProductOptionCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductOptionCreateWithoutProductInput, ProductOptionUncheckedCreateWithoutProductInput> | ProductOptionCreateWithoutProductInput[] | ProductOptionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductOptionCreateOrConnectWithoutProductInput | ProductOptionCreateOrConnectWithoutProductInput[]
    createMany?: ProductOptionCreateManyProductInputEnvelope
    connect?: ProductOptionWhereUniqueInput | ProductOptionWhereUniqueInput[]
  }

  export type CartItemCreateNestedManyWithoutProductInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type SpecialOrderRequestCreateNestedManyWithoutProductInput = {
    create?: XOR<SpecialOrderRequestCreateWithoutProductInput, SpecialOrderRequestUncheckedCreateWithoutProductInput> | SpecialOrderRequestCreateWithoutProductInput[] | SpecialOrderRequestUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SpecialOrderRequestCreateOrConnectWithoutProductInput | SpecialOrderRequestCreateOrConnectWithoutProductInput[]
    createMany?: SpecialOrderRequestCreateManyProductInputEnvelope
    connect?: SpecialOrderRequestWhereUniqueInput | SpecialOrderRequestWhereUniqueInput[]
  }

  export type ProductScheduleCreateNestedOneWithoutProductInput = {
    create?: XOR<ProductScheduleCreateWithoutProductInput, ProductScheduleUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductScheduleCreateOrConnectWithoutProductInput
    connect?: ProductScheduleWhereUniqueInput
  }

  export type ProductReviewUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductReviewCreateWithoutProductInput, ProductReviewUncheckedCreateWithoutProductInput> | ProductReviewCreateWithoutProductInput[] | ProductReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductReviewCreateOrConnectWithoutProductInput | ProductReviewCreateOrConnectWithoutProductInput[]
    createMany?: ProductReviewCreateManyProductInputEnvelope
    connect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderCreateWithoutProductInput, OrderUncheckedCreateWithoutProductInput> | OrderCreateWithoutProductInput[] | OrderUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutProductInput | OrderCreateOrConnectWithoutProductInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ProductOptionUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductOptionCreateWithoutProductInput, ProductOptionUncheckedCreateWithoutProductInput> | ProductOptionCreateWithoutProductInput[] | ProductOptionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductOptionCreateOrConnectWithoutProductInput | ProductOptionCreateOrConnectWithoutProductInput[]
    createMany?: ProductOptionCreateManyProductInputEnvelope
    connect?: ProductOptionWhereUniqueInput | ProductOptionWhereUniqueInput[]
  }

  export type CartItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type SpecialOrderRequestUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<SpecialOrderRequestCreateWithoutProductInput, SpecialOrderRequestUncheckedCreateWithoutProductInput> | SpecialOrderRequestCreateWithoutProductInput[] | SpecialOrderRequestUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SpecialOrderRequestCreateOrConnectWithoutProductInput | SpecialOrderRequestCreateOrConnectWithoutProductInput[]
    createMany?: SpecialOrderRequestCreateManyProductInputEnvelope
    connect?: SpecialOrderRequestWhereUniqueInput | SpecialOrderRequestWhereUniqueInput[]
  }

  export type ProductScheduleUncheckedCreateNestedOneWithoutProductInput = {
    create?: XOR<ProductScheduleCreateWithoutProductInput, ProductScheduleUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductScheduleCreateOrConnectWithoutProductInput
    connect?: ProductScheduleWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumCategoryFieldUpdateOperationsInput = {
    set?: $Enums.Category
  }

  export type ProductUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProductUpdatevideoInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<UserCreateWithoutProductsInput, UserUncheckedCreateWithoutProductsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductsInput
    upsert?: UserUpsertWithoutProductsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProductsInput, UserUpdateWithoutProductsInput>, UserUncheckedUpdateWithoutProductsInput>
  }

  export type ProductReviewUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductReviewCreateWithoutProductInput, ProductReviewUncheckedCreateWithoutProductInput> | ProductReviewCreateWithoutProductInput[] | ProductReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductReviewCreateOrConnectWithoutProductInput | ProductReviewCreateOrConnectWithoutProductInput[]
    upsert?: ProductReviewUpsertWithWhereUniqueWithoutProductInput | ProductReviewUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductReviewCreateManyProductInputEnvelope
    set?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    disconnect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    delete?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    connect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    update?: ProductReviewUpdateWithWhereUniqueWithoutProductInput | ProductReviewUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductReviewUpdateManyWithWhereWithoutProductInput | ProductReviewUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductReviewScalarWhereInput | ProductReviewScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderCreateWithoutProductInput, OrderUncheckedCreateWithoutProductInput> | OrderCreateWithoutProductInput[] | OrderUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutProductInput | OrderCreateOrConnectWithoutProductInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutProductInput | OrderUpsertWithWhereUniqueWithoutProductInput[]
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutProductInput | OrderUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutProductInput | OrderUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ProductOptionUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductOptionCreateWithoutProductInput, ProductOptionUncheckedCreateWithoutProductInput> | ProductOptionCreateWithoutProductInput[] | ProductOptionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductOptionCreateOrConnectWithoutProductInput | ProductOptionCreateOrConnectWithoutProductInput[]
    upsert?: ProductOptionUpsertWithWhereUniqueWithoutProductInput | ProductOptionUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductOptionCreateManyProductInputEnvelope
    set?: ProductOptionWhereUniqueInput | ProductOptionWhereUniqueInput[]
    disconnect?: ProductOptionWhereUniqueInput | ProductOptionWhereUniqueInput[]
    delete?: ProductOptionWhereUniqueInput | ProductOptionWhereUniqueInput[]
    connect?: ProductOptionWhereUniqueInput | ProductOptionWhereUniqueInput[]
    update?: ProductOptionUpdateWithWhereUniqueWithoutProductInput | ProductOptionUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductOptionUpdateManyWithWhereWithoutProductInput | ProductOptionUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductOptionScalarWhereInput | ProductOptionScalarWhereInput[]
  }

  export type CartItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutProductInput | CartItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutProductInput | CartItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutProductInput | CartItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type SpecialOrderRequestUpdateManyWithoutProductNestedInput = {
    create?: XOR<SpecialOrderRequestCreateWithoutProductInput, SpecialOrderRequestUncheckedCreateWithoutProductInput> | SpecialOrderRequestCreateWithoutProductInput[] | SpecialOrderRequestUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SpecialOrderRequestCreateOrConnectWithoutProductInput | SpecialOrderRequestCreateOrConnectWithoutProductInput[]
    upsert?: SpecialOrderRequestUpsertWithWhereUniqueWithoutProductInput | SpecialOrderRequestUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SpecialOrderRequestCreateManyProductInputEnvelope
    set?: SpecialOrderRequestWhereUniqueInput | SpecialOrderRequestWhereUniqueInput[]
    disconnect?: SpecialOrderRequestWhereUniqueInput | SpecialOrderRequestWhereUniqueInput[]
    delete?: SpecialOrderRequestWhereUniqueInput | SpecialOrderRequestWhereUniqueInput[]
    connect?: SpecialOrderRequestWhereUniqueInput | SpecialOrderRequestWhereUniqueInput[]
    update?: SpecialOrderRequestUpdateWithWhereUniqueWithoutProductInput | SpecialOrderRequestUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SpecialOrderRequestUpdateManyWithWhereWithoutProductInput | SpecialOrderRequestUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SpecialOrderRequestScalarWhereInput | SpecialOrderRequestScalarWhereInput[]
  }

  export type ProductScheduleUpdateOneWithoutProductNestedInput = {
    create?: XOR<ProductScheduleCreateWithoutProductInput, ProductScheduleUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductScheduleCreateOrConnectWithoutProductInput
    upsert?: ProductScheduleUpsertWithoutProductInput
    disconnect?: ProductScheduleWhereInput | boolean
    delete?: ProductScheduleWhereInput | boolean
    connect?: ProductScheduleWhereUniqueInput
    update?: XOR<XOR<ProductScheduleUpdateToOneWithWhereWithoutProductInput, ProductScheduleUpdateWithoutProductInput>, ProductScheduleUncheckedUpdateWithoutProductInput>
  }

  export type ProductReviewUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductReviewCreateWithoutProductInput, ProductReviewUncheckedCreateWithoutProductInput> | ProductReviewCreateWithoutProductInput[] | ProductReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductReviewCreateOrConnectWithoutProductInput | ProductReviewCreateOrConnectWithoutProductInput[]
    upsert?: ProductReviewUpsertWithWhereUniqueWithoutProductInput | ProductReviewUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductReviewCreateManyProductInputEnvelope
    set?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    disconnect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    delete?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    connect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    update?: ProductReviewUpdateWithWhereUniqueWithoutProductInput | ProductReviewUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductReviewUpdateManyWithWhereWithoutProductInput | ProductReviewUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductReviewScalarWhereInput | ProductReviewScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderCreateWithoutProductInput, OrderUncheckedCreateWithoutProductInput> | OrderCreateWithoutProductInput[] | OrderUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutProductInput | OrderCreateOrConnectWithoutProductInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutProductInput | OrderUpsertWithWhereUniqueWithoutProductInput[]
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutProductInput | OrderUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutProductInput | OrderUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ProductOptionUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductOptionCreateWithoutProductInput, ProductOptionUncheckedCreateWithoutProductInput> | ProductOptionCreateWithoutProductInput[] | ProductOptionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductOptionCreateOrConnectWithoutProductInput | ProductOptionCreateOrConnectWithoutProductInput[]
    upsert?: ProductOptionUpsertWithWhereUniqueWithoutProductInput | ProductOptionUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductOptionCreateManyProductInputEnvelope
    set?: ProductOptionWhereUniqueInput | ProductOptionWhereUniqueInput[]
    disconnect?: ProductOptionWhereUniqueInput | ProductOptionWhereUniqueInput[]
    delete?: ProductOptionWhereUniqueInput | ProductOptionWhereUniqueInput[]
    connect?: ProductOptionWhereUniqueInput | ProductOptionWhereUniqueInput[]
    update?: ProductOptionUpdateWithWhereUniqueWithoutProductInput | ProductOptionUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductOptionUpdateManyWithWhereWithoutProductInput | ProductOptionUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductOptionScalarWhereInput | ProductOptionScalarWhereInput[]
  }

  export type CartItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutProductInput | CartItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutProductInput | CartItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutProductInput | CartItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type SpecialOrderRequestUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<SpecialOrderRequestCreateWithoutProductInput, SpecialOrderRequestUncheckedCreateWithoutProductInput> | SpecialOrderRequestCreateWithoutProductInput[] | SpecialOrderRequestUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SpecialOrderRequestCreateOrConnectWithoutProductInput | SpecialOrderRequestCreateOrConnectWithoutProductInput[]
    upsert?: SpecialOrderRequestUpsertWithWhereUniqueWithoutProductInput | SpecialOrderRequestUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SpecialOrderRequestCreateManyProductInputEnvelope
    set?: SpecialOrderRequestWhereUniqueInput | SpecialOrderRequestWhereUniqueInput[]
    disconnect?: SpecialOrderRequestWhereUniqueInput | SpecialOrderRequestWhereUniqueInput[]
    delete?: SpecialOrderRequestWhereUniqueInput | SpecialOrderRequestWhereUniqueInput[]
    connect?: SpecialOrderRequestWhereUniqueInput | SpecialOrderRequestWhereUniqueInput[]
    update?: SpecialOrderRequestUpdateWithWhereUniqueWithoutProductInput | SpecialOrderRequestUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SpecialOrderRequestUpdateManyWithWhereWithoutProductInput | SpecialOrderRequestUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SpecialOrderRequestScalarWhereInput | SpecialOrderRequestScalarWhereInput[]
  }

  export type ProductScheduleUncheckedUpdateOneWithoutProductNestedInput = {
    create?: XOR<ProductScheduleCreateWithoutProductInput, ProductScheduleUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductScheduleCreateOrConnectWithoutProductInput
    upsert?: ProductScheduleUpsertWithoutProductInput
    disconnect?: ProductScheduleWhereInput | boolean
    delete?: ProductScheduleWhereInput | boolean
    connect?: ProductScheduleWhereUniqueInput
    update?: XOR<XOR<ProductScheduleUpdateToOneWithWhereWithoutProductInput, ProductScheduleUpdateWithoutProductInput>, ProductScheduleUncheckedUpdateWithoutProductInput>
  }

  export type ProductCreateNestedOneWithoutProductScheduleInput = {
    create?: XOR<ProductCreateWithoutProductScheduleInput, ProductUncheckedCreateWithoutProductScheduleInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductScheduleInput
    connect?: ProductWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductUpdateOneRequiredWithoutProductScheduleNestedInput = {
    create?: XOR<ProductCreateWithoutProductScheduleInput, ProductUncheckedCreateWithoutProductScheduleInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductScheduleInput
    upsert?: ProductUpsertWithoutProductScheduleInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProductScheduleInput, ProductUpdateWithoutProductScheduleInput>, ProductUncheckedUpdateWithoutProductScheduleInput>
  }

  export type ProductCreateNestedOneWithoutOptionsInput = {
    create?: XOR<ProductCreateWithoutOptionsInput, ProductUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOptionsInput
    connect?: ProductWhereUniqueInput
  }

  export type OrderItemOptionCreateNestedManyWithoutProductOptionInput = {
    create?: XOR<OrderItemOptionCreateWithoutProductOptionInput, OrderItemOptionUncheckedCreateWithoutProductOptionInput> | OrderItemOptionCreateWithoutProductOptionInput[] | OrderItemOptionUncheckedCreateWithoutProductOptionInput[]
    connectOrCreate?: OrderItemOptionCreateOrConnectWithoutProductOptionInput | OrderItemOptionCreateOrConnectWithoutProductOptionInput[]
    createMany?: OrderItemOptionCreateManyProductOptionInputEnvelope
    connect?: OrderItemOptionWhereUniqueInput | OrderItemOptionWhereUniqueInput[]
  }

  export type CartItemOptionCreateNestedManyWithoutProductOptionInput = {
    create?: XOR<CartItemOptionCreateWithoutProductOptionInput, CartItemOptionUncheckedCreateWithoutProductOptionInput> | CartItemOptionCreateWithoutProductOptionInput[] | CartItemOptionUncheckedCreateWithoutProductOptionInput[]
    connectOrCreate?: CartItemOptionCreateOrConnectWithoutProductOptionInput | CartItemOptionCreateOrConnectWithoutProductOptionInput[]
    createMany?: CartItemOptionCreateManyProductOptionInputEnvelope
    connect?: CartItemOptionWhereUniqueInput | CartItemOptionWhereUniqueInput[]
  }

  export type OrderItemOptionUncheckedCreateNestedManyWithoutProductOptionInput = {
    create?: XOR<OrderItemOptionCreateWithoutProductOptionInput, OrderItemOptionUncheckedCreateWithoutProductOptionInput> | OrderItemOptionCreateWithoutProductOptionInput[] | OrderItemOptionUncheckedCreateWithoutProductOptionInput[]
    connectOrCreate?: OrderItemOptionCreateOrConnectWithoutProductOptionInput | OrderItemOptionCreateOrConnectWithoutProductOptionInput[]
    createMany?: OrderItemOptionCreateManyProductOptionInputEnvelope
    connect?: OrderItemOptionWhereUniqueInput | OrderItemOptionWhereUniqueInput[]
  }

  export type CartItemOptionUncheckedCreateNestedManyWithoutProductOptionInput = {
    create?: XOR<CartItemOptionCreateWithoutProductOptionInput, CartItemOptionUncheckedCreateWithoutProductOptionInput> | CartItemOptionCreateWithoutProductOptionInput[] | CartItemOptionUncheckedCreateWithoutProductOptionInput[]
    connectOrCreate?: CartItemOptionCreateOrConnectWithoutProductOptionInput | CartItemOptionCreateOrConnectWithoutProductOptionInput[]
    createMany?: CartItemOptionCreateManyProductOptionInputEnvelope
    connect?: CartItemOptionWhereUniqueInput | CartItemOptionWhereUniqueInput[]
  }

  export type ProductUpdateOneRequiredWithoutOptionsNestedInput = {
    create?: XOR<ProductCreateWithoutOptionsInput, ProductUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOptionsInput
    upsert?: ProductUpsertWithoutOptionsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutOptionsInput, ProductUpdateWithoutOptionsInput>, ProductUncheckedUpdateWithoutOptionsInput>
  }

  export type OrderItemOptionUpdateManyWithoutProductOptionNestedInput = {
    create?: XOR<OrderItemOptionCreateWithoutProductOptionInput, OrderItemOptionUncheckedCreateWithoutProductOptionInput> | OrderItemOptionCreateWithoutProductOptionInput[] | OrderItemOptionUncheckedCreateWithoutProductOptionInput[]
    connectOrCreate?: OrderItemOptionCreateOrConnectWithoutProductOptionInput | OrderItemOptionCreateOrConnectWithoutProductOptionInput[]
    upsert?: OrderItemOptionUpsertWithWhereUniqueWithoutProductOptionInput | OrderItemOptionUpsertWithWhereUniqueWithoutProductOptionInput[]
    createMany?: OrderItemOptionCreateManyProductOptionInputEnvelope
    set?: OrderItemOptionWhereUniqueInput | OrderItemOptionWhereUniqueInput[]
    disconnect?: OrderItemOptionWhereUniqueInput | OrderItemOptionWhereUniqueInput[]
    delete?: OrderItemOptionWhereUniqueInput | OrderItemOptionWhereUniqueInput[]
    connect?: OrderItemOptionWhereUniqueInput | OrderItemOptionWhereUniqueInput[]
    update?: OrderItemOptionUpdateWithWhereUniqueWithoutProductOptionInput | OrderItemOptionUpdateWithWhereUniqueWithoutProductOptionInput[]
    updateMany?: OrderItemOptionUpdateManyWithWhereWithoutProductOptionInput | OrderItemOptionUpdateManyWithWhereWithoutProductOptionInput[]
    deleteMany?: OrderItemOptionScalarWhereInput | OrderItemOptionScalarWhereInput[]
  }

  export type CartItemOptionUpdateManyWithoutProductOptionNestedInput = {
    create?: XOR<CartItemOptionCreateWithoutProductOptionInput, CartItemOptionUncheckedCreateWithoutProductOptionInput> | CartItemOptionCreateWithoutProductOptionInput[] | CartItemOptionUncheckedCreateWithoutProductOptionInput[]
    connectOrCreate?: CartItemOptionCreateOrConnectWithoutProductOptionInput | CartItemOptionCreateOrConnectWithoutProductOptionInput[]
    upsert?: CartItemOptionUpsertWithWhereUniqueWithoutProductOptionInput | CartItemOptionUpsertWithWhereUniqueWithoutProductOptionInput[]
    createMany?: CartItemOptionCreateManyProductOptionInputEnvelope
    set?: CartItemOptionWhereUniqueInput | CartItemOptionWhereUniqueInput[]
    disconnect?: CartItemOptionWhereUniqueInput | CartItemOptionWhereUniqueInput[]
    delete?: CartItemOptionWhereUniqueInput | CartItemOptionWhereUniqueInput[]
    connect?: CartItemOptionWhereUniqueInput | CartItemOptionWhereUniqueInput[]
    update?: CartItemOptionUpdateWithWhereUniqueWithoutProductOptionInput | CartItemOptionUpdateWithWhereUniqueWithoutProductOptionInput[]
    updateMany?: CartItemOptionUpdateManyWithWhereWithoutProductOptionInput | CartItemOptionUpdateManyWithWhereWithoutProductOptionInput[]
    deleteMany?: CartItemOptionScalarWhereInput | CartItemOptionScalarWhereInput[]
  }

  export type OrderItemOptionUncheckedUpdateManyWithoutProductOptionNestedInput = {
    create?: XOR<OrderItemOptionCreateWithoutProductOptionInput, OrderItemOptionUncheckedCreateWithoutProductOptionInput> | OrderItemOptionCreateWithoutProductOptionInput[] | OrderItemOptionUncheckedCreateWithoutProductOptionInput[]
    connectOrCreate?: OrderItemOptionCreateOrConnectWithoutProductOptionInput | OrderItemOptionCreateOrConnectWithoutProductOptionInput[]
    upsert?: OrderItemOptionUpsertWithWhereUniqueWithoutProductOptionInput | OrderItemOptionUpsertWithWhereUniqueWithoutProductOptionInput[]
    createMany?: OrderItemOptionCreateManyProductOptionInputEnvelope
    set?: OrderItemOptionWhereUniqueInput | OrderItemOptionWhereUniqueInput[]
    disconnect?: OrderItemOptionWhereUniqueInput | OrderItemOptionWhereUniqueInput[]
    delete?: OrderItemOptionWhereUniqueInput | OrderItemOptionWhereUniqueInput[]
    connect?: OrderItemOptionWhereUniqueInput | OrderItemOptionWhereUniqueInput[]
    update?: OrderItemOptionUpdateWithWhereUniqueWithoutProductOptionInput | OrderItemOptionUpdateWithWhereUniqueWithoutProductOptionInput[]
    updateMany?: OrderItemOptionUpdateManyWithWhereWithoutProductOptionInput | OrderItemOptionUpdateManyWithWhereWithoutProductOptionInput[]
    deleteMany?: OrderItemOptionScalarWhereInput | OrderItemOptionScalarWhereInput[]
  }

  export type CartItemOptionUncheckedUpdateManyWithoutProductOptionNestedInput = {
    create?: XOR<CartItemOptionCreateWithoutProductOptionInput, CartItemOptionUncheckedCreateWithoutProductOptionInput> | CartItemOptionCreateWithoutProductOptionInput[] | CartItemOptionUncheckedCreateWithoutProductOptionInput[]
    connectOrCreate?: CartItemOptionCreateOrConnectWithoutProductOptionInput | CartItemOptionCreateOrConnectWithoutProductOptionInput[]
    upsert?: CartItemOptionUpsertWithWhereUniqueWithoutProductOptionInput | CartItemOptionUpsertWithWhereUniqueWithoutProductOptionInput[]
    createMany?: CartItemOptionCreateManyProductOptionInputEnvelope
    set?: CartItemOptionWhereUniqueInput | CartItemOptionWhereUniqueInput[]
    disconnect?: CartItemOptionWhereUniqueInput | CartItemOptionWhereUniqueInput[]
    delete?: CartItemOptionWhereUniqueInput | CartItemOptionWhereUniqueInput[]
    connect?: CartItemOptionWhereUniqueInput | CartItemOptionWhereUniqueInput[]
    update?: CartItemOptionUpdateWithWhereUniqueWithoutProductOptionInput | CartItemOptionUpdateWithWhereUniqueWithoutProductOptionInput[]
    updateMany?: CartItemOptionUpdateManyWithWhereWithoutProductOptionInput | CartItemOptionUpdateManyWithWhereWithoutProductOptionInput[]
    deleteMany?: CartItemOptionScalarWhereInput | CartItemOptionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCustomerOrdersInput = {
    create?: XOR<UserCreateWithoutCustomerOrdersInput, UserUncheckedCreateWithoutCustomerOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomerOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVendorOrdersInput = {
    create?: XOR<UserCreateWithoutVendorOrdersInput, UserUncheckedCreateWithoutVendorOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutVendorOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type AddressCreateNestedOneWithoutOrdersInput = {
    create?: XOR<AddressCreateWithoutOrdersInput, AddressUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: AddressCreateOrConnectWithoutOrdersInput
    connect?: AddressWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutOrdersInput = {
    create?: XOR<ProductCreateWithoutOrdersInput, ProductUncheckedCreateWithoutOrdersInput> | ProductCreateWithoutOrdersInput[] | ProductUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutOrdersInput | ProductCreateOrConnectWithoutOrdersInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type DeliveryAssignmentCreateNestedManyWithoutOrderInput = {
    create?: XOR<DeliveryAssignmentCreateWithoutOrderInput, DeliveryAssignmentUncheckedCreateWithoutOrderInput> | DeliveryAssignmentCreateWithoutOrderInput[] | DeliveryAssignmentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DeliveryAssignmentCreateOrConnectWithoutOrderInput | DeliveryAssignmentCreateOrConnectWithoutOrderInput[]
    createMany?: DeliveryAssignmentCreateManyOrderInputEnvelope
    connect?: DeliveryAssignmentWhereUniqueInput | DeliveryAssignmentWhereUniqueInput[]
  }

  export type DeliveryEarningCreateNestedManyWithoutOrderInput = {
    create?: XOR<DeliveryEarningCreateWithoutOrderInput, DeliveryEarningUncheckedCreateWithoutOrderInput> | DeliveryEarningCreateWithoutOrderInput[] | DeliveryEarningUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DeliveryEarningCreateOrConnectWithoutOrderInput | DeliveryEarningCreateOrConnectWithoutOrderInput[]
    createMany?: DeliveryEarningCreateManyOrderInputEnvelope
    connect?: DeliveryEarningWhereUniqueInput | DeliveryEarningWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutOrderInput = {
    create?: XOR<ActivityCreateWithoutOrderInput, ActivityUncheckedCreateWithoutOrderInput> | ActivityCreateWithoutOrderInput[] | ActivityUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutOrderInput | ActivityCreateOrConnectWithoutOrderInput[]
    createMany?: ActivityCreateManyOrderInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type DeliveryBroadcastCreateNestedManyWithoutOrderInput = {
    create?: XOR<DeliveryBroadcastCreateWithoutOrderInput, DeliveryBroadcastUncheckedCreateWithoutOrderInput> | DeliveryBroadcastCreateWithoutOrderInput[] | DeliveryBroadcastUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DeliveryBroadcastCreateOrConnectWithoutOrderInput | DeliveryBroadcastCreateOrConnectWithoutOrderInput[]
    createMany?: DeliveryBroadcastCreateManyOrderInputEnvelope
    connect?: DeliveryBroadcastWhereUniqueInput | DeliveryBroadcastWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutOrdersInput = {
    create?: XOR<ProductCreateWithoutOrdersInput, ProductUncheckedCreateWithoutOrdersInput> | ProductCreateWithoutOrdersInput[] | ProductUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutOrdersInput | ProductCreateOrConnectWithoutOrdersInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type DeliveryAssignmentUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<DeliveryAssignmentCreateWithoutOrderInput, DeliveryAssignmentUncheckedCreateWithoutOrderInput> | DeliveryAssignmentCreateWithoutOrderInput[] | DeliveryAssignmentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DeliveryAssignmentCreateOrConnectWithoutOrderInput | DeliveryAssignmentCreateOrConnectWithoutOrderInput[]
    createMany?: DeliveryAssignmentCreateManyOrderInputEnvelope
    connect?: DeliveryAssignmentWhereUniqueInput | DeliveryAssignmentWhereUniqueInput[]
  }

  export type DeliveryEarningUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<DeliveryEarningCreateWithoutOrderInput, DeliveryEarningUncheckedCreateWithoutOrderInput> | DeliveryEarningCreateWithoutOrderInput[] | DeliveryEarningUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DeliveryEarningCreateOrConnectWithoutOrderInput | DeliveryEarningCreateOrConnectWithoutOrderInput[]
    createMany?: DeliveryEarningCreateManyOrderInputEnvelope
    connect?: DeliveryEarningWhereUniqueInput | DeliveryEarningWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<ActivityCreateWithoutOrderInput, ActivityUncheckedCreateWithoutOrderInput> | ActivityCreateWithoutOrderInput[] | ActivityUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutOrderInput | ActivityCreateOrConnectWithoutOrderInput[]
    createMany?: ActivityCreateManyOrderInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type DeliveryBroadcastUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<DeliveryBroadcastCreateWithoutOrderInput, DeliveryBroadcastUncheckedCreateWithoutOrderInput> | DeliveryBroadcastCreateWithoutOrderInput[] | DeliveryBroadcastUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DeliveryBroadcastCreateOrConnectWithoutOrderInput | DeliveryBroadcastCreateOrConnectWithoutOrderInput[]
    createMany?: DeliveryBroadcastCreateManyOrderInputEnvelope
    connect?: DeliveryBroadcastWhereUniqueInput | DeliveryBroadcastWhereUniqueInput[]
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type NullableEnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus | null
  }

  export type UserUpdateOneRequiredWithoutCustomerOrdersNestedInput = {
    create?: XOR<UserCreateWithoutCustomerOrdersInput, UserUncheckedCreateWithoutCustomerOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomerOrdersInput
    upsert?: UserUpsertWithoutCustomerOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCustomerOrdersInput, UserUpdateWithoutCustomerOrdersInput>, UserUncheckedUpdateWithoutCustomerOrdersInput>
  }

  export type UserUpdateOneRequiredWithoutVendorOrdersNestedInput = {
    create?: XOR<UserCreateWithoutVendorOrdersInput, UserUncheckedCreateWithoutVendorOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutVendorOrdersInput
    upsert?: UserUpsertWithoutVendorOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVendorOrdersInput, UserUpdateWithoutVendorOrdersInput>, UserUncheckedUpdateWithoutVendorOrdersInput>
  }

  export type AddressUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<AddressCreateWithoutOrdersInput, AddressUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: AddressCreateOrConnectWithoutOrdersInput
    upsert?: AddressUpsertWithoutOrdersInput
    disconnect?: AddressWhereInput | boolean
    delete?: AddressWhereInput | boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutOrdersInput, AddressUpdateWithoutOrdersInput>, AddressUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutOrderInput | PaymentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutOrderInput | PaymentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutOrderInput | PaymentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutOrdersNestedInput = {
    create?: XOR<ProductCreateWithoutOrdersInput, ProductUncheckedCreateWithoutOrdersInput> | ProductCreateWithoutOrdersInput[] | ProductUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutOrdersInput | ProductCreateOrConnectWithoutOrdersInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutOrdersInput | ProductUpsertWithWhereUniqueWithoutOrdersInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutOrdersInput | ProductUpdateWithWhereUniqueWithoutOrdersInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutOrdersInput | ProductUpdateManyWithWhereWithoutOrdersInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type DeliveryAssignmentUpdateManyWithoutOrderNestedInput = {
    create?: XOR<DeliveryAssignmentCreateWithoutOrderInput, DeliveryAssignmentUncheckedCreateWithoutOrderInput> | DeliveryAssignmentCreateWithoutOrderInput[] | DeliveryAssignmentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DeliveryAssignmentCreateOrConnectWithoutOrderInput | DeliveryAssignmentCreateOrConnectWithoutOrderInput[]
    upsert?: DeliveryAssignmentUpsertWithWhereUniqueWithoutOrderInput | DeliveryAssignmentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: DeliveryAssignmentCreateManyOrderInputEnvelope
    set?: DeliveryAssignmentWhereUniqueInput | DeliveryAssignmentWhereUniqueInput[]
    disconnect?: DeliveryAssignmentWhereUniqueInput | DeliveryAssignmentWhereUniqueInput[]
    delete?: DeliveryAssignmentWhereUniqueInput | DeliveryAssignmentWhereUniqueInput[]
    connect?: DeliveryAssignmentWhereUniqueInput | DeliveryAssignmentWhereUniqueInput[]
    update?: DeliveryAssignmentUpdateWithWhereUniqueWithoutOrderInput | DeliveryAssignmentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: DeliveryAssignmentUpdateManyWithWhereWithoutOrderInput | DeliveryAssignmentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: DeliveryAssignmentScalarWhereInput | DeliveryAssignmentScalarWhereInput[]
  }

  export type DeliveryEarningUpdateManyWithoutOrderNestedInput = {
    create?: XOR<DeliveryEarningCreateWithoutOrderInput, DeliveryEarningUncheckedCreateWithoutOrderInput> | DeliveryEarningCreateWithoutOrderInput[] | DeliveryEarningUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DeliveryEarningCreateOrConnectWithoutOrderInput | DeliveryEarningCreateOrConnectWithoutOrderInput[]
    upsert?: DeliveryEarningUpsertWithWhereUniqueWithoutOrderInput | DeliveryEarningUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: DeliveryEarningCreateManyOrderInputEnvelope
    set?: DeliveryEarningWhereUniqueInput | DeliveryEarningWhereUniqueInput[]
    disconnect?: DeliveryEarningWhereUniqueInput | DeliveryEarningWhereUniqueInput[]
    delete?: DeliveryEarningWhereUniqueInput | DeliveryEarningWhereUniqueInput[]
    connect?: DeliveryEarningWhereUniqueInput | DeliveryEarningWhereUniqueInput[]
    update?: DeliveryEarningUpdateWithWhereUniqueWithoutOrderInput | DeliveryEarningUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: DeliveryEarningUpdateManyWithWhereWithoutOrderInput | DeliveryEarningUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: DeliveryEarningScalarWhereInput | DeliveryEarningScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ActivityCreateWithoutOrderInput, ActivityUncheckedCreateWithoutOrderInput> | ActivityCreateWithoutOrderInput[] | ActivityUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutOrderInput | ActivityCreateOrConnectWithoutOrderInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutOrderInput | ActivityUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ActivityCreateManyOrderInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutOrderInput | ActivityUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutOrderInput | ActivityUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type DeliveryBroadcastUpdateManyWithoutOrderNestedInput = {
    create?: XOR<DeliveryBroadcastCreateWithoutOrderInput, DeliveryBroadcastUncheckedCreateWithoutOrderInput> | DeliveryBroadcastCreateWithoutOrderInput[] | DeliveryBroadcastUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DeliveryBroadcastCreateOrConnectWithoutOrderInput | DeliveryBroadcastCreateOrConnectWithoutOrderInput[]
    upsert?: DeliveryBroadcastUpsertWithWhereUniqueWithoutOrderInput | DeliveryBroadcastUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: DeliveryBroadcastCreateManyOrderInputEnvelope
    set?: DeliveryBroadcastWhereUniqueInput | DeliveryBroadcastWhereUniqueInput[]
    disconnect?: DeliveryBroadcastWhereUniqueInput | DeliveryBroadcastWhereUniqueInput[]
    delete?: DeliveryBroadcastWhereUniqueInput | DeliveryBroadcastWhereUniqueInput[]
    connect?: DeliveryBroadcastWhereUniqueInput | DeliveryBroadcastWhereUniqueInput[]
    update?: DeliveryBroadcastUpdateWithWhereUniqueWithoutOrderInput | DeliveryBroadcastUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: DeliveryBroadcastUpdateManyWithWhereWithoutOrderInput | DeliveryBroadcastUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: DeliveryBroadcastScalarWhereInput | DeliveryBroadcastScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutOrderInput | PaymentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutOrderInput | PaymentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutOrderInput | PaymentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutOrdersNestedInput = {
    create?: XOR<ProductCreateWithoutOrdersInput, ProductUncheckedCreateWithoutOrdersInput> | ProductCreateWithoutOrdersInput[] | ProductUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutOrdersInput | ProductCreateOrConnectWithoutOrdersInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutOrdersInput | ProductUpsertWithWhereUniqueWithoutOrdersInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutOrdersInput | ProductUpdateWithWhereUniqueWithoutOrdersInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutOrdersInput | ProductUpdateManyWithWhereWithoutOrdersInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type DeliveryAssignmentUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<DeliveryAssignmentCreateWithoutOrderInput, DeliveryAssignmentUncheckedCreateWithoutOrderInput> | DeliveryAssignmentCreateWithoutOrderInput[] | DeliveryAssignmentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DeliveryAssignmentCreateOrConnectWithoutOrderInput | DeliveryAssignmentCreateOrConnectWithoutOrderInput[]
    upsert?: DeliveryAssignmentUpsertWithWhereUniqueWithoutOrderInput | DeliveryAssignmentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: DeliveryAssignmentCreateManyOrderInputEnvelope
    set?: DeliveryAssignmentWhereUniqueInput | DeliveryAssignmentWhereUniqueInput[]
    disconnect?: DeliveryAssignmentWhereUniqueInput | DeliveryAssignmentWhereUniqueInput[]
    delete?: DeliveryAssignmentWhereUniqueInput | DeliveryAssignmentWhereUniqueInput[]
    connect?: DeliveryAssignmentWhereUniqueInput | DeliveryAssignmentWhereUniqueInput[]
    update?: DeliveryAssignmentUpdateWithWhereUniqueWithoutOrderInput | DeliveryAssignmentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: DeliveryAssignmentUpdateManyWithWhereWithoutOrderInput | DeliveryAssignmentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: DeliveryAssignmentScalarWhereInput | DeliveryAssignmentScalarWhereInput[]
  }

  export type DeliveryEarningUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<DeliveryEarningCreateWithoutOrderInput, DeliveryEarningUncheckedCreateWithoutOrderInput> | DeliveryEarningCreateWithoutOrderInput[] | DeliveryEarningUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DeliveryEarningCreateOrConnectWithoutOrderInput | DeliveryEarningCreateOrConnectWithoutOrderInput[]
    upsert?: DeliveryEarningUpsertWithWhereUniqueWithoutOrderInput | DeliveryEarningUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: DeliveryEarningCreateManyOrderInputEnvelope
    set?: DeliveryEarningWhereUniqueInput | DeliveryEarningWhereUniqueInput[]
    disconnect?: DeliveryEarningWhereUniqueInput | DeliveryEarningWhereUniqueInput[]
    delete?: DeliveryEarningWhereUniqueInput | DeliveryEarningWhereUniqueInput[]
    connect?: DeliveryEarningWhereUniqueInput | DeliveryEarningWhereUniqueInput[]
    update?: DeliveryEarningUpdateWithWhereUniqueWithoutOrderInput | DeliveryEarningUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: DeliveryEarningUpdateManyWithWhereWithoutOrderInput | DeliveryEarningUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: DeliveryEarningScalarWhereInput | DeliveryEarningScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ActivityCreateWithoutOrderInput, ActivityUncheckedCreateWithoutOrderInput> | ActivityCreateWithoutOrderInput[] | ActivityUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutOrderInput | ActivityCreateOrConnectWithoutOrderInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutOrderInput | ActivityUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ActivityCreateManyOrderInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutOrderInput | ActivityUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutOrderInput | ActivityUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type DeliveryBroadcastUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<DeliveryBroadcastCreateWithoutOrderInput, DeliveryBroadcastUncheckedCreateWithoutOrderInput> | DeliveryBroadcastCreateWithoutOrderInput[] | DeliveryBroadcastUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DeliveryBroadcastCreateOrConnectWithoutOrderInput | DeliveryBroadcastCreateOrConnectWithoutOrderInput[]
    upsert?: DeliveryBroadcastUpsertWithWhereUniqueWithoutOrderInput | DeliveryBroadcastUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: DeliveryBroadcastCreateManyOrderInputEnvelope
    set?: DeliveryBroadcastWhereUniqueInput | DeliveryBroadcastWhereUniqueInput[]
    disconnect?: DeliveryBroadcastWhereUniqueInput | DeliveryBroadcastWhereUniqueInput[]
    delete?: DeliveryBroadcastWhereUniqueInput | DeliveryBroadcastWhereUniqueInput[]
    connect?: DeliveryBroadcastWhereUniqueInput | DeliveryBroadcastWhereUniqueInput[]
    update?: DeliveryBroadcastUpdateWithWhereUniqueWithoutOrderInput | DeliveryBroadcastUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: DeliveryBroadcastUpdateManyWithWhereWithoutOrderInput | DeliveryBroadcastUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: DeliveryBroadcastScalarWhereInput | DeliveryBroadcastScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type OrderItemOptionCreateNestedManyWithoutOrderItemInput = {
    create?: XOR<OrderItemOptionCreateWithoutOrderItemInput, OrderItemOptionUncheckedCreateWithoutOrderItemInput> | OrderItemOptionCreateWithoutOrderItemInput[] | OrderItemOptionUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: OrderItemOptionCreateOrConnectWithoutOrderItemInput | OrderItemOptionCreateOrConnectWithoutOrderItemInput[]
    createMany?: OrderItemOptionCreateManyOrderItemInputEnvelope
    connect?: OrderItemOptionWhereUniqueInput | OrderItemOptionWhereUniqueInput[]
  }

  export type OrderItemOptionUncheckedCreateNestedManyWithoutOrderItemInput = {
    create?: XOR<OrderItemOptionCreateWithoutOrderItemInput, OrderItemOptionUncheckedCreateWithoutOrderItemInput> | OrderItemOptionCreateWithoutOrderItemInput[] | OrderItemOptionUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: OrderItemOptionCreateOrConnectWithoutOrderItemInput | OrderItemOptionCreateOrConnectWithoutOrderItemInput[]
    createMany?: OrderItemOptionCreateManyOrderItemInputEnvelope
    connect?: OrderItemOptionWhereUniqueInput | OrderItemOptionWhereUniqueInput[]
  }

  export type OrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    upsert?: OrderUpsertWithoutItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutItemsInput, OrderUpdateWithoutItemsInput>, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    upsert?: ProductUpsertWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutOrderItemsInput, ProductUpdateWithoutOrderItemsInput>, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type OrderItemOptionUpdateManyWithoutOrderItemNestedInput = {
    create?: XOR<OrderItemOptionCreateWithoutOrderItemInput, OrderItemOptionUncheckedCreateWithoutOrderItemInput> | OrderItemOptionCreateWithoutOrderItemInput[] | OrderItemOptionUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: OrderItemOptionCreateOrConnectWithoutOrderItemInput | OrderItemOptionCreateOrConnectWithoutOrderItemInput[]
    upsert?: OrderItemOptionUpsertWithWhereUniqueWithoutOrderItemInput | OrderItemOptionUpsertWithWhereUniqueWithoutOrderItemInput[]
    createMany?: OrderItemOptionCreateManyOrderItemInputEnvelope
    set?: OrderItemOptionWhereUniqueInput | OrderItemOptionWhereUniqueInput[]
    disconnect?: OrderItemOptionWhereUniqueInput | OrderItemOptionWhereUniqueInput[]
    delete?: OrderItemOptionWhereUniqueInput | OrderItemOptionWhereUniqueInput[]
    connect?: OrderItemOptionWhereUniqueInput | OrderItemOptionWhereUniqueInput[]
    update?: OrderItemOptionUpdateWithWhereUniqueWithoutOrderItemInput | OrderItemOptionUpdateWithWhereUniqueWithoutOrderItemInput[]
    updateMany?: OrderItemOptionUpdateManyWithWhereWithoutOrderItemInput | OrderItemOptionUpdateManyWithWhereWithoutOrderItemInput[]
    deleteMany?: OrderItemOptionScalarWhereInput | OrderItemOptionScalarWhereInput[]
  }

  export type OrderItemOptionUncheckedUpdateManyWithoutOrderItemNestedInput = {
    create?: XOR<OrderItemOptionCreateWithoutOrderItemInput, OrderItemOptionUncheckedCreateWithoutOrderItemInput> | OrderItemOptionCreateWithoutOrderItemInput[] | OrderItemOptionUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: OrderItemOptionCreateOrConnectWithoutOrderItemInput | OrderItemOptionCreateOrConnectWithoutOrderItemInput[]
    upsert?: OrderItemOptionUpsertWithWhereUniqueWithoutOrderItemInput | OrderItemOptionUpsertWithWhereUniqueWithoutOrderItemInput[]
    createMany?: OrderItemOptionCreateManyOrderItemInputEnvelope
    set?: OrderItemOptionWhereUniqueInput | OrderItemOptionWhereUniqueInput[]
    disconnect?: OrderItemOptionWhereUniqueInput | OrderItemOptionWhereUniqueInput[]
    delete?: OrderItemOptionWhereUniqueInput | OrderItemOptionWhereUniqueInput[]
    connect?: OrderItemOptionWhereUniqueInput | OrderItemOptionWhereUniqueInput[]
    update?: OrderItemOptionUpdateWithWhereUniqueWithoutOrderItemInput | OrderItemOptionUpdateWithWhereUniqueWithoutOrderItemInput[]
    updateMany?: OrderItemOptionUpdateManyWithWhereWithoutOrderItemInput | OrderItemOptionUpdateManyWithWhereWithoutOrderItemInput[]
    deleteMany?: OrderItemOptionScalarWhereInput | OrderItemOptionScalarWhereInput[]
  }

  export type OrderItemCreateNestedOneWithoutOptionsInput = {
    create?: XOR<OrderItemCreateWithoutOptionsInput, OrderItemUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: OrderItemCreateOrConnectWithoutOptionsInput
    connect?: OrderItemWhereUniqueInput
  }

  export type ProductOptionCreateNestedOneWithoutOrderItemOptionInput = {
    create?: XOR<ProductOptionCreateWithoutOrderItemOptionInput, ProductOptionUncheckedCreateWithoutOrderItemOptionInput>
    connectOrCreate?: ProductOptionCreateOrConnectWithoutOrderItemOptionInput
    connect?: ProductOptionWhereUniqueInput
  }

  export type OrderItemUpdateOneRequiredWithoutOptionsNestedInput = {
    create?: XOR<OrderItemCreateWithoutOptionsInput, OrderItemUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: OrderItemCreateOrConnectWithoutOptionsInput
    upsert?: OrderItemUpsertWithoutOptionsInput
    connect?: OrderItemWhereUniqueInput
    update?: XOR<XOR<OrderItemUpdateToOneWithWhereWithoutOptionsInput, OrderItemUpdateWithoutOptionsInput>, OrderItemUncheckedUpdateWithoutOptionsInput>
  }

  export type ProductOptionUpdateOneRequiredWithoutOrderItemOptionNestedInput = {
    create?: XOR<ProductOptionCreateWithoutOrderItemOptionInput, ProductOptionUncheckedCreateWithoutOrderItemOptionInput>
    connectOrCreate?: ProductOptionCreateOrConnectWithoutOrderItemOptionInput
    upsert?: ProductOptionUpsertWithoutOrderItemOptionInput
    connect?: ProductOptionWhereUniqueInput
    update?: XOR<XOR<ProductOptionUpdateToOneWithWhereWithoutOrderItemOptionInput, ProductOptionUpdateWithoutOrderItemOptionInput>, ProductOptionUncheckedUpdateWithoutOrderItemOptionInput>
  }

  export type ProductReviewCreateimagesInput = {
    set: string[]
  }

  export type ProductCreateNestedOneWithoutReviewsInput = {
    create?: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutReviewsInput
    connect?: ProductWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProductReviewsGivenInput = {
    create?: XOR<UserCreateWithoutProductReviewsGivenInput, UserUncheckedCreateWithoutProductReviewsGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductReviewsGivenInput
    connect?: UserWhereUniqueInput
  }

  export type VendorReplyCreateNestedOneWithoutReviewInput = {
    create?: XOR<VendorReplyCreateWithoutReviewInput, VendorReplyUncheckedCreateWithoutReviewInput>
    connectOrCreate?: VendorReplyCreateOrConnectWithoutReviewInput
    connect?: VendorReplyWhereUniqueInput
  }

  export type ReviewVoteCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewVoteCreateWithoutReviewInput, ReviewVoteUncheckedCreateWithoutReviewInput> | ReviewVoteCreateWithoutReviewInput[] | ReviewVoteUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewVoteCreateOrConnectWithoutReviewInput | ReviewVoteCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewVoteCreateManyReviewInputEnvelope
    connect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
  }

  export type ReviewReportCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewReportCreateWithoutReviewInput, ReviewReportUncheckedCreateWithoutReviewInput> | ReviewReportCreateWithoutReviewInput[] | ReviewReportUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewReportCreateOrConnectWithoutReviewInput | ReviewReportCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewReportCreateManyReviewInputEnvelope
    connect?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
  }

  export type VendorReplyUncheckedCreateNestedOneWithoutReviewInput = {
    create?: XOR<VendorReplyCreateWithoutReviewInput, VendorReplyUncheckedCreateWithoutReviewInput>
    connectOrCreate?: VendorReplyCreateOrConnectWithoutReviewInput
    connect?: VendorReplyWhereUniqueInput
  }

  export type ReviewVoteUncheckedCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewVoteCreateWithoutReviewInput, ReviewVoteUncheckedCreateWithoutReviewInput> | ReviewVoteCreateWithoutReviewInput[] | ReviewVoteUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewVoteCreateOrConnectWithoutReviewInput | ReviewVoteCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewVoteCreateManyReviewInputEnvelope
    connect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
  }

  export type ReviewReportUncheckedCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewReportCreateWithoutReviewInput, ReviewReportUncheckedCreateWithoutReviewInput> | ReviewReportCreateWithoutReviewInput[] | ReviewReportUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewReportCreateOrConnectWithoutReviewInput | ReviewReportCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewReportCreateManyReviewInputEnvelope
    connect?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
  }

  export type ProductReviewUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProductUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutReviewsInput
    upsert?: ProductUpsertWithoutReviewsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutReviewsInput, ProductUpdateWithoutReviewsInput>, ProductUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateOneRequiredWithoutProductReviewsGivenNestedInput = {
    create?: XOR<UserCreateWithoutProductReviewsGivenInput, UserUncheckedCreateWithoutProductReviewsGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductReviewsGivenInput
    upsert?: UserUpsertWithoutProductReviewsGivenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProductReviewsGivenInput, UserUpdateWithoutProductReviewsGivenInput>, UserUncheckedUpdateWithoutProductReviewsGivenInput>
  }

  export type VendorReplyUpdateOneWithoutReviewNestedInput = {
    create?: XOR<VendorReplyCreateWithoutReviewInput, VendorReplyUncheckedCreateWithoutReviewInput>
    connectOrCreate?: VendorReplyCreateOrConnectWithoutReviewInput
    upsert?: VendorReplyUpsertWithoutReviewInput
    disconnect?: VendorReplyWhereInput | boolean
    delete?: VendorReplyWhereInput | boolean
    connect?: VendorReplyWhereUniqueInput
    update?: XOR<XOR<VendorReplyUpdateToOneWithWhereWithoutReviewInput, VendorReplyUpdateWithoutReviewInput>, VendorReplyUncheckedUpdateWithoutReviewInput>
  }

  export type ReviewVoteUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewVoteCreateWithoutReviewInput, ReviewVoteUncheckedCreateWithoutReviewInput> | ReviewVoteCreateWithoutReviewInput[] | ReviewVoteUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewVoteCreateOrConnectWithoutReviewInput | ReviewVoteCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewVoteUpsertWithWhereUniqueWithoutReviewInput | ReviewVoteUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewVoteCreateManyReviewInputEnvelope
    set?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    disconnect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    delete?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    connect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    update?: ReviewVoteUpdateWithWhereUniqueWithoutReviewInput | ReviewVoteUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewVoteUpdateManyWithWhereWithoutReviewInput | ReviewVoteUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewVoteScalarWhereInput | ReviewVoteScalarWhereInput[]
  }

  export type ReviewReportUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewReportCreateWithoutReviewInput, ReviewReportUncheckedCreateWithoutReviewInput> | ReviewReportCreateWithoutReviewInput[] | ReviewReportUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewReportCreateOrConnectWithoutReviewInput | ReviewReportCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewReportUpsertWithWhereUniqueWithoutReviewInput | ReviewReportUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewReportCreateManyReviewInputEnvelope
    set?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
    disconnect?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
    delete?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
    connect?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
    update?: ReviewReportUpdateWithWhereUniqueWithoutReviewInput | ReviewReportUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewReportUpdateManyWithWhereWithoutReviewInput | ReviewReportUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewReportScalarWhereInput | ReviewReportScalarWhereInput[]
  }

  export type VendorReplyUncheckedUpdateOneWithoutReviewNestedInput = {
    create?: XOR<VendorReplyCreateWithoutReviewInput, VendorReplyUncheckedCreateWithoutReviewInput>
    connectOrCreate?: VendorReplyCreateOrConnectWithoutReviewInput
    upsert?: VendorReplyUpsertWithoutReviewInput
    disconnect?: VendorReplyWhereInput | boolean
    delete?: VendorReplyWhereInput | boolean
    connect?: VendorReplyWhereUniqueInput
    update?: XOR<XOR<VendorReplyUpdateToOneWithWhereWithoutReviewInput, VendorReplyUpdateWithoutReviewInput>, VendorReplyUncheckedUpdateWithoutReviewInput>
  }

  export type ReviewVoteUncheckedUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewVoteCreateWithoutReviewInput, ReviewVoteUncheckedCreateWithoutReviewInput> | ReviewVoteCreateWithoutReviewInput[] | ReviewVoteUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewVoteCreateOrConnectWithoutReviewInput | ReviewVoteCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewVoteUpsertWithWhereUniqueWithoutReviewInput | ReviewVoteUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewVoteCreateManyReviewInputEnvelope
    set?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    disconnect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    delete?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    connect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    update?: ReviewVoteUpdateWithWhereUniqueWithoutReviewInput | ReviewVoteUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewVoteUpdateManyWithWhereWithoutReviewInput | ReviewVoteUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewVoteScalarWhereInput | ReviewVoteScalarWhereInput[]
  }

  export type ReviewReportUncheckedUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewReportCreateWithoutReviewInput, ReviewReportUncheckedCreateWithoutReviewInput> | ReviewReportCreateWithoutReviewInput[] | ReviewReportUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewReportCreateOrConnectWithoutReviewInput | ReviewReportCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewReportUpsertWithWhereUniqueWithoutReviewInput | ReviewReportUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewReportCreateManyReviewInputEnvelope
    set?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
    disconnect?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
    delete?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
    connect?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
    update?: ReviewReportUpdateWithWhereUniqueWithoutReviewInput | ReviewReportUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewReportUpdateManyWithWhereWithoutReviewInput | ReviewReportUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewReportScalarWhereInput | ReviewReportScalarWhereInput[]
  }

  export type ProductReviewCreateNestedOneWithoutReplyInput = {
    create?: XOR<ProductReviewCreateWithoutReplyInput, ProductReviewUncheckedCreateWithoutReplyInput>
    connectOrCreate?: ProductReviewCreateOrConnectWithoutReplyInput
    connect?: ProductReviewWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVendorRepliesSentInput = {
    create?: XOR<UserCreateWithoutVendorRepliesSentInput, UserUncheckedCreateWithoutVendorRepliesSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutVendorRepliesSentInput
    connect?: UserWhereUniqueInput
  }

  export type ProductReviewUpdateOneRequiredWithoutReplyNestedInput = {
    create?: XOR<ProductReviewCreateWithoutReplyInput, ProductReviewUncheckedCreateWithoutReplyInput>
    connectOrCreate?: ProductReviewCreateOrConnectWithoutReplyInput
    upsert?: ProductReviewUpsertWithoutReplyInput
    connect?: ProductReviewWhereUniqueInput
    update?: XOR<XOR<ProductReviewUpdateToOneWithWhereWithoutReplyInput, ProductReviewUpdateWithoutReplyInput>, ProductReviewUncheckedUpdateWithoutReplyInput>
  }

  export type UserUpdateOneRequiredWithoutVendorRepliesSentNestedInput = {
    create?: XOR<UserCreateWithoutVendorRepliesSentInput, UserUncheckedCreateWithoutVendorRepliesSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutVendorRepliesSentInput
    upsert?: UserUpsertWithoutVendorRepliesSentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVendorRepliesSentInput, UserUpdateWithoutVendorRepliesSentInput>, UserUncheckedUpdateWithoutVendorRepliesSentInput>
  }

  export type ProductReviewCreateNestedOneWithoutVotesInput = {
    create?: XOR<ProductReviewCreateWithoutVotesInput, ProductReviewUncheckedCreateWithoutVotesInput>
    connectOrCreate?: ProductReviewCreateOrConnectWithoutVotesInput
    connect?: ProductReviewWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewVotesInput = {
    create?: XOR<UserCreateWithoutReviewVotesInput, UserUncheckedCreateWithoutReviewVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewVotesInput
    connect?: UserWhereUniqueInput
  }

  export type ProductReviewUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<ProductReviewCreateWithoutVotesInput, ProductReviewUncheckedCreateWithoutVotesInput>
    connectOrCreate?: ProductReviewCreateOrConnectWithoutVotesInput
    upsert?: ProductReviewUpsertWithoutVotesInput
    connect?: ProductReviewWhereUniqueInput
    update?: XOR<XOR<ProductReviewUpdateToOneWithWhereWithoutVotesInput, ProductReviewUpdateWithoutVotesInput>, ProductReviewUncheckedUpdateWithoutVotesInput>
  }

  export type UserUpdateOneRequiredWithoutReviewVotesNestedInput = {
    create?: XOR<UserCreateWithoutReviewVotesInput, UserUncheckedCreateWithoutReviewVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewVotesInput
    upsert?: UserUpsertWithoutReviewVotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewVotesInput, UserUpdateWithoutReviewVotesInput>, UserUncheckedUpdateWithoutReviewVotesInput>
  }

  export type ProductReviewCreateNestedOneWithoutReportsInput = {
    create?: XOR<ProductReviewCreateWithoutReportsInput, ProductReviewUncheckedCreateWithoutReportsInput>
    connectOrCreate?: ProductReviewCreateOrConnectWithoutReportsInput
    connect?: ProductReviewWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewReportsInput = {
    create?: XOR<UserCreateWithoutReviewReportsInput, UserUncheckedCreateWithoutReviewReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewReportsInput
    connect?: UserWhereUniqueInput
  }

  export type ProductReviewUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<ProductReviewCreateWithoutReportsInput, ProductReviewUncheckedCreateWithoutReportsInput>
    connectOrCreate?: ProductReviewCreateOrConnectWithoutReportsInput
    upsert?: ProductReviewUpsertWithoutReportsInput
    connect?: ProductReviewWhereUniqueInput
    update?: XOR<XOR<ProductReviewUpdateToOneWithWhereWithoutReportsInput, ProductReviewUpdateWithoutReportsInput>, ProductReviewUncheckedUpdateWithoutReportsInput>
  }

  export type UserUpdateOneRequiredWithoutReviewReportsNestedInput = {
    create?: XOR<UserCreateWithoutReviewReportsInput, UserUncheckedCreateWithoutReviewReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewReportsInput
    upsert?: UserUpsertWithoutReviewReportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewReportsInput, UserUpdateWithoutReviewReportsInput>, UserUncheckedUpdateWithoutReviewReportsInput>
  }

  export type UserCreateNestedOneWithoutVendorReviewsReceivedInput = {
    create?: XOR<UserCreateWithoutVendorReviewsReceivedInput, UserUncheckedCreateWithoutVendorReviewsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutVendorReviewsReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVendorReviewsGivenInput = {
    create?: XOR<UserCreateWithoutVendorReviewsGivenInput, UserUncheckedCreateWithoutVendorReviewsGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutVendorReviewsGivenInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutVendorReviewsReceivedNestedInput = {
    create?: XOR<UserCreateWithoutVendorReviewsReceivedInput, UserUncheckedCreateWithoutVendorReviewsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutVendorReviewsReceivedInput
    upsert?: UserUpsertWithoutVendorReviewsReceivedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVendorReviewsReceivedInput, UserUpdateWithoutVendorReviewsReceivedInput>, UserUncheckedUpdateWithoutVendorReviewsReceivedInput>
  }

  export type UserUpdateOneRequiredWithoutVendorReviewsGivenNestedInput = {
    create?: XOR<UserCreateWithoutVendorReviewsGivenInput, UserUncheckedCreateWithoutVendorReviewsGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutVendorReviewsGivenInput
    upsert?: UserUpsertWithoutVendorReviewsGivenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVendorReviewsGivenInput, UserUpdateWithoutVendorReviewsGivenInput>, UserUncheckedUpdateWithoutVendorReviewsGivenInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutLoginHistoryInput = {
    create?: XOR<UserCreateWithoutLoginHistoryInput, UserUncheckedCreateWithoutLoginHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutLoginHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLoginHistoryNestedInput = {
    create?: XOR<UserCreateWithoutLoginHistoryInput, UserUncheckedCreateWithoutLoginHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutLoginHistoryInput
    upsert?: UserUpsertWithoutLoginHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLoginHistoryInput, UserUpdateWithoutLoginHistoryInput>, UserUncheckedUpdateWithoutLoginHistoryInput>
  }

  export type UserCreateNestedOneWithoutPasswordResetTokenInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokenInput, UserUncheckedCreateWithoutPasswordResetTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokenInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPasswordResetTokenNestedInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokenInput, UserUncheckedCreateWithoutPasswordResetTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokenInput
    upsert?: UserUpsertWithoutPasswordResetTokenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordResetTokenInput, UserUpdateWithoutPasswordResetTokenInput>, UserUncheckedUpdateWithoutPasswordResetTokenInput>
  }

  export type UserCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentsInput
    connect?: OrderWhereUniqueInput
  }

  export type ReceiptCreateNestedManyWithoutPaymentInput = {
    create?: XOR<ReceiptCreateWithoutPaymentInput, ReceiptUncheckedCreateWithoutPaymentInput> | ReceiptCreateWithoutPaymentInput[] | ReceiptUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: ReceiptCreateOrConnectWithoutPaymentInput | ReceiptCreateOrConnectWithoutPaymentInput[]
    createMany?: ReceiptCreateManyPaymentInputEnvelope
    connect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
  }

  export type ReceiptUncheckedCreateNestedManyWithoutPaymentInput = {
    create?: XOR<ReceiptCreateWithoutPaymentInput, ReceiptUncheckedCreateWithoutPaymentInput> | ReceiptCreateWithoutPaymentInput[] | ReceiptUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: ReceiptCreateOrConnectWithoutPaymentInput | ReceiptCreateOrConnectWithoutPaymentInput[]
    createMany?: ReceiptCreateManyPaymentInputEnvelope
    connect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    upsert?: UserUpsertWithoutPaymentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsInput, UserUpdateWithoutPaymentsInput>, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type OrderUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentsInput
    upsert?: OrderUpsertWithoutPaymentsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutPaymentsInput, OrderUpdateWithoutPaymentsInput>, OrderUncheckedUpdateWithoutPaymentsInput>
  }

  export type ReceiptUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<ReceiptCreateWithoutPaymentInput, ReceiptUncheckedCreateWithoutPaymentInput> | ReceiptCreateWithoutPaymentInput[] | ReceiptUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: ReceiptCreateOrConnectWithoutPaymentInput | ReceiptCreateOrConnectWithoutPaymentInput[]
    upsert?: ReceiptUpsertWithWhereUniqueWithoutPaymentInput | ReceiptUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: ReceiptCreateManyPaymentInputEnvelope
    set?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    disconnect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    delete?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    connect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    update?: ReceiptUpdateWithWhereUniqueWithoutPaymentInput | ReceiptUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: ReceiptUpdateManyWithWhereWithoutPaymentInput | ReceiptUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: ReceiptScalarWhereInput | ReceiptScalarWhereInput[]
  }

  export type ReceiptUncheckedUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<ReceiptCreateWithoutPaymentInput, ReceiptUncheckedCreateWithoutPaymentInput> | ReceiptCreateWithoutPaymentInput[] | ReceiptUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: ReceiptCreateOrConnectWithoutPaymentInput | ReceiptCreateOrConnectWithoutPaymentInput[]
    upsert?: ReceiptUpsertWithWhereUniqueWithoutPaymentInput | ReceiptUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: ReceiptCreateManyPaymentInputEnvelope
    set?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    disconnect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    delete?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    connect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    update?: ReceiptUpdateWithWhereUniqueWithoutPaymentInput | ReceiptUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: ReceiptUpdateManyWithWhereWithoutPaymentInput | ReceiptUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: ReceiptScalarWhereInput | ReceiptScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRefundRequestInput = {
    create?: XOR<UserCreateWithoutRefundRequestInput, UserUncheckedCreateWithoutRefundRequestInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefundRequestInput
    connect?: UserWhereUniqueInput
  }

  export type EnumRefundStatusFieldUpdateOperationsInput = {
    set?: $Enums.RefundStatus
  }

  export type UserUpdateOneRequiredWithoutRefundRequestNestedInput = {
    create?: XOR<UserCreateWithoutRefundRequestInput, UserUncheckedCreateWithoutRefundRequestInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefundRequestInput
    upsert?: UserUpsertWithoutRefundRequestInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefundRequestInput, UserUpdateWithoutRefundRequestInput>, UserUncheckedUpdateWithoutRefundRequestInput>
  }

  export type UserCreateNestedOneWithoutCartsInput = {
    create?: XOR<UserCreateWithoutCartsInput, UserUncheckedCreateWithoutCartsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCartsInput
    connect?: UserWhereUniqueInput
  }

  export type CartItemCreateNestedManyWithoutCartInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type CartItemUncheckedCreateNestedManyWithoutCartInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCartsNestedInput = {
    create?: XOR<UserCreateWithoutCartsInput, UserUncheckedCreateWithoutCartsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCartsInput
    upsert?: UserUpsertWithoutCartsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCartsInput, UserUpdateWithoutCartsInput>, UserUncheckedUpdateWithoutCartsInput>
  }

  export type CartItemUpdateManyWithoutCartNestedInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutCartInput | CartItemUpsertWithWhereUniqueWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutCartInput | CartItemUpdateWithWhereUniqueWithoutCartInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutCartInput | CartItemUpdateManyWithWhereWithoutCartInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type CartItemUncheckedUpdateManyWithoutCartNestedInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutCartInput | CartItemUpsertWithWhereUniqueWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutCartInput | CartItemUpdateWithWhereUniqueWithoutCartInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutCartInput | CartItemUpdateManyWithWhereWithoutCartInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type CartCreateNestedOneWithoutItemsInput = {
    create?: XOR<CartCreateWithoutItemsInput, CartUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CartCreateOrConnectWithoutItemsInput
    connect?: CartWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutCartItemInput = {
    create?: XOR<ProductCreateWithoutCartItemInput, ProductUncheckedCreateWithoutCartItemInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCartItemInput
    connect?: ProductWhereUniqueInput
  }

  export type CartItemOptionCreateNestedManyWithoutCartItemInput = {
    create?: XOR<CartItemOptionCreateWithoutCartItemInput, CartItemOptionUncheckedCreateWithoutCartItemInput> | CartItemOptionCreateWithoutCartItemInput[] | CartItemOptionUncheckedCreateWithoutCartItemInput[]
    connectOrCreate?: CartItemOptionCreateOrConnectWithoutCartItemInput | CartItemOptionCreateOrConnectWithoutCartItemInput[]
    createMany?: CartItemOptionCreateManyCartItemInputEnvelope
    connect?: CartItemOptionWhereUniqueInput | CartItemOptionWhereUniqueInput[]
  }

  export type CartItemOptionUncheckedCreateNestedManyWithoutCartItemInput = {
    create?: XOR<CartItemOptionCreateWithoutCartItemInput, CartItemOptionUncheckedCreateWithoutCartItemInput> | CartItemOptionCreateWithoutCartItemInput[] | CartItemOptionUncheckedCreateWithoutCartItemInput[]
    connectOrCreate?: CartItemOptionCreateOrConnectWithoutCartItemInput | CartItemOptionCreateOrConnectWithoutCartItemInput[]
    createMany?: CartItemOptionCreateManyCartItemInputEnvelope
    connect?: CartItemOptionWhereUniqueInput | CartItemOptionWhereUniqueInput[]
  }

  export type CartUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<CartCreateWithoutItemsInput, CartUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CartCreateOrConnectWithoutItemsInput
    upsert?: CartUpsertWithoutItemsInput
    connect?: CartWhereUniqueInput
    update?: XOR<XOR<CartUpdateToOneWithWhereWithoutItemsInput, CartUpdateWithoutItemsInput>, CartUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutCartItemNestedInput = {
    create?: XOR<ProductCreateWithoutCartItemInput, ProductUncheckedCreateWithoutCartItemInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCartItemInput
    upsert?: ProductUpsertWithoutCartItemInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutCartItemInput, ProductUpdateWithoutCartItemInput>, ProductUncheckedUpdateWithoutCartItemInput>
  }

  export type CartItemOptionUpdateManyWithoutCartItemNestedInput = {
    create?: XOR<CartItemOptionCreateWithoutCartItemInput, CartItemOptionUncheckedCreateWithoutCartItemInput> | CartItemOptionCreateWithoutCartItemInput[] | CartItemOptionUncheckedCreateWithoutCartItemInput[]
    connectOrCreate?: CartItemOptionCreateOrConnectWithoutCartItemInput | CartItemOptionCreateOrConnectWithoutCartItemInput[]
    upsert?: CartItemOptionUpsertWithWhereUniqueWithoutCartItemInput | CartItemOptionUpsertWithWhereUniqueWithoutCartItemInput[]
    createMany?: CartItemOptionCreateManyCartItemInputEnvelope
    set?: CartItemOptionWhereUniqueInput | CartItemOptionWhereUniqueInput[]
    disconnect?: CartItemOptionWhereUniqueInput | CartItemOptionWhereUniqueInput[]
    delete?: CartItemOptionWhereUniqueInput | CartItemOptionWhereUniqueInput[]
    connect?: CartItemOptionWhereUniqueInput | CartItemOptionWhereUniqueInput[]
    update?: CartItemOptionUpdateWithWhereUniqueWithoutCartItemInput | CartItemOptionUpdateWithWhereUniqueWithoutCartItemInput[]
    updateMany?: CartItemOptionUpdateManyWithWhereWithoutCartItemInput | CartItemOptionUpdateManyWithWhereWithoutCartItemInput[]
    deleteMany?: CartItemOptionScalarWhereInput | CartItemOptionScalarWhereInput[]
  }

  export type CartItemOptionUncheckedUpdateManyWithoutCartItemNestedInput = {
    create?: XOR<CartItemOptionCreateWithoutCartItemInput, CartItemOptionUncheckedCreateWithoutCartItemInput> | CartItemOptionCreateWithoutCartItemInput[] | CartItemOptionUncheckedCreateWithoutCartItemInput[]
    connectOrCreate?: CartItemOptionCreateOrConnectWithoutCartItemInput | CartItemOptionCreateOrConnectWithoutCartItemInput[]
    upsert?: CartItemOptionUpsertWithWhereUniqueWithoutCartItemInput | CartItemOptionUpsertWithWhereUniqueWithoutCartItemInput[]
    createMany?: CartItemOptionCreateManyCartItemInputEnvelope
    set?: CartItemOptionWhereUniqueInput | CartItemOptionWhereUniqueInput[]
    disconnect?: CartItemOptionWhereUniqueInput | CartItemOptionWhereUniqueInput[]
    delete?: CartItemOptionWhereUniqueInput | CartItemOptionWhereUniqueInput[]
    connect?: CartItemOptionWhereUniqueInput | CartItemOptionWhereUniqueInput[]
    update?: CartItemOptionUpdateWithWhereUniqueWithoutCartItemInput | CartItemOptionUpdateWithWhereUniqueWithoutCartItemInput[]
    updateMany?: CartItemOptionUpdateManyWithWhereWithoutCartItemInput | CartItemOptionUpdateManyWithWhereWithoutCartItemInput[]
    deleteMany?: CartItemOptionScalarWhereInput | CartItemOptionScalarWhereInput[]
  }

  export type CartItemCreateNestedOneWithoutOptionsInput = {
    create?: XOR<CartItemCreateWithoutOptionsInput, CartItemUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: CartItemCreateOrConnectWithoutOptionsInput
    connect?: CartItemWhereUniqueInput
  }

  export type ProductOptionCreateNestedOneWithoutCartItemOptionInput = {
    create?: XOR<ProductOptionCreateWithoutCartItemOptionInput, ProductOptionUncheckedCreateWithoutCartItemOptionInput>
    connectOrCreate?: ProductOptionCreateOrConnectWithoutCartItemOptionInput
    connect?: ProductOptionWhereUniqueInput
  }

  export type CartItemUpdateOneRequiredWithoutOptionsNestedInput = {
    create?: XOR<CartItemCreateWithoutOptionsInput, CartItemUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: CartItemCreateOrConnectWithoutOptionsInput
    upsert?: CartItemUpsertWithoutOptionsInput
    connect?: CartItemWhereUniqueInput
    update?: XOR<XOR<CartItemUpdateToOneWithWhereWithoutOptionsInput, CartItemUpdateWithoutOptionsInput>, CartItemUncheckedUpdateWithoutOptionsInput>
  }

  export type ProductOptionUpdateOneRequiredWithoutCartItemOptionNestedInput = {
    create?: XOR<ProductOptionCreateWithoutCartItemOptionInput, ProductOptionUncheckedCreateWithoutCartItemOptionInput>
    connectOrCreate?: ProductOptionCreateOrConnectWithoutCartItemOptionInput
    upsert?: ProductOptionUpsertWithoutCartItemOptionInput
    connect?: ProductOptionWhereUniqueInput
    update?: XOR<XOR<ProductOptionUpdateToOneWithWhereWithoutCartItemOptionInput, ProductOptionUpdateWithoutCartItemOptionInput>, ProductOptionUncheckedUpdateWithoutCartItemOptionInput>
  }

  export type UserCreateNestedOneWithoutUserPaymentMethodInput = {
    create?: XOR<UserCreateWithoutUserPaymentMethodInput, UserUncheckedCreateWithoutUserPaymentMethodInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPaymentMethodInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserPaymentMethodNestedInput = {
    create?: XOR<UserCreateWithoutUserPaymentMethodInput, UserUncheckedCreateWithoutUserPaymentMethodInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPaymentMethodInput
    upsert?: UserUpsertWithoutUserPaymentMethodInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserPaymentMethodInput, UserUpdateWithoutUserPaymentMethodInput>, UserUncheckedUpdateWithoutUserPaymentMethodInput>
  }

  export type UserCreateNestedOneWithoutDeliveryPersonInput = {
    create?: XOR<UserCreateWithoutDeliveryPersonInput, UserUncheckedCreateWithoutDeliveryPersonInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeliveryPersonInput
    connect?: UserWhereUniqueInput
  }

  export type DeliveryAssignmentCreateNestedManyWithoutDeliveryPersonInput = {
    create?: XOR<DeliveryAssignmentCreateWithoutDeliveryPersonInput, DeliveryAssignmentUncheckedCreateWithoutDeliveryPersonInput> | DeliveryAssignmentCreateWithoutDeliveryPersonInput[] | DeliveryAssignmentUncheckedCreateWithoutDeliveryPersonInput[]
    connectOrCreate?: DeliveryAssignmentCreateOrConnectWithoutDeliveryPersonInput | DeliveryAssignmentCreateOrConnectWithoutDeliveryPersonInput[]
    createMany?: DeliveryAssignmentCreateManyDeliveryPersonInputEnvelope
    connect?: DeliveryAssignmentWhereUniqueInput | DeliveryAssignmentWhereUniqueInput[]
  }

  export type DeliveryEarningCreateNestedManyWithoutDeliveryPersonInput = {
    create?: XOR<DeliveryEarningCreateWithoutDeliveryPersonInput, DeliveryEarningUncheckedCreateWithoutDeliveryPersonInput> | DeliveryEarningCreateWithoutDeliveryPersonInput[] | DeliveryEarningUncheckedCreateWithoutDeliveryPersonInput[]
    connectOrCreate?: DeliveryEarningCreateOrConnectWithoutDeliveryPersonInput | DeliveryEarningCreateOrConnectWithoutDeliveryPersonInput[]
    createMany?: DeliveryEarningCreateManyDeliveryPersonInputEnvelope
    connect?: DeliveryEarningWhereUniqueInput | DeliveryEarningWhereUniqueInput[]
  }

  export type DriverLocationLogCreateNestedManyWithoutDriverInput = {
    create?: XOR<DriverLocationLogCreateWithoutDriverInput, DriverLocationLogUncheckedCreateWithoutDriverInput> | DriverLocationLogCreateWithoutDriverInput[] | DriverLocationLogUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: DriverLocationLogCreateOrConnectWithoutDriverInput | DriverLocationLogCreateOrConnectWithoutDriverInput[]
    createMany?: DriverLocationLogCreateManyDriverInputEnvelope
    connect?: DriverLocationLogWhereUniqueInput | DriverLocationLogWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutDeliveryInput = {
    create?: XOR<ActivityCreateWithoutDeliveryInput, ActivityUncheckedCreateWithoutDeliveryInput> | ActivityCreateWithoutDeliveryInput[] | ActivityUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutDeliveryInput | ActivityCreateOrConnectWithoutDeliveryInput[]
    createMany?: ActivityCreateManyDeliveryInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type DeliveryAssignmentUncheckedCreateNestedManyWithoutDeliveryPersonInput = {
    create?: XOR<DeliveryAssignmentCreateWithoutDeliveryPersonInput, DeliveryAssignmentUncheckedCreateWithoutDeliveryPersonInput> | DeliveryAssignmentCreateWithoutDeliveryPersonInput[] | DeliveryAssignmentUncheckedCreateWithoutDeliveryPersonInput[]
    connectOrCreate?: DeliveryAssignmentCreateOrConnectWithoutDeliveryPersonInput | DeliveryAssignmentCreateOrConnectWithoutDeliveryPersonInput[]
    createMany?: DeliveryAssignmentCreateManyDeliveryPersonInputEnvelope
    connect?: DeliveryAssignmentWhereUniqueInput | DeliveryAssignmentWhereUniqueInput[]
  }

  export type DeliveryEarningUncheckedCreateNestedManyWithoutDeliveryPersonInput = {
    create?: XOR<DeliveryEarningCreateWithoutDeliveryPersonInput, DeliveryEarningUncheckedCreateWithoutDeliveryPersonInput> | DeliveryEarningCreateWithoutDeliveryPersonInput[] | DeliveryEarningUncheckedCreateWithoutDeliveryPersonInput[]
    connectOrCreate?: DeliveryEarningCreateOrConnectWithoutDeliveryPersonInput | DeliveryEarningCreateOrConnectWithoutDeliveryPersonInput[]
    createMany?: DeliveryEarningCreateManyDeliveryPersonInputEnvelope
    connect?: DeliveryEarningWhereUniqueInput | DeliveryEarningWhereUniqueInput[]
  }

  export type DriverLocationLogUncheckedCreateNestedManyWithoutDriverInput = {
    create?: XOR<DriverLocationLogCreateWithoutDriverInput, DriverLocationLogUncheckedCreateWithoutDriverInput> | DriverLocationLogCreateWithoutDriverInput[] | DriverLocationLogUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: DriverLocationLogCreateOrConnectWithoutDriverInput | DriverLocationLogCreateOrConnectWithoutDriverInput[]
    createMany?: DriverLocationLogCreateManyDriverInputEnvelope
    connect?: DriverLocationLogWhereUniqueInput | DriverLocationLogWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutDeliveryInput = {
    create?: XOR<ActivityCreateWithoutDeliveryInput, ActivityUncheckedCreateWithoutDeliveryInput> | ActivityCreateWithoutDeliveryInput[] | ActivityUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutDeliveryInput | ActivityCreateOrConnectWithoutDeliveryInput[]
    createMany?: ActivityCreateManyDeliveryInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutDeliveryPersonNestedInput = {
    create?: XOR<UserCreateWithoutDeliveryPersonInput, UserUncheckedCreateWithoutDeliveryPersonInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeliveryPersonInput
    upsert?: UserUpsertWithoutDeliveryPersonInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeliveryPersonInput, UserUpdateWithoutDeliveryPersonInput>, UserUncheckedUpdateWithoutDeliveryPersonInput>
  }

  export type DeliveryAssignmentUpdateManyWithoutDeliveryPersonNestedInput = {
    create?: XOR<DeliveryAssignmentCreateWithoutDeliveryPersonInput, DeliveryAssignmentUncheckedCreateWithoutDeliveryPersonInput> | DeliveryAssignmentCreateWithoutDeliveryPersonInput[] | DeliveryAssignmentUncheckedCreateWithoutDeliveryPersonInput[]
    connectOrCreate?: DeliveryAssignmentCreateOrConnectWithoutDeliveryPersonInput | DeliveryAssignmentCreateOrConnectWithoutDeliveryPersonInput[]
    upsert?: DeliveryAssignmentUpsertWithWhereUniqueWithoutDeliveryPersonInput | DeliveryAssignmentUpsertWithWhereUniqueWithoutDeliveryPersonInput[]
    createMany?: DeliveryAssignmentCreateManyDeliveryPersonInputEnvelope
    set?: DeliveryAssignmentWhereUniqueInput | DeliveryAssignmentWhereUniqueInput[]
    disconnect?: DeliveryAssignmentWhereUniqueInput | DeliveryAssignmentWhereUniqueInput[]
    delete?: DeliveryAssignmentWhereUniqueInput | DeliveryAssignmentWhereUniqueInput[]
    connect?: DeliveryAssignmentWhereUniqueInput | DeliveryAssignmentWhereUniqueInput[]
    update?: DeliveryAssignmentUpdateWithWhereUniqueWithoutDeliveryPersonInput | DeliveryAssignmentUpdateWithWhereUniqueWithoutDeliveryPersonInput[]
    updateMany?: DeliveryAssignmentUpdateManyWithWhereWithoutDeliveryPersonInput | DeliveryAssignmentUpdateManyWithWhereWithoutDeliveryPersonInput[]
    deleteMany?: DeliveryAssignmentScalarWhereInput | DeliveryAssignmentScalarWhereInput[]
  }

  export type DeliveryEarningUpdateManyWithoutDeliveryPersonNestedInput = {
    create?: XOR<DeliveryEarningCreateWithoutDeliveryPersonInput, DeliveryEarningUncheckedCreateWithoutDeliveryPersonInput> | DeliveryEarningCreateWithoutDeliveryPersonInput[] | DeliveryEarningUncheckedCreateWithoutDeliveryPersonInput[]
    connectOrCreate?: DeliveryEarningCreateOrConnectWithoutDeliveryPersonInput | DeliveryEarningCreateOrConnectWithoutDeliveryPersonInput[]
    upsert?: DeliveryEarningUpsertWithWhereUniqueWithoutDeliveryPersonInput | DeliveryEarningUpsertWithWhereUniqueWithoutDeliveryPersonInput[]
    createMany?: DeliveryEarningCreateManyDeliveryPersonInputEnvelope
    set?: DeliveryEarningWhereUniqueInput | DeliveryEarningWhereUniqueInput[]
    disconnect?: DeliveryEarningWhereUniqueInput | DeliveryEarningWhereUniqueInput[]
    delete?: DeliveryEarningWhereUniqueInput | DeliveryEarningWhereUniqueInput[]
    connect?: DeliveryEarningWhereUniqueInput | DeliveryEarningWhereUniqueInput[]
    update?: DeliveryEarningUpdateWithWhereUniqueWithoutDeliveryPersonInput | DeliveryEarningUpdateWithWhereUniqueWithoutDeliveryPersonInput[]
    updateMany?: DeliveryEarningUpdateManyWithWhereWithoutDeliveryPersonInput | DeliveryEarningUpdateManyWithWhereWithoutDeliveryPersonInput[]
    deleteMany?: DeliveryEarningScalarWhereInput | DeliveryEarningScalarWhereInput[]
  }

  export type DriverLocationLogUpdateManyWithoutDriverNestedInput = {
    create?: XOR<DriverLocationLogCreateWithoutDriverInput, DriverLocationLogUncheckedCreateWithoutDriverInput> | DriverLocationLogCreateWithoutDriverInput[] | DriverLocationLogUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: DriverLocationLogCreateOrConnectWithoutDriverInput | DriverLocationLogCreateOrConnectWithoutDriverInput[]
    upsert?: DriverLocationLogUpsertWithWhereUniqueWithoutDriverInput | DriverLocationLogUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: DriverLocationLogCreateManyDriverInputEnvelope
    set?: DriverLocationLogWhereUniqueInput | DriverLocationLogWhereUniqueInput[]
    disconnect?: DriverLocationLogWhereUniqueInput | DriverLocationLogWhereUniqueInput[]
    delete?: DriverLocationLogWhereUniqueInput | DriverLocationLogWhereUniqueInput[]
    connect?: DriverLocationLogWhereUniqueInput | DriverLocationLogWhereUniqueInput[]
    update?: DriverLocationLogUpdateWithWhereUniqueWithoutDriverInput | DriverLocationLogUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: DriverLocationLogUpdateManyWithWhereWithoutDriverInput | DriverLocationLogUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: DriverLocationLogScalarWhereInput | DriverLocationLogScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutDeliveryNestedInput = {
    create?: XOR<ActivityCreateWithoutDeliveryInput, ActivityUncheckedCreateWithoutDeliveryInput> | ActivityCreateWithoutDeliveryInput[] | ActivityUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutDeliveryInput | ActivityCreateOrConnectWithoutDeliveryInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutDeliveryInput | ActivityUpsertWithWhereUniqueWithoutDeliveryInput[]
    createMany?: ActivityCreateManyDeliveryInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutDeliveryInput | ActivityUpdateWithWhereUniqueWithoutDeliveryInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutDeliveryInput | ActivityUpdateManyWithWhereWithoutDeliveryInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type DeliveryAssignmentUncheckedUpdateManyWithoutDeliveryPersonNestedInput = {
    create?: XOR<DeliveryAssignmentCreateWithoutDeliveryPersonInput, DeliveryAssignmentUncheckedCreateWithoutDeliveryPersonInput> | DeliveryAssignmentCreateWithoutDeliveryPersonInput[] | DeliveryAssignmentUncheckedCreateWithoutDeliveryPersonInput[]
    connectOrCreate?: DeliveryAssignmentCreateOrConnectWithoutDeliveryPersonInput | DeliveryAssignmentCreateOrConnectWithoutDeliveryPersonInput[]
    upsert?: DeliveryAssignmentUpsertWithWhereUniqueWithoutDeliveryPersonInput | DeliveryAssignmentUpsertWithWhereUniqueWithoutDeliveryPersonInput[]
    createMany?: DeliveryAssignmentCreateManyDeliveryPersonInputEnvelope
    set?: DeliveryAssignmentWhereUniqueInput | DeliveryAssignmentWhereUniqueInput[]
    disconnect?: DeliveryAssignmentWhereUniqueInput | DeliveryAssignmentWhereUniqueInput[]
    delete?: DeliveryAssignmentWhereUniqueInput | DeliveryAssignmentWhereUniqueInput[]
    connect?: DeliveryAssignmentWhereUniqueInput | DeliveryAssignmentWhereUniqueInput[]
    update?: DeliveryAssignmentUpdateWithWhereUniqueWithoutDeliveryPersonInput | DeliveryAssignmentUpdateWithWhereUniqueWithoutDeliveryPersonInput[]
    updateMany?: DeliveryAssignmentUpdateManyWithWhereWithoutDeliveryPersonInput | DeliveryAssignmentUpdateManyWithWhereWithoutDeliveryPersonInput[]
    deleteMany?: DeliveryAssignmentScalarWhereInput | DeliveryAssignmentScalarWhereInput[]
  }

  export type DeliveryEarningUncheckedUpdateManyWithoutDeliveryPersonNestedInput = {
    create?: XOR<DeliveryEarningCreateWithoutDeliveryPersonInput, DeliveryEarningUncheckedCreateWithoutDeliveryPersonInput> | DeliveryEarningCreateWithoutDeliveryPersonInput[] | DeliveryEarningUncheckedCreateWithoutDeliveryPersonInput[]
    connectOrCreate?: DeliveryEarningCreateOrConnectWithoutDeliveryPersonInput | DeliveryEarningCreateOrConnectWithoutDeliveryPersonInput[]
    upsert?: DeliveryEarningUpsertWithWhereUniqueWithoutDeliveryPersonInput | DeliveryEarningUpsertWithWhereUniqueWithoutDeliveryPersonInput[]
    createMany?: DeliveryEarningCreateManyDeliveryPersonInputEnvelope
    set?: DeliveryEarningWhereUniqueInput | DeliveryEarningWhereUniqueInput[]
    disconnect?: DeliveryEarningWhereUniqueInput | DeliveryEarningWhereUniqueInput[]
    delete?: DeliveryEarningWhereUniqueInput | DeliveryEarningWhereUniqueInput[]
    connect?: DeliveryEarningWhereUniqueInput | DeliveryEarningWhereUniqueInput[]
    update?: DeliveryEarningUpdateWithWhereUniqueWithoutDeliveryPersonInput | DeliveryEarningUpdateWithWhereUniqueWithoutDeliveryPersonInput[]
    updateMany?: DeliveryEarningUpdateManyWithWhereWithoutDeliveryPersonInput | DeliveryEarningUpdateManyWithWhereWithoutDeliveryPersonInput[]
    deleteMany?: DeliveryEarningScalarWhereInput | DeliveryEarningScalarWhereInput[]
  }

  export type DriverLocationLogUncheckedUpdateManyWithoutDriverNestedInput = {
    create?: XOR<DriverLocationLogCreateWithoutDriverInput, DriverLocationLogUncheckedCreateWithoutDriverInput> | DriverLocationLogCreateWithoutDriverInput[] | DriverLocationLogUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: DriverLocationLogCreateOrConnectWithoutDriverInput | DriverLocationLogCreateOrConnectWithoutDriverInput[]
    upsert?: DriverLocationLogUpsertWithWhereUniqueWithoutDriverInput | DriverLocationLogUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: DriverLocationLogCreateManyDriverInputEnvelope
    set?: DriverLocationLogWhereUniqueInput | DriverLocationLogWhereUniqueInput[]
    disconnect?: DriverLocationLogWhereUniqueInput | DriverLocationLogWhereUniqueInput[]
    delete?: DriverLocationLogWhereUniqueInput | DriverLocationLogWhereUniqueInput[]
    connect?: DriverLocationLogWhereUniqueInput | DriverLocationLogWhereUniqueInput[]
    update?: DriverLocationLogUpdateWithWhereUniqueWithoutDriverInput | DriverLocationLogUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: DriverLocationLogUpdateManyWithWhereWithoutDriverInput | DriverLocationLogUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: DriverLocationLogScalarWhereInput | DriverLocationLogScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutDeliveryNestedInput = {
    create?: XOR<ActivityCreateWithoutDeliveryInput, ActivityUncheckedCreateWithoutDeliveryInput> | ActivityCreateWithoutDeliveryInput[] | ActivityUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutDeliveryInput | ActivityCreateOrConnectWithoutDeliveryInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutDeliveryInput | ActivityUpsertWithWhereUniqueWithoutDeliveryInput[]
    createMany?: ActivityCreateManyDeliveryInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutDeliveryInput | ActivityUpdateWithWhereUniqueWithoutDeliveryInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutDeliveryInput | ActivityUpdateManyWithWhereWithoutDeliveryInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<OrderCreateWithoutAssignmentsInput, OrderUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutAssignmentsInput
    connect?: OrderWhereUniqueInput
  }

  export type DeliveryPersonCreateNestedOneWithoutAssignedOrdersInput = {
    create?: XOR<DeliveryPersonCreateWithoutAssignedOrdersInput, DeliveryPersonUncheckedCreateWithoutAssignedOrdersInput>
    connectOrCreate?: DeliveryPersonCreateOrConnectWithoutAssignedOrdersInput
    connect?: DeliveryPersonWhereUniqueInput
  }

  export type EnumDeliveryStatusFieldUpdateOperationsInput = {
    set?: $Enums.DeliveryStatus
  }

  export type OrderUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<OrderCreateWithoutAssignmentsInput, OrderUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutAssignmentsInput
    upsert?: OrderUpsertWithoutAssignmentsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutAssignmentsInput, OrderUpdateWithoutAssignmentsInput>, OrderUncheckedUpdateWithoutAssignmentsInput>
  }

  export type DeliveryPersonUpdateOneRequiredWithoutAssignedOrdersNestedInput = {
    create?: XOR<DeliveryPersonCreateWithoutAssignedOrdersInput, DeliveryPersonUncheckedCreateWithoutAssignedOrdersInput>
    connectOrCreate?: DeliveryPersonCreateOrConnectWithoutAssignedOrdersInput
    upsert?: DeliveryPersonUpsertWithoutAssignedOrdersInput
    connect?: DeliveryPersonWhereUniqueInput
    update?: XOR<XOR<DeliveryPersonUpdateToOneWithWhereWithoutAssignedOrdersInput, DeliveryPersonUpdateWithoutAssignedOrdersInput>, DeliveryPersonUncheckedUpdateWithoutAssignedOrdersInput>
  }

  export type DeliveryPersonCreateNestedOneWithoutEarningsInput = {
    create?: XOR<DeliveryPersonCreateWithoutEarningsInput, DeliveryPersonUncheckedCreateWithoutEarningsInput>
    connectOrCreate?: DeliveryPersonCreateOrConnectWithoutEarningsInput
    connect?: DeliveryPersonWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutEarningsInput = {
    create?: XOR<OrderCreateWithoutEarningsInput, OrderUncheckedCreateWithoutEarningsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutEarningsInput
    connect?: OrderWhereUniqueInput
  }

  export type DeliveryPersonUpdateOneRequiredWithoutEarningsNestedInput = {
    create?: XOR<DeliveryPersonCreateWithoutEarningsInput, DeliveryPersonUncheckedCreateWithoutEarningsInput>
    connectOrCreate?: DeliveryPersonCreateOrConnectWithoutEarningsInput
    upsert?: DeliveryPersonUpsertWithoutEarningsInput
    connect?: DeliveryPersonWhereUniqueInput
    update?: XOR<XOR<DeliveryPersonUpdateToOneWithWhereWithoutEarningsInput, DeliveryPersonUpdateWithoutEarningsInput>, DeliveryPersonUncheckedUpdateWithoutEarningsInput>
  }

  export type OrderUpdateOneRequiredWithoutEarningsNestedInput = {
    create?: XOR<OrderCreateWithoutEarningsInput, OrderUncheckedCreateWithoutEarningsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutEarningsInput
    upsert?: OrderUpsertWithoutEarningsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutEarningsInput, OrderUpdateWithoutEarningsInput>, OrderUncheckedUpdateWithoutEarningsInput>
  }

  export type DeliveryPersonCreateNestedOneWithoutDriverLocationLogInput = {
    create?: XOR<DeliveryPersonCreateWithoutDriverLocationLogInput, DeliveryPersonUncheckedCreateWithoutDriverLocationLogInput>
    connectOrCreate?: DeliveryPersonCreateOrConnectWithoutDriverLocationLogInput
    connect?: DeliveryPersonWhereUniqueInput
  }

  export type DeliveryPersonUpdateOneRequiredWithoutDriverLocationLogNestedInput = {
    create?: XOR<DeliveryPersonCreateWithoutDriverLocationLogInput, DeliveryPersonUncheckedCreateWithoutDriverLocationLogInput>
    connectOrCreate?: DeliveryPersonCreateOrConnectWithoutDriverLocationLogInput
    upsert?: DeliveryPersonUpsertWithoutDriverLocationLogInput
    connect?: DeliveryPersonWhereUniqueInput
    update?: XOR<XOR<DeliveryPersonUpdateToOneWithWhereWithoutDriverLocationLogInput, DeliveryPersonUpdateWithoutDriverLocationLogInput>, DeliveryPersonUncheckedUpdateWithoutDriverLocationLogInput>
  }

  export type OrderCreateNestedOneWithoutActivityInput = {
    create?: XOR<OrderCreateWithoutActivityInput, OrderUncheckedCreateWithoutActivityInput>
    connectOrCreate?: OrderCreateOrConnectWithoutActivityInput
    connect?: OrderWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVendorActivitiesInput = {
    create?: XOR<UserCreateWithoutVendorActivitiesInput, UserUncheckedCreateWithoutVendorActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutVendorActivitiesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCustomerActivitiesInput = {
    create?: XOR<UserCreateWithoutCustomerActivitiesInput, UserUncheckedCreateWithoutCustomerActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomerActivitiesInput
    connect?: UserWhereUniqueInput
  }

  export type DeliveryPersonCreateNestedOneWithoutActivityInput = {
    create?: XOR<DeliveryPersonCreateWithoutActivityInput, DeliveryPersonUncheckedCreateWithoutActivityInput>
    connectOrCreate?: DeliveryPersonCreateOrConnectWithoutActivityInput
    connect?: DeliveryPersonWhereUniqueInput
  }

  export type EnumActivityTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActivityType
  }

  export type OrderUpdateOneWithoutActivityNestedInput = {
    create?: XOR<OrderCreateWithoutActivityInput, OrderUncheckedCreateWithoutActivityInput>
    connectOrCreate?: OrderCreateOrConnectWithoutActivityInput
    upsert?: OrderUpsertWithoutActivityInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutActivityInput, OrderUpdateWithoutActivityInput>, OrderUncheckedUpdateWithoutActivityInput>
  }

  export type UserUpdateOneWithoutVendorActivitiesNestedInput = {
    create?: XOR<UserCreateWithoutVendorActivitiesInput, UserUncheckedCreateWithoutVendorActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutVendorActivitiesInput
    upsert?: UserUpsertWithoutVendorActivitiesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVendorActivitiesInput, UserUpdateWithoutVendorActivitiesInput>, UserUncheckedUpdateWithoutVendorActivitiesInput>
  }

  export type UserUpdateOneWithoutCustomerActivitiesNestedInput = {
    create?: XOR<UserCreateWithoutCustomerActivitiesInput, UserUncheckedCreateWithoutCustomerActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomerActivitiesInput
    upsert?: UserUpsertWithoutCustomerActivitiesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCustomerActivitiesInput, UserUpdateWithoutCustomerActivitiesInput>, UserUncheckedUpdateWithoutCustomerActivitiesInput>
  }

  export type DeliveryPersonUpdateOneWithoutActivityNestedInput = {
    create?: XOR<DeliveryPersonCreateWithoutActivityInput, DeliveryPersonUncheckedCreateWithoutActivityInput>
    connectOrCreate?: DeliveryPersonCreateOrConnectWithoutActivityInput
    upsert?: DeliveryPersonUpsertWithoutActivityInput
    disconnect?: DeliveryPersonWhereInput | boolean
    delete?: DeliveryPersonWhereInput | boolean
    connect?: DeliveryPersonWhereUniqueInput
    update?: XOR<XOR<DeliveryPersonUpdateToOneWithWhereWithoutActivityInput, DeliveryPersonUpdateWithoutActivityInput>, DeliveryPersonUncheckedUpdateWithoutActivityInput>
  }

  export type DeliveryBroadcastCreatedriverIdsInput = {
    set: string[]
  }

  export type OrderCreateNestedOneWithoutDeliveryBroadcastInput = {
    create?: XOR<OrderCreateWithoutDeliveryBroadcastInput, OrderUncheckedCreateWithoutDeliveryBroadcastInput>
    connectOrCreate?: OrderCreateOrConnectWithoutDeliveryBroadcastInput
    connect?: OrderWhereUniqueInput
  }

  export type DeliveryBroadcastUpdatedriverIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OrderUpdateOneRequiredWithoutDeliveryBroadcastNestedInput = {
    create?: XOR<OrderCreateWithoutDeliveryBroadcastInput, OrderUncheckedCreateWithoutDeliveryBroadcastInput>
    connectOrCreate?: OrderCreateOrConnectWithoutDeliveryBroadcastInput
    upsert?: OrderUpsertWithoutDeliveryBroadcastInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutDeliveryBroadcastInput, OrderUpdateWithoutDeliveryBroadcastInput>, OrderUncheckedUpdateWithoutDeliveryBroadcastInput>
  }

  export type PaymentCreateNestedOneWithoutReceiptInput = {
    create?: XOR<PaymentCreateWithoutReceiptInput, PaymentUncheckedCreateWithoutReceiptInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutReceiptInput
    connect?: PaymentWhereUniqueInput
  }

  export type PaymentUpdateOneRequiredWithoutReceiptNestedInput = {
    create?: XOR<PaymentCreateWithoutReceiptInput, PaymentUncheckedCreateWithoutReceiptInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutReceiptInput
    upsert?: PaymentUpsertWithoutReceiptInput
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutReceiptInput, PaymentUpdateWithoutReceiptInput>, PaymentUncheckedUpdateWithoutReceiptInput>
  }

  export type UserCreateNestedOneWithoutFollowersInput = {
    create?: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFollowingInput = {
    create?: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFollowersNestedInput = {
    create?: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowersInput
    upsert?: UserUpsertWithoutFollowersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFollowersInput, UserUpdateWithoutFollowersInput>, UserUncheckedUpdateWithoutFollowersInput>
  }

  export type UserUpdateOneRequiredWithoutFollowingNestedInput = {
    create?: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingInput
    upsert?: UserUpsertWithoutFollowingInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFollowingInput, UserUpdateWithoutFollowingInput>, UserUncheckedUpdateWithoutFollowingInput>
  }

  export type UserCreateNestedOneWithoutSpecialRequestsMadeInput = {
    create?: XOR<UserCreateWithoutSpecialRequestsMadeInput, UserUncheckedCreateWithoutSpecialRequestsMadeInput>
    connectOrCreate?: UserCreateOrConnectWithoutSpecialRequestsMadeInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSpecialRequestsReceivedInput = {
    create?: XOR<UserCreateWithoutSpecialRequestsReceivedInput, UserUncheckedCreateWithoutSpecialRequestsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutSpecialRequestsReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutSpecialRequestsInput = {
    create?: XOR<ProductCreateWithoutSpecialRequestsInput, ProductUncheckedCreateWithoutSpecialRequestsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSpecialRequestsInput
    connect?: ProductWhereUniqueInput
  }

  export type SpecialOrderOfferCreateNestedManyWithoutRequestInput = {
    create?: XOR<SpecialOrderOfferCreateWithoutRequestInput, SpecialOrderOfferUncheckedCreateWithoutRequestInput> | SpecialOrderOfferCreateWithoutRequestInput[] | SpecialOrderOfferUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: SpecialOrderOfferCreateOrConnectWithoutRequestInput | SpecialOrderOfferCreateOrConnectWithoutRequestInput[]
    createMany?: SpecialOrderOfferCreateManyRequestInputEnvelope
    connect?: SpecialOrderOfferWhereUniqueInput | SpecialOrderOfferWhereUniqueInput[]
  }

  export type SpecialOrderOfferUncheckedCreateNestedManyWithoutRequestInput = {
    create?: XOR<SpecialOrderOfferCreateWithoutRequestInput, SpecialOrderOfferUncheckedCreateWithoutRequestInput> | SpecialOrderOfferCreateWithoutRequestInput[] | SpecialOrderOfferUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: SpecialOrderOfferCreateOrConnectWithoutRequestInput | SpecialOrderOfferCreateOrConnectWithoutRequestInput[]
    createMany?: SpecialOrderOfferCreateManyRequestInputEnvelope
    connect?: SpecialOrderOfferWhereUniqueInput | SpecialOrderOfferWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutSpecialRequestsMadeNestedInput = {
    create?: XOR<UserCreateWithoutSpecialRequestsMadeInput, UserUncheckedCreateWithoutSpecialRequestsMadeInput>
    connectOrCreate?: UserCreateOrConnectWithoutSpecialRequestsMadeInput
    upsert?: UserUpsertWithoutSpecialRequestsMadeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSpecialRequestsMadeInput, UserUpdateWithoutSpecialRequestsMadeInput>, UserUncheckedUpdateWithoutSpecialRequestsMadeInput>
  }

  export type UserUpdateOneWithoutSpecialRequestsReceivedNestedInput = {
    create?: XOR<UserCreateWithoutSpecialRequestsReceivedInput, UserUncheckedCreateWithoutSpecialRequestsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutSpecialRequestsReceivedInput
    upsert?: UserUpsertWithoutSpecialRequestsReceivedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSpecialRequestsReceivedInput, UserUpdateWithoutSpecialRequestsReceivedInput>, UserUncheckedUpdateWithoutSpecialRequestsReceivedInput>
  }

  export type ProductUpdateOneRequiredWithoutSpecialRequestsNestedInput = {
    create?: XOR<ProductCreateWithoutSpecialRequestsInput, ProductUncheckedCreateWithoutSpecialRequestsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSpecialRequestsInput
    upsert?: ProductUpsertWithoutSpecialRequestsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutSpecialRequestsInput, ProductUpdateWithoutSpecialRequestsInput>, ProductUncheckedUpdateWithoutSpecialRequestsInput>
  }

  export type SpecialOrderOfferUpdateManyWithoutRequestNestedInput = {
    create?: XOR<SpecialOrderOfferCreateWithoutRequestInput, SpecialOrderOfferUncheckedCreateWithoutRequestInput> | SpecialOrderOfferCreateWithoutRequestInput[] | SpecialOrderOfferUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: SpecialOrderOfferCreateOrConnectWithoutRequestInput | SpecialOrderOfferCreateOrConnectWithoutRequestInput[]
    upsert?: SpecialOrderOfferUpsertWithWhereUniqueWithoutRequestInput | SpecialOrderOfferUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: SpecialOrderOfferCreateManyRequestInputEnvelope
    set?: SpecialOrderOfferWhereUniqueInput | SpecialOrderOfferWhereUniqueInput[]
    disconnect?: SpecialOrderOfferWhereUniqueInput | SpecialOrderOfferWhereUniqueInput[]
    delete?: SpecialOrderOfferWhereUniqueInput | SpecialOrderOfferWhereUniqueInput[]
    connect?: SpecialOrderOfferWhereUniqueInput | SpecialOrderOfferWhereUniqueInput[]
    update?: SpecialOrderOfferUpdateWithWhereUniqueWithoutRequestInput | SpecialOrderOfferUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: SpecialOrderOfferUpdateManyWithWhereWithoutRequestInput | SpecialOrderOfferUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: SpecialOrderOfferScalarWhereInput | SpecialOrderOfferScalarWhereInput[]
  }

  export type SpecialOrderOfferUncheckedUpdateManyWithoutRequestNestedInput = {
    create?: XOR<SpecialOrderOfferCreateWithoutRequestInput, SpecialOrderOfferUncheckedCreateWithoutRequestInput> | SpecialOrderOfferCreateWithoutRequestInput[] | SpecialOrderOfferUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: SpecialOrderOfferCreateOrConnectWithoutRequestInput | SpecialOrderOfferCreateOrConnectWithoutRequestInput[]
    upsert?: SpecialOrderOfferUpsertWithWhereUniqueWithoutRequestInput | SpecialOrderOfferUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: SpecialOrderOfferCreateManyRequestInputEnvelope
    set?: SpecialOrderOfferWhereUniqueInput | SpecialOrderOfferWhereUniqueInput[]
    disconnect?: SpecialOrderOfferWhereUniqueInput | SpecialOrderOfferWhereUniqueInput[]
    delete?: SpecialOrderOfferWhereUniqueInput | SpecialOrderOfferWhereUniqueInput[]
    connect?: SpecialOrderOfferWhereUniqueInput | SpecialOrderOfferWhereUniqueInput[]
    update?: SpecialOrderOfferUpdateWithWhereUniqueWithoutRequestInput | SpecialOrderOfferUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: SpecialOrderOfferUpdateManyWithWhereWithoutRequestInput | SpecialOrderOfferUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: SpecialOrderOfferScalarWhereInput | SpecialOrderOfferScalarWhereInput[]
  }

  export type SpecialOrderRequestCreateNestedOneWithoutOffersInput = {
    create?: XOR<SpecialOrderRequestCreateWithoutOffersInput, SpecialOrderRequestUncheckedCreateWithoutOffersInput>
    connectOrCreate?: SpecialOrderRequestCreateOrConnectWithoutOffersInput
    connect?: SpecialOrderRequestWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSpecialOffersSentInput = {
    create?: XOR<UserCreateWithoutSpecialOffersSentInput, UserUncheckedCreateWithoutSpecialOffersSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutSpecialOffersSentInput
    connect?: UserWhereUniqueInput
  }

  export type SpecialOrderRequestUpdateOneRequiredWithoutOffersNestedInput = {
    create?: XOR<SpecialOrderRequestCreateWithoutOffersInput, SpecialOrderRequestUncheckedCreateWithoutOffersInput>
    connectOrCreate?: SpecialOrderRequestCreateOrConnectWithoutOffersInput
    upsert?: SpecialOrderRequestUpsertWithoutOffersInput
    connect?: SpecialOrderRequestWhereUniqueInput
    update?: XOR<XOR<SpecialOrderRequestUpdateToOneWithWhereWithoutOffersInput, SpecialOrderRequestUpdateWithoutOffersInput>, SpecialOrderRequestUncheckedUpdateWithoutOffersInput>
  }

  export type UserUpdateOneRequiredWithoutSpecialOffersSentNestedInput = {
    create?: XOR<UserCreateWithoutSpecialOffersSentInput, UserUncheckedCreateWithoutSpecialOffersSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutSpecialOffersSentInput
    upsert?: UserUpsertWithoutSpecialOffersSentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSpecialOffersSentInput, UserUpdateWithoutSpecialOffersSentInput>, UserUncheckedUpdateWithoutSpecialOffersSentInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableFilter<$PrismaModel> | $Enums.Role | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.Role | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumRoleNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryFilter<$PrismaModel> | $Enums.Category
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryWithAggregatesFilter<$PrismaModel> | $Enums.Category
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategoryFilter<$PrismaModel>
    _max?: NestedEnumCategoryFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumPaymentStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentStatusNullableFilter<$PrismaModel> | $Enums.PaymentStatus | null
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumRefundStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundStatus | EnumRefundStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRefundStatusFilter<$PrismaModel> | $Enums.RefundStatus
  }

  export type NestedEnumRefundStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundStatus | EnumRefundStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRefundStatusWithAggregatesFilter<$PrismaModel> | $Enums.RefundStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRefundStatusFilter<$PrismaModel>
    _max?: NestedEnumRefundStatusFilter<$PrismaModel>
  }

  export type NestedEnumDeliveryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryStatus | EnumDeliveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryStatusFilter<$PrismaModel> | $Enums.DeliveryStatus
  }

  export type NestedEnumDeliveryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryStatus | EnumDeliveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeliveryStatusFilter<$PrismaModel>
    _max?: NestedEnumDeliveryStatusFilter<$PrismaModel>
  }

  export type NestedEnumActivityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeFilter<$PrismaModel> | $Enums.ActivityType
  }

  export type NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ProductCreateWithoutVendorInput = {
    id?: string
    name: string
    description: string
    price: number
    archived?: boolean
    category: $Enums.Category
    images?: ProductCreateimagesInput | string[]
    thumbnail?: string | null
    video?: ProductCreatevideoInput | string[]
    averageRating?: number | null
    reviewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    totalViews?: number
    popularityScore?: number
    popularityUpdatedAt?: Date | string | null
    popularityPercent?: number
    isNew?: boolean
    isLive?: boolean
    liveUntil?: Date | string | null
    reviews?: ProductReviewCreateNestedManyWithoutProductInput
    orders?: OrderCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    options?: ProductOptionCreateNestedManyWithoutProductInput
    CartItem?: CartItemCreateNestedManyWithoutProductInput
    specialRequests?: SpecialOrderRequestCreateNestedManyWithoutProductInput
    productSchedule?: ProductScheduleCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutVendorInput = {
    id?: string
    name: string
    description: string
    price: number
    archived?: boolean
    category: $Enums.Category
    images?: ProductCreateimagesInput | string[]
    thumbnail?: string | null
    video?: ProductCreatevideoInput | string[]
    averageRating?: number | null
    reviewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    totalViews?: number
    popularityScore?: number
    popularityUpdatedAt?: Date | string | null
    popularityPercent?: number
    isNew?: boolean
    isLive?: boolean
    liveUntil?: Date | string | null
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    orders?: OrderUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    options?: ProductOptionUncheckedCreateNestedManyWithoutProductInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductInput
    specialRequests?: SpecialOrderRequestUncheckedCreateNestedManyWithoutProductInput
    productSchedule?: ProductScheduleUncheckedCreateNestedOneWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutVendorInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutVendorInput, ProductUncheckedCreateWithoutVendorInput>
  }

  export type ProductCreateManyVendorInputEnvelope = {
    data: ProductCreateManyVendorInput | ProductCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type VendorReviewCreateWithoutVendorInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    customer: UserCreateNestedOneWithoutVendorReviewsGivenInput
  }

  export type VendorReviewUncheckedCreateWithoutVendorInput = {
    id?: string
    customerId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type VendorReviewCreateOrConnectWithoutVendorInput = {
    where: VendorReviewWhereUniqueInput
    create: XOR<VendorReviewCreateWithoutVendorInput, VendorReviewUncheckedCreateWithoutVendorInput>
  }

  export type VendorReviewCreateManyVendorInputEnvelope = {
    data: VendorReviewCreateManyVendorInput | VendorReviewCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type VendorReviewCreateWithoutCustomerInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    vendor: UserCreateNestedOneWithoutVendorReviewsReceivedInput
  }

  export type VendorReviewUncheckedCreateWithoutCustomerInput = {
    id?: string
    vendorId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type VendorReviewCreateOrConnectWithoutCustomerInput = {
    where: VendorReviewWhereUniqueInput
    create: XOR<VendorReviewCreateWithoutCustomerInput, VendorReviewUncheckedCreateWithoutCustomerInput>
  }

  export type VendorReviewCreateManyCustomerInputEnvelope = {
    data: VendorReviewCreateManyCustomerInput | VendorReviewCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type ProductReviewCreateWithoutCustomerInput = {
    id?: string
    rating: number
    comment?: string | null
    images?: ProductReviewCreateimagesInput | string[]
    createdAt?: Date | string
    verifiedPurchase?: boolean
    product: ProductCreateNestedOneWithoutReviewsInput
    reply?: VendorReplyCreateNestedOneWithoutReviewInput
    votes?: ReviewVoteCreateNestedManyWithoutReviewInput
    reports?: ReviewReportCreateNestedManyWithoutReviewInput
  }

  export type ProductReviewUncheckedCreateWithoutCustomerInput = {
    id?: string
    productId: string
    rating: number
    comment?: string | null
    images?: ProductReviewCreateimagesInput | string[]
    createdAt?: Date | string
    verifiedPurchase?: boolean
    reply?: VendorReplyUncheckedCreateNestedOneWithoutReviewInput
    votes?: ReviewVoteUncheckedCreateNestedManyWithoutReviewInput
    reports?: ReviewReportUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ProductReviewCreateOrConnectWithoutCustomerInput = {
    where: ProductReviewWhereUniqueInput
    create: XOR<ProductReviewCreateWithoutCustomerInput, ProductReviewUncheckedCreateWithoutCustomerInput>
  }

  export type ProductReviewCreateManyCustomerInputEnvelope = {
    data: ProductReviewCreateManyCustomerInput | ProductReviewCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutCustomerInput = {
    id?: string
    basePrice: number
    extraCharge?: number
    totalPrice: number
    vendorNote?: string | null
    customerApproval?: boolean
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentInitiatedAt?: Date | string | null
    paymentStartedAt?: Date | string | null
    paidAt?: Date | string | null
    paymentStatus?: $Enums.PaymentStatus | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    protectedUntil?: Date | string | null
    paymentGraceMinutes?: number | null
    vendor: UserCreateNestedOneWithoutVendorOrdersInput
    address?: AddressCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    Product?: ProductCreateNestedManyWithoutOrdersInput
    assignments?: DeliveryAssignmentCreateNestedManyWithoutOrderInput
    earnings?: DeliveryEarningCreateNestedManyWithoutOrderInput
    Activity?: ActivityCreateNestedManyWithoutOrderInput
    DeliveryBroadcast?: DeliveryBroadcastCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCustomerInput = {
    id?: string
    vendorId: string
    addressId?: string | null
    basePrice: number
    extraCharge?: number
    totalPrice: number
    vendorNote?: string | null
    customerApproval?: boolean
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentInitiatedAt?: Date | string | null
    paymentStartedAt?: Date | string | null
    paidAt?: Date | string | null
    paymentStatus?: $Enums.PaymentStatus | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    protectedUntil?: Date | string | null
    paymentGraceMinutes?: number | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    Product?: ProductUncheckedCreateNestedManyWithoutOrdersInput
    assignments?: DeliveryAssignmentUncheckedCreateNestedManyWithoutOrderInput
    earnings?: DeliveryEarningUncheckedCreateNestedManyWithoutOrderInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutOrderInput
    DeliveryBroadcast?: DeliveryBroadcastUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderCreateManyCustomerInputEnvelope = {
    data: OrderCreateManyCustomerInput | OrderCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutVendorInput = {
    id?: string
    basePrice: number
    extraCharge?: number
    totalPrice: number
    vendorNote?: string | null
    customerApproval?: boolean
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentInitiatedAt?: Date | string | null
    paymentStartedAt?: Date | string | null
    paidAt?: Date | string | null
    paymentStatus?: $Enums.PaymentStatus | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    protectedUntil?: Date | string | null
    paymentGraceMinutes?: number | null
    customer: UserCreateNestedOneWithoutCustomerOrdersInput
    address?: AddressCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    Product?: ProductCreateNestedManyWithoutOrdersInput
    assignments?: DeliveryAssignmentCreateNestedManyWithoutOrderInput
    earnings?: DeliveryEarningCreateNestedManyWithoutOrderInput
    Activity?: ActivityCreateNestedManyWithoutOrderInput
    DeliveryBroadcast?: DeliveryBroadcastCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutVendorInput = {
    id?: string
    customerId: string
    addressId?: string | null
    basePrice: number
    extraCharge?: number
    totalPrice: number
    vendorNote?: string | null
    customerApproval?: boolean
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentInitiatedAt?: Date | string | null
    paymentStartedAt?: Date | string | null
    paidAt?: Date | string | null
    paymentStatus?: $Enums.PaymentStatus | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    protectedUntil?: Date | string | null
    paymentGraceMinutes?: number | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    Product?: ProductUncheckedCreateNestedManyWithoutOrdersInput
    assignments?: DeliveryAssignmentUncheckedCreateNestedManyWithoutOrderInput
    earnings?: DeliveryEarningUncheckedCreateNestedManyWithoutOrderInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutOrderInput
    DeliveryBroadcast?: DeliveryBroadcastUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutVendorInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutVendorInput, OrderUncheckedCreateWithoutVendorInput>
  }

  export type OrderCreateManyVendorInputEnvelope = {
    data: OrderCreateManyVendorInput | OrderCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type VendorReplyCreateWithoutVendorInput = {
    id?: string
    message: string
    createdAt?: Date | string
    review: ProductReviewCreateNestedOneWithoutReplyInput
  }

  export type VendorReplyUncheckedCreateWithoutVendorInput = {
    id?: string
    reviewId: string
    message: string
    createdAt?: Date | string
  }

  export type VendorReplyCreateOrConnectWithoutVendorInput = {
    where: VendorReplyWhereUniqueInput
    create: XOR<VendorReplyCreateWithoutVendorInput, VendorReplyUncheckedCreateWithoutVendorInput>
  }

  export type VendorReplyCreateManyVendorInputEnvelope = {
    data: VendorReplyCreateManyVendorInput | VendorReplyCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type ReviewVoteCreateWithoutUserInput = {
    id?: string
    isHelpful: boolean
    createdAt?: Date | string
    review: ProductReviewCreateNestedOneWithoutVotesInput
  }

  export type ReviewVoteUncheckedCreateWithoutUserInput = {
    id?: string
    reviewId: string
    isHelpful: boolean
    createdAt?: Date | string
  }

  export type ReviewVoteCreateOrConnectWithoutUserInput = {
    where: ReviewVoteWhereUniqueInput
    create: XOR<ReviewVoteCreateWithoutUserInput, ReviewVoteUncheckedCreateWithoutUserInput>
  }

  export type ReviewVoteCreateManyUserInputEnvelope = {
    data: ReviewVoteCreateManyUserInput | ReviewVoteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewReportCreateWithoutUserInput = {
    id?: string
    reason: string
    createdAt?: Date | string
    review: ProductReviewCreateNestedOneWithoutReportsInput
  }

  export type ReviewReportUncheckedCreateWithoutUserInput = {
    id?: string
    reviewId: string
    reason: string
    createdAt?: Date | string
  }

  export type ReviewReportCreateOrConnectWithoutUserInput = {
    where: ReviewReportWhereUniqueInput
    create: XOR<ReviewReportCreateWithoutUserInput, ReviewReportUncheckedCreateWithoutUserInput>
  }

  export type ReviewReportCreateManyUserInputEnvelope = {
    data: ReviewReportCreateManyUserInput | ReviewReportCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LoginHistoryCreateWithoutUserInput = {
    id?: string
    method: string
    deviceId?: string | null
    location?: string | null
    ip?: string | null
    userAgent?: string | null
    geoCity?: string | null
    geoRegion?: string | null
    geoCountry?: string | null
    createdAt?: Date | string
  }

  export type LoginHistoryUncheckedCreateWithoutUserInput = {
    id?: string
    method: string
    deviceId?: string | null
    location?: string | null
    ip?: string | null
    userAgent?: string | null
    geoCity?: string | null
    geoRegion?: string | null
    geoCountry?: string | null
    createdAt?: Date | string
  }

  export type LoginHistoryCreateOrConnectWithoutUserInput = {
    where: LoginHistoryWhereUniqueInput
    create: XOR<LoginHistoryCreateWithoutUserInput, LoginHistoryUncheckedCreateWithoutUserInput>
  }

  export type LoginHistoryCreateManyUserInputEnvelope = {
    data: LoginHistoryCreateManyUserInput | LoginHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AddressCreateWithoutUserInput = {
    id?: string
    label: string
    street: string
    city: string
    state?: string | null
    country: string
    zipCode?: string | null
    landmark?: string | null
    latitude?: number | null
    longitude?: number | null
    isDefault?: boolean
    createdAt?: Date | string
    orders?: OrderCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutUserInput = {
    id?: string
    label: string
    street: string
    city: string
    state?: string | null
    country: string
    zipCode?: string | null
    landmark?: string | null
    latitude?: number | null
    longitude?: number | null
    isDefault?: boolean
    createdAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressCreateOrConnectWithoutUserInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
  }

  export type AddressCreateManyUserInputEnvelope = {
    data: AddressCreateManyUserInput | AddressCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CartCreateWithoutCustomerInput = {
    id?: string
    basePrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CartItemCreateNestedManyWithoutCartInput
  }

  export type CartUncheckedCreateWithoutCustomerInput = {
    id?: string
    basePrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CartItemUncheckedCreateNestedManyWithoutCartInput
  }

  export type CartCreateOrConnectWithoutCustomerInput = {
    where: CartWhereUniqueInput
    create: XOR<CartCreateWithoutCustomerInput, CartUncheckedCreateWithoutCustomerInput>
  }

  export type CartCreateManyCustomerInputEnvelope = {
    data: CartCreateManyCustomerInput | CartCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type UserPaymentMethodCreateWithoutUserInput = {
    id?: string
    cardToken: string
    last4: string
    brand: string
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPaymentMethodUncheckedCreateWithoutUserInput = {
    id?: string
    cardToken: string
    last4: string
    brand: string
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPaymentMethodCreateOrConnectWithoutUserInput = {
    where: UserPaymentMethodWhereUniqueInput
    create: XOR<UserPaymentMethodCreateWithoutUserInput, UserPaymentMethodUncheckedCreateWithoutUserInput>
  }

  export type UserPaymentMethodCreateManyUserInputEnvelope = {
    data: UserPaymentMethodCreateManyUserInput | UserPaymentMethodCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryPersonCreateWithoutUserInput = {
    id?: string
    vehicleType?: string | null
    licensePlate?: string | null
    status?: string
    rating?: number
    totalDeliveries?: number
    isOnline?: boolean
    latitude?: number | null
    longitude?: number | null
    lastSeenAt?: Date | string | null
    walletBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedOrders?: DeliveryAssignmentCreateNestedManyWithoutDeliveryPersonInput
    earnings?: DeliveryEarningCreateNestedManyWithoutDeliveryPersonInput
    DriverLocationLog?: DriverLocationLogCreateNestedManyWithoutDriverInput
    Activity?: ActivityCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryPersonUncheckedCreateWithoutUserInput = {
    id?: string
    vehicleType?: string | null
    licensePlate?: string | null
    status?: string
    rating?: number
    totalDeliveries?: number
    isOnline?: boolean
    latitude?: number | null
    longitude?: number | null
    lastSeenAt?: Date | string | null
    walletBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedOrders?: DeliveryAssignmentUncheckedCreateNestedManyWithoutDeliveryPersonInput
    earnings?: DeliveryEarningUncheckedCreateNestedManyWithoutDeliveryPersonInput
    DriverLocationLog?: DriverLocationLogUncheckedCreateNestedManyWithoutDriverInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryPersonCreateOrConnectWithoutUserInput = {
    where: DeliveryPersonWhereUniqueInput
    create: XOR<DeliveryPersonCreateWithoutUserInput, DeliveryPersonUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenCreateWithoutUserInput = {
    token: string
    expiresAt: Date | string
  }

  export type PasswordResetTokenUncheckedCreateWithoutUserInput = {
    token: string
    expiresAt: Date | string
  }

  export type PasswordResetTokenCreateOrConnectWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PaymentCreateWithoutUserInput = {
    id?: string
    amount: number
    reference: string
    status: string
    paystackData?: NullableJsonNullValueInput | InputJsonValue
    channel?: string | null
    ipAddress?: string
    userAgent?: string
    deviceId?: string | null
    geoCity?: string | null
    geoCountry?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    order: OrderCreateNestedOneWithoutPaymentsInput
    Receipt?: ReceiptCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutUserInput = {
    id?: string
    orderId: string
    amount: number
    reference: string
    status: string
    paystackData?: NullableJsonNullValueInput | InputJsonValue
    channel?: string | null
    ipAddress?: string
    userAgent?: string
    deviceId?: string | null
    geoCity?: string | null
    geoCountry?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    Receipt?: ReceiptUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutUserInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentCreateManyUserInputEnvelope = {
    data: PaymentCreateManyUserInput | PaymentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RefundRequestCreateWithoutUserInput = {
    id?: string
    paymentRef: string
    reason: string
    status?: $Enums.RefundStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefundRequestUncheckedCreateWithoutUserInput = {
    id?: string
    paymentRef: string
    reason: string
    status?: $Enums.RefundStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefundRequestCreateOrConnectWithoutUserInput = {
    where: RefundRequestWhereUniqueInput
    create: XOR<RefundRequestCreateWithoutUserInput, RefundRequestUncheckedCreateWithoutUserInput>
  }

  export type RefundRequestCreateManyUserInputEnvelope = {
    data: RefundRequestCreateManyUserInput | RefundRequestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutVendorInput = {
    id?: string
    type: $Enums.ActivityType
    title: string
    message: string
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    order?: OrderCreateNestedOneWithoutActivityInput
    customer?: UserCreateNestedOneWithoutCustomerActivitiesInput
    delivery?: DeliveryPersonCreateNestedOneWithoutActivityInput
  }

  export type ActivityUncheckedCreateWithoutVendorInput = {
    id?: string
    orderId?: string | null
    customerId?: string | null
    deliveryId?: string | null
    type: $Enums.ActivityType
    title: string
    message: string
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ActivityCreateOrConnectWithoutVendorInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutVendorInput, ActivityUncheckedCreateWithoutVendorInput>
  }

  export type ActivityCreateManyVendorInputEnvelope = {
    data: ActivityCreateManyVendorInput | ActivityCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutCustomerInput = {
    id?: string
    type: $Enums.ActivityType
    title: string
    message: string
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    order?: OrderCreateNestedOneWithoutActivityInput
    vendor?: UserCreateNestedOneWithoutVendorActivitiesInput
    delivery?: DeliveryPersonCreateNestedOneWithoutActivityInput
  }

  export type ActivityUncheckedCreateWithoutCustomerInput = {
    id?: string
    orderId?: string | null
    vendorId?: string | null
    deliveryId?: string | null
    type: $Enums.ActivityType
    title: string
    message: string
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ActivityCreateOrConnectWithoutCustomerInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutCustomerInput, ActivityUncheckedCreateWithoutCustomerInput>
  }

  export type ActivityCreateManyCustomerInputEnvelope = {
    data: ActivityCreateManyCustomerInput | ActivityCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type VendorFollowerCreateWithoutVendorInput = {
    id?: string
    createdAt?: Date | string
    customer: UserCreateNestedOneWithoutFollowingInput
  }

  export type VendorFollowerUncheckedCreateWithoutVendorInput = {
    id?: string
    customerId: string
    createdAt?: Date | string
  }

  export type VendorFollowerCreateOrConnectWithoutVendorInput = {
    where: VendorFollowerWhereUniqueInput
    create: XOR<VendorFollowerCreateWithoutVendorInput, VendorFollowerUncheckedCreateWithoutVendorInput>
  }

  export type VendorFollowerCreateManyVendorInputEnvelope = {
    data: VendorFollowerCreateManyVendorInput | VendorFollowerCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type VendorFollowerCreateWithoutCustomerInput = {
    id?: string
    createdAt?: Date | string
    vendor: UserCreateNestedOneWithoutFollowersInput
  }

  export type VendorFollowerUncheckedCreateWithoutCustomerInput = {
    id?: string
    vendorId: string
    createdAt?: Date | string
  }

  export type VendorFollowerCreateOrConnectWithoutCustomerInput = {
    where: VendorFollowerWhereUniqueInput
    create: XOR<VendorFollowerCreateWithoutCustomerInput, VendorFollowerUncheckedCreateWithoutCustomerInput>
  }

  export type VendorFollowerCreateManyCustomerInputEnvelope = {
    data: VendorFollowerCreateManyCustomerInput | VendorFollowerCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type SpecialOrderRequestCreateWithoutCustomerInput = {
    id?: string
    quantity: number
    message: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor?: UserCreateNestedOneWithoutSpecialRequestsReceivedInput
    product: ProductCreateNestedOneWithoutSpecialRequestsInput
    offers?: SpecialOrderOfferCreateNestedManyWithoutRequestInput
  }

  export type SpecialOrderRequestUncheckedCreateWithoutCustomerInput = {
    id?: string
    vendorId?: string | null
    productId: string
    quantity: number
    message: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    offers?: SpecialOrderOfferUncheckedCreateNestedManyWithoutRequestInput
  }

  export type SpecialOrderRequestCreateOrConnectWithoutCustomerInput = {
    where: SpecialOrderRequestWhereUniqueInput
    create: XOR<SpecialOrderRequestCreateWithoutCustomerInput, SpecialOrderRequestUncheckedCreateWithoutCustomerInput>
  }

  export type SpecialOrderRequestCreateManyCustomerInputEnvelope = {
    data: SpecialOrderRequestCreateManyCustomerInput | SpecialOrderRequestCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type SpecialOrderRequestCreateWithoutVendorInput = {
    id?: string
    quantity: number
    message: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: UserCreateNestedOneWithoutSpecialRequestsMadeInput
    product: ProductCreateNestedOneWithoutSpecialRequestsInput
    offers?: SpecialOrderOfferCreateNestedManyWithoutRequestInput
  }

  export type SpecialOrderRequestUncheckedCreateWithoutVendorInput = {
    id?: string
    customerId: string
    productId: string
    quantity: number
    message: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    offers?: SpecialOrderOfferUncheckedCreateNestedManyWithoutRequestInput
  }

  export type SpecialOrderRequestCreateOrConnectWithoutVendorInput = {
    where: SpecialOrderRequestWhereUniqueInput
    create: XOR<SpecialOrderRequestCreateWithoutVendorInput, SpecialOrderRequestUncheckedCreateWithoutVendorInput>
  }

  export type SpecialOrderRequestCreateManyVendorInputEnvelope = {
    data: SpecialOrderRequestCreateManyVendorInput | SpecialOrderRequestCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type SpecialOrderOfferCreateWithoutVendorInput = {
    id?: string
    price: number
    message?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    request: SpecialOrderRequestCreateNestedOneWithoutOffersInput
  }

  export type SpecialOrderOfferUncheckedCreateWithoutVendorInput = {
    id?: string
    requestId: string
    price: number
    message?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpecialOrderOfferCreateOrConnectWithoutVendorInput = {
    where: SpecialOrderOfferWhereUniqueInput
    create: XOR<SpecialOrderOfferCreateWithoutVendorInput, SpecialOrderOfferUncheckedCreateWithoutVendorInput>
  }

  export type SpecialOrderOfferCreateManyVendorInputEnvelope = {
    data: SpecialOrderOfferCreateManyVendorInput | SpecialOrderOfferCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutVendorInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutVendorInput, ProductUncheckedUpdateWithoutVendorInput>
    create: XOR<ProductCreateWithoutVendorInput, ProductUncheckedCreateWithoutVendorInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutVendorInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutVendorInput, ProductUncheckedUpdateWithoutVendorInput>
  }

  export type ProductUpdateManyWithWhereWithoutVendorInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutVendorInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    price?: FloatFilter<"Product"> | number
    archived?: BoolFilter<"Product"> | boolean
    category?: EnumCategoryFilter<"Product"> | $Enums.Category
    images?: StringNullableListFilter<"Product">
    thumbnail?: StringNullableFilter<"Product"> | string | null
    video?: StringNullableListFilter<"Product">
    vendorId?: StringFilter<"Product"> | string
    averageRating?: FloatNullableFilter<"Product"> | number | null
    reviewCount?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    totalViews?: IntFilter<"Product"> | number
    popularityScore?: FloatFilter<"Product"> | number
    popularityUpdatedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    popularityPercent?: FloatFilter<"Product"> | number
    isNew?: BoolFilter<"Product"> | boolean
    isLive?: BoolFilter<"Product"> | boolean
    liveUntil?: DateTimeNullableFilter<"Product"> | Date | string | null
  }

  export type VendorReviewUpsertWithWhereUniqueWithoutVendorInput = {
    where: VendorReviewWhereUniqueInput
    update: XOR<VendorReviewUpdateWithoutVendorInput, VendorReviewUncheckedUpdateWithoutVendorInput>
    create: XOR<VendorReviewCreateWithoutVendorInput, VendorReviewUncheckedCreateWithoutVendorInput>
  }

  export type VendorReviewUpdateWithWhereUniqueWithoutVendorInput = {
    where: VendorReviewWhereUniqueInput
    data: XOR<VendorReviewUpdateWithoutVendorInput, VendorReviewUncheckedUpdateWithoutVendorInput>
  }

  export type VendorReviewUpdateManyWithWhereWithoutVendorInput = {
    where: VendorReviewScalarWhereInput
    data: XOR<VendorReviewUpdateManyMutationInput, VendorReviewUncheckedUpdateManyWithoutVendorInput>
  }

  export type VendorReviewScalarWhereInput = {
    AND?: VendorReviewScalarWhereInput | VendorReviewScalarWhereInput[]
    OR?: VendorReviewScalarWhereInput[]
    NOT?: VendorReviewScalarWhereInput | VendorReviewScalarWhereInput[]
    id?: StringFilter<"VendorReview"> | string
    vendorId?: StringFilter<"VendorReview"> | string
    customerId?: StringFilter<"VendorReview"> | string
    rating?: IntFilter<"VendorReview"> | number
    comment?: StringNullableFilter<"VendorReview"> | string | null
    createdAt?: DateTimeFilter<"VendorReview"> | Date | string
  }

  export type VendorReviewUpsertWithWhereUniqueWithoutCustomerInput = {
    where: VendorReviewWhereUniqueInput
    update: XOR<VendorReviewUpdateWithoutCustomerInput, VendorReviewUncheckedUpdateWithoutCustomerInput>
    create: XOR<VendorReviewCreateWithoutCustomerInput, VendorReviewUncheckedCreateWithoutCustomerInput>
  }

  export type VendorReviewUpdateWithWhereUniqueWithoutCustomerInput = {
    where: VendorReviewWhereUniqueInput
    data: XOR<VendorReviewUpdateWithoutCustomerInput, VendorReviewUncheckedUpdateWithoutCustomerInput>
  }

  export type VendorReviewUpdateManyWithWhereWithoutCustomerInput = {
    where: VendorReviewScalarWhereInput
    data: XOR<VendorReviewUpdateManyMutationInput, VendorReviewUncheckedUpdateManyWithoutCustomerInput>
  }

  export type ProductReviewUpsertWithWhereUniqueWithoutCustomerInput = {
    where: ProductReviewWhereUniqueInput
    update: XOR<ProductReviewUpdateWithoutCustomerInput, ProductReviewUncheckedUpdateWithoutCustomerInput>
    create: XOR<ProductReviewCreateWithoutCustomerInput, ProductReviewUncheckedCreateWithoutCustomerInput>
  }

  export type ProductReviewUpdateWithWhereUniqueWithoutCustomerInput = {
    where: ProductReviewWhereUniqueInput
    data: XOR<ProductReviewUpdateWithoutCustomerInput, ProductReviewUncheckedUpdateWithoutCustomerInput>
  }

  export type ProductReviewUpdateManyWithWhereWithoutCustomerInput = {
    where: ProductReviewScalarWhereInput
    data: XOR<ProductReviewUpdateManyMutationInput, ProductReviewUncheckedUpdateManyWithoutCustomerInput>
  }

  export type ProductReviewScalarWhereInput = {
    AND?: ProductReviewScalarWhereInput | ProductReviewScalarWhereInput[]
    OR?: ProductReviewScalarWhereInput[]
    NOT?: ProductReviewScalarWhereInput | ProductReviewScalarWhereInput[]
    id?: StringFilter<"ProductReview"> | string
    productId?: StringFilter<"ProductReview"> | string
    customerId?: StringFilter<"ProductReview"> | string
    rating?: IntFilter<"ProductReview"> | number
    comment?: StringNullableFilter<"ProductReview"> | string | null
    images?: StringNullableListFilter<"ProductReview">
    createdAt?: DateTimeFilter<"ProductReview"> | Date | string
    verifiedPurchase?: BoolFilter<"ProductReview"> | boolean
  }

  export type OrderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
  }

  export type OrderUpdateManyWithWhereWithoutCustomerInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutCustomerInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    customerId?: StringFilter<"Order"> | string
    vendorId?: StringFilter<"Order"> | string
    addressId?: StringNullableFilter<"Order"> | string | null
    basePrice?: FloatFilter<"Order"> | number
    extraCharge?: FloatFilter<"Order"> | number
    totalPrice?: FloatFilter<"Order"> | number
    vendorNote?: StringNullableFilter<"Order"> | string | null
    customerApproval?: BoolFilter<"Order"> | boolean
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    paymentInitiatedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    paymentStartedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    paymentStatus?: EnumPaymentStatusNullableFilter<"Order"> | $Enums.PaymentStatus | null
    cancelledAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    cancellationReason?: StringNullableFilter<"Order"> | string | null
    protectedUntil?: DateTimeNullableFilter<"Order"> | Date | string | null
    paymentGraceMinutes?: IntNullableFilter<"Order"> | number | null
  }

  export type OrderUpsertWithWhereUniqueWithoutVendorInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutVendorInput, OrderUncheckedUpdateWithoutVendorInput>
    create: XOR<OrderCreateWithoutVendorInput, OrderUncheckedCreateWithoutVendorInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutVendorInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutVendorInput, OrderUncheckedUpdateWithoutVendorInput>
  }

  export type OrderUpdateManyWithWhereWithoutVendorInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutVendorInput>
  }

  export type VendorReplyUpsertWithWhereUniqueWithoutVendorInput = {
    where: VendorReplyWhereUniqueInput
    update: XOR<VendorReplyUpdateWithoutVendorInput, VendorReplyUncheckedUpdateWithoutVendorInput>
    create: XOR<VendorReplyCreateWithoutVendorInput, VendorReplyUncheckedCreateWithoutVendorInput>
  }

  export type VendorReplyUpdateWithWhereUniqueWithoutVendorInput = {
    where: VendorReplyWhereUniqueInput
    data: XOR<VendorReplyUpdateWithoutVendorInput, VendorReplyUncheckedUpdateWithoutVendorInput>
  }

  export type VendorReplyUpdateManyWithWhereWithoutVendorInput = {
    where: VendorReplyScalarWhereInput
    data: XOR<VendorReplyUpdateManyMutationInput, VendorReplyUncheckedUpdateManyWithoutVendorInput>
  }

  export type VendorReplyScalarWhereInput = {
    AND?: VendorReplyScalarWhereInput | VendorReplyScalarWhereInput[]
    OR?: VendorReplyScalarWhereInput[]
    NOT?: VendorReplyScalarWhereInput | VendorReplyScalarWhereInput[]
    id?: StringFilter<"VendorReply"> | string
    reviewId?: StringFilter<"VendorReply"> | string
    vendorId?: StringFilter<"VendorReply"> | string
    message?: StringFilter<"VendorReply"> | string
    createdAt?: DateTimeFilter<"VendorReply"> | Date | string
  }

  export type ReviewVoteUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewVoteWhereUniqueInput
    update: XOR<ReviewVoteUpdateWithoutUserInput, ReviewVoteUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewVoteCreateWithoutUserInput, ReviewVoteUncheckedCreateWithoutUserInput>
  }

  export type ReviewVoteUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewVoteWhereUniqueInput
    data: XOR<ReviewVoteUpdateWithoutUserInput, ReviewVoteUncheckedUpdateWithoutUserInput>
  }

  export type ReviewVoteUpdateManyWithWhereWithoutUserInput = {
    where: ReviewVoteScalarWhereInput
    data: XOR<ReviewVoteUpdateManyMutationInput, ReviewVoteUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewVoteScalarWhereInput = {
    AND?: ReviewVoteScalarWhereInput | ReviewVoteScalarWhereInput[]
    OR?: ReviewVoteScalarWhereInput[]
    NOT?: ReviewVoteScalarWhereInput | ReviewVoteScalarWhereInput[]
    id?: StringFilter<"ReviewVote"> | string
    reviewId?: StringFilter<"ReviewVote"> | string
    userId?: StringFilter<"ReviewVote"> | string
    isHelpful?: BoolFilter<"ReviewVote"> | boolean
    createdAt?: DateTimeFilter<"ReviewVote"> | Date | string
  }

  export type ReviewReportUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewReportWhereUniqueInput
    update: XOR<ReviewReportUpdateWithoutUserInput, ReviewReportUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewReportCreateWithoutUserInput, ReviewReportUncheckedCreateWithoutUserInput>
  }

  export type ReviewReportUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewReportWhereUniqueInput
    data: XOR<ReviewReportUpdateWithoutUserInput, ReviewReportUncheckedUpdateWithoutUserInput>
  }

  export type ReviewReportUpdateManyWithWhereWithoutUserInput = {
    where: ReviewReportScalarWhereInput
    data: XOR<ReviewReportUpdateManyMutationInput, ReviewReportUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewReportScalarWhereInput = {
    AND?: ReviewReportScalarWhereInput | ReviewReportScalarWhereInput[]
    OR?: ReviewReportScalarWhereInput[]
    NOT?: ReviewReportScalarWhereInput | ReviewReportScalarWhereInput[]
    id?: StringFilter<"ReviewReport"> | string
    reviewId?: StringFilter<"ReviewReport"> | string
    userId?: StringFilter<"ReviewReport"> | string
    reason?: StringFilter<"ReviewReport"> | string
    createdAt?: DateTimeFilter<"ReviewReport"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    metadata?: JsonNullableFilter<"Notification">
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type LoginHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: LoginHistoryWhereUniqueInput
    update: XOR<LoginHistoryUpdateWithoutUserInput, LoginHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<LoginHistoryCreateWithoutUserInput, LoginHistoryUncheckedCreateWithoutUserInput>
  }

  export type LoginHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: LoginHistoryWhereUniqueInput
    data: XOR<LoginHistoryUpdateWithoutUserInput, LoginHistoryUncheckedUpdateWithoutUserInput>
  }

  export type LoginHistoryUpdateManyWithWhereWithoutUserInput = {
    where: LoginHistoryScalarWhereInput
    data: XOR<LoginHistoryUpdateManyMutationInput, LoginHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type LoginHistoryScalarWhereInput = {
    AND?: LoginHistoryScalarWhereInput | LoginHistoryScalarWhereInput[]
    OR?: LoginHistoryScalarWhereInput[]
    NOT?: LoginHistoryScalarWhereInput | LoginHistoryScalarWhereInput[]
    id?: StringFilter<"LoginHistory"> | string
    userId?: StringFilter<"LoginHistory"> | string
    method?: StringFilter<"LoginHistory"> | string
    deviceId?: StringNullableFilter<"LoginHistory"> | string | null
    location?: StringNullableFilter<"LoginHistory"> | string | null
    ip?: StringNullableFilter<"LoginHistory"> | string | null
    userAgent?: StringNullableFilter<"LoginHistory"> | string | null
    geoCity?: StringNullableFilter<"LoginHistory"> | string | null
    geoRegion?: StringNullableFilter<"LoginHistory"> | string | null
    geoCountry?: StringNullableFilter<"LoginHistory"> | string | null
    createdAt?: DateTimeFilter<"LoginHistory"> | Date | string
  }

  export type AddressUpsertWithWhereUniqueWithoutUserInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutUserInput, AddressUncheckedUpdateWithoutUserInput>
    create: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutUserInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutUserInput, AddressUncheckedUpdateWithoutUserInput>
  }

  export type AddressUpdateManyWithWhereWithoutUserInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutUserInput>
  }

  export type AddressScalarWhereInput = {
    AND?: AddressScalarWhereInput | AddressScalarWhereInput[]
    OR?: AddressScalarWhereInput[]
    NOT?: AddressScalarWhereInput | AddressScalarWhereInput[]
    id?: StringFilter<"Address"> | string
    userId?: StringFilter<"Address"> | string
    label?: StringFilter<"Address"> | string
    street?: StringFilter<"Address"> | string
    city?: StringFilter<"Address"> | string
    state?: StringNullableFilter<"Address"> | string | null
    country?: StringFilter<"Address"> | string
    zipCode?: StringNullableFilter<"Address"> | string | null
    landmark?: StringNullableFilter<"Address"> | string | null
    latitude?: FloatNullableFilter<"Address"> | number | null
    longitude?: FloatNullableFilter<"Address"> | number | null
    isDefault?: BoolFilter<"Address"> | boolean
    createdAt?: DateTimeFilter<"Address"> | Date | string
  }

  export type CartUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CartWhereUniqueInput
    update: XOR<CartUpdateWithoutCustomerInput, CartUncheckedUpdateWithoutCustomerInput>
    create: XOR<CartCreateWithoutCustomerInput, CartUncheckedCreateWithoutCustomerInput>
  }

  export type CartUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CartWhereUniqueInput
    data: XOR<CartUpdateWithoutCustomerInput, CartUncheckedUpdateWithoutCustomerInput>
  }

  export type CartUpdateManyWithWhereWithoutCustomerInput = {
    where: CartScalarWhereInput
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CartScalarWhereInput = {
    AND?: CartScalarWhereInput | CartScalarWhereInput[]
    OR?: CartScalarWhereInput[]
    NOT?: CartScalarWhereInput | CartScalarWhereInput[]
    id?: StringFilter<"Cart"> | string
    customerId?: StringFilter<"Cart"> | string
    basePrice?: FloatFilter<"Cart"> | number
    totalPrice?: FloatFilter<"Cart"> | number
    createdAt?: DateTimeFilter<"Cart"> | Date | string
    updatedAt?: DateTimeFilter<"Cart"> | Date | string
  }

  export type UserPaymentMethodUpsertWithWhereUniqueWithoutUserInput = {
    where: UserPaymentMethodWhereUniqueInput
    update: XOR<UserPaymentMethodUpdateWithoutUserInput, UserPaymentMethodUncheckedUpdateWithoutUserInput>
    create: XOR<UserPaymentMethodCreateWithoutUserInput, UserPaymentMethodUncheckedCreateWithoutUserInput>
  }

  export type UserPaymentMethodUpdateWithWhereUniqueWithoutUserInput = {
    where: UserPaymentMethodWhereUniqueInput
    data: XOR<UserPaymentMethodUpdateWithoutUserInput, UserPaymentMethodUncheckedUpdateWithoutUserInput>
  }

  export type UserPaymentMethodUpdateManyWithWhereWithoutUserInput = {
    where: UserPaymentMethodScalarWhereInput
    data: XOR<UserPaymentMethodUpdateManyMutationInput, UserPaymentMethodUncheckedUpdateManyWithoutUserInput>
  }

  export type UserPaymentMethodScalarWhereInput = {
    AND?: UserPaymentMethodScalarWhereInput | UserPaymentMethodScalarWhereInput[]
    OR?: UserPaymentMethodScalarWhereInput[]
    NOT?: UserPaymentMethodScalarWhereInput | UserPaymentMethodScalarWhereInput[]
    id?: StringFilter<"UserPaymentMethod"> | string
    userId?: StringFilter<"UserPaymentMethod"> | string
    cardToken?: StringFilter<"UserPaymentMethod"> | string
    last4?: StringFilter<"UserPaymentMethod"> | string
    brand?: StringFilter<"UserPaymentMethod"> | string
    isDefault?: BoolFilter<"UserPaymentMethod"> | boolean
    createdAt?: DateTimeFilter<"UserPaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"UserPaymentMethod"> | Date | string
  }

  export type DeliveryPersonUpsertWithoutUserInput = {
    update: XOR<DeliveryPersonUpdateWithoutUserInput, DeliveryPersonUncheckedUpdateWithoutUserInput>
    create: XOR<DeliveryPersonCreateWithoutUserInput, DeliveryPersonUncheckedCreateWithoutUserInput>
    where?: DeliveryPersonWhereInput
  }

  export type DeliveryPersonUpdateToOneWithWhereWithoutUserInput = {
    where?: DeliveryPersonWhereInput
    data: XOR<DeliveryPersonUpdateWithoutUserInput, DeliveryPersonUncheckedUpdateWithoutUserInput>
  }

  export type DeliveryPersonUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    totalDeliveries?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedOrders?: DeliveryAssignmentUpdateManyWithoutDeliveryPersonNestedInput
    earnings?: DeliveryEarningUpdateManyWithoutDeliveryPersonNestedInput
    DriverLocationLog?: DriverLocationLogUpdateManyWithoutDriverNestedInput
    Activity?: ActivityUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryPersonUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    totalDeliveries?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedOrders?: DeliveryAssignmentUncheckedUpdateManyWithoutDeliveryPersonNestedInput
    earnings?: DeliveryEarningUncheckedUpdateManyWithoutDeliveryPersonNestedInput
    DriverLocationLog?: DriverLocationLogUncheckedUpdateManyWithoutDriverNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutDeliveryNestedInput
  }

  export type PasswordResetTokenUpsertWithoutUserInput = {
    update: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
    where?: PasswordResetTokenWhereInput
  }

  export type PasswordResetTokenUpdateToOneWithWhereWithoutUserInput = {
    where?: PasswordResetTokenWhereInput
    data: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
  }

  export type PaymentUpdateManyWithWhereWithoutUserInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutUserInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    orderId?: StringFilter<"Payment"> | string
    amount?: IntFilter<"Payment"> | number
    reference?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    paystackData?: JsonNullableFilter<"Payment">
    channel?: StringNullableFilter<"Payment"> | string | null
    ipAddress?: StringFilter<"Payment"> | string
    userAgent?: StringFilter<"Payment"> | string
    deviceId?: StringNullableFilter<"Payment"> | string | null
    geoCity?: StringNullableFilter<"Payment"> | string | null
    geoCountry?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    metadata?: JsonNullableFilter<"Payment">
    startedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
  }

  export type RefundRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: RefundRequestWhereUniqueInput
    update: XOR<RefundRequestUpdateWithoutUserInput, RefundRequestUncheckedUpdateWithoutUserInput>
    create: XOR<RefundRequestCreateWithoutUserInput, RefundRequestUncheckedCreateWithoutUserInput>
  }

  export type RefundRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: RefundRequestWhereUniqueInput
    data: XOR<RefundRequestUpdateWithoutUserInput, RefundRequestUncheckedUpdateWithoutUserInput>
  }

  export type RefundRequestUpdateManyWithWhereWithoutUserInput = {
    where: RefundRequestScalarWhereInput
    data: XOR<RefundRequestUpdateManyMutationInput, RefundRequestUncheckedUpdateManyWithoutUserInput>
  }

  export type RefundRequestScalarWhereInput = {
    AND?: RefundRequestScalarWhereInput | RefundRequestScalarWhereInput[]
    OR?: RefundRequestScalarWhereInput[]
    NOT?: RefundRequestScalarWhereInput | RefundRequestScalarWhereInput[]
    id?: StringFilter<"RefundRequest"> | string
    userId?: StringFilter<"RefundRequest"> | string
    paymentRef?: StringFilter<"RefundRequest"> | string
    reason?: StringFilter<"RefundRequest"> | string
    status?: EnumRefundStatusFilter<"RefundRequest"> | $Enums.RefundStatus
    createdAt?: DateTimeFilter<"RefundRequest"> | Date | string
    updatedAt?: DateTimeFilter<"RefundRequest"> | Date | string
  }

  export type ActivityUpsertWithWhereUniqueWithoutVendorInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutVendorInput, ActivityUncheckedUpdateWithoutVendorInput>
    create: XOR<ActivityCreateWithoutVendorInput, ActivityUncheckedCreateWithoutVendorInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutVendorInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutVendorInput, ActivityUncheckedUpdateWithoutVendorInput>
  }

  export type ActivityUpdateManyWithWhereWithoutVendorInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutVendorInput>
  }

  export type ActivityScalarWhereInput = {
    AND?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    OR?: ActivityScalarWhereInput[]
    NOT?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    id?: StringFilter<"Activity"> | string
    orderId?: StringNullableFilter<"Activity"> | string | null
    vendorId?: StringNullableFilter<"Activity"> | string | null
    customerId?: StringNullableFilter<"Activity"> | string | null
    deliveryId?: StringNullableFilter<"Activity"> | string | null
    type?: EnumActivityTypeFilter<"Activity"> | $Enums.ActivityType
    title?: StringFilter<"Activity"> | string
    message?: StringFilter<"Activity"> | string
    meta?: JsonNullableFilter<"Activity">
    createdAt?: DateTimeFilter<"Activity"> | Date | string
  }

  export type ActivityUpsertWithWhereUniqueWithoutCustomerInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutCustomerInput, ActivityUncheckedUpdateWithoutCustomerInput>
    create: XOR<ActivityCreateWithoutCustomerInput, ActivityUncheckedCreateWithoutCustomerInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutCustomerInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutCustomerInput, ActivityUncheckedUpdateWithoutCustomerInput>
  }

  export type ActivityUpdateManyWithWhereWithoutCustomerInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutCustomerInput>
  }

  export type VendorFollowerUpsertWithWhereUniqueWithoutVendorInput = {
    where: VendorFollowerWhereUniqueInput
    update: XOR<VendorFollowerUpdateWithoutVendorInput, VendorFollowerUncheckedUpdateWithoutVendorInput>
    create: XOR<VendorFollowerCreateWithoutVendorInput, VendorFollowerUncheckedCreateWithoutVendorInput>
  }

  export type VendorFollowerUpdateWithWhereUniqueWithoutVendorInput = {
    where: VendorFollowerWhereUniqueInput
    data: XOR<VendorFollowerUpdateWithoutVendorInput, VendorFollowerUncheckedUpdateWithoutVendorInput>
  }

  export type VendorFollowerUpdateManyWithWhereWithoutVendorInput = {
    where: VendorFollowerScalarWhereInput
    data: XOR<VendorFollowerUpdateManyMutationInput, VendorFollowerUncheckedUpdateManyWithoutVendorInput>
  }

  export type VendorFollowerScalarWhereInput = {
    AND?: VendorFollowerScalarWhereInput | VendorFollowerScalarWhereInput[]
    OR?: VendorFollowerScalarWhereInput[]
    NOT?: VendorFollowerScalarWhereInput | VendorFollowerScalarWhereInput[]
    id?: StringFilter<"VendorFollower"> | string
    vendorId?: StringFilter<"VendorFollower"> | string
    customerId?: StringFilter<"VendorFollower"> | string
    createdAt?: DateTimeFilter<"VendorFollower"> | Date | string
  }

  export type VendorFollowerUpsertWithWhereUniqueWithoutCustomerInput = {
    where: VendorFollowerWhereUniqueInput
    update: XOR<VendorFollowerUpdateWithoutCustomerInput, VendorFollowerUncheckedUpdateWithoutCustomerInput>
    create: XOR<VendorFollowerCreateWithoutCustomerInput, VendorFollowerUncheckedCreateWithoutCustomerInput>
  }

  export type VendorFollowerUpdateWithWhereUniqueWithoutCustomerInput = {
    where: VendorFollowerWhereUniqueInput
    data: XOR<VendorFollowerUpdateWithoutCustomerInput, VendorFollowerUncheckedUpdateWithoutCustomerInput>
  }

  export type VendorFollowerUpdateManyWithWhereWithoutCustomerInput = {
    where: VendorFollowerScalarWhereInput
    data: XOR<VendorFollowerUpdateManyMutationInput, VendorFollowerUncheckedUpdateManyWithoutCustomerInput>
  }

  export type SpecialOrderRequestUpsertWithWhereUniqueWithoutCustomerInput = {
    where: SpecialOrderRequestWhereUniqueInput
    update: XOR<SpecialOrderRequestUpdateWithoutCustomerInput, SpecialOrderRequestUncheckedUpdateWithoutCustomerInput>
    create: XOR<SpecialOrderRequestCreateWithoutCustomerInput, SpecialOrderRequestUncheckedCreateWithoutCustomerInput>
  }

  export type SpecialOrderRequestUpdateWithWhereUniqueWithoutCustomerInput = {
    where: SpecialOrderRequestWhereUniqueInput
    data: XOR<SpecialOrderRequestUpdateWithoutCustomerInput, SpecialOrderRequestUncheckedUpdateWithoutCustomerInput>
  }

  export type SpecialOrderRequestUpdateManyWithWhereWithoutCustomerInput = {
    where: SpecialOrderRequestScalarWhereInput
    data: XOR<SpecialOrderRequestUpdateManyMutationInput, SpecialOrderRequestUncheckedUpdateManyWithoutCustomerInput>
  }

  export type SpecialOrderRequestScalarWhereInput = {
    AND?: SpecialOrderRequestScalarWhereInput | SpecialOrderRequestScalarWhereInput[]
    OR?: SpecialOrderRequestScalarWhereInput[]
    NOT?: SpecialOrderRequestScalarWhereInput | SpecialOrderRequestScalarWhereInput[]
    id?: StringFilter<"SpecialOrderRequest"> | string
    customerId?: StringFilter<"SpecialOrderRequest"> | string
    vendorId?: StringNullableFilter<"SpecialOrderRequest"> | string | null
    productId?: StringFilter<"SpecialOrderRequest"> | string
    quantity?: IntFilter<"SpecialOrderRequest"> | number
    message?: StringFilter<"SpecialOrderRequest"> | string
    status?: StringFilter<"SpecialOrderRequest"> | string
    createdAt?: DateTimeFilter<"SpecialOrderRequest"> | Date | string
    updatedAt?: DateTimeFilter<"SpecialOrderRequest"> | Date | string
  }

  export type SpecialOrderRequestUpsertWithWhereUniqueWithoutVendorInput = {
    where: SpecialOrderRequestWhereUniqueInput
    update: XOR<SpecialOrderRequestUpdateWithoutVendorInput, SpecialOrderRequestUncheckedUpdateWithoutVendorInput>
    create: XOR<SpecialOrderRequestCreateWithoutVendorInput, SpecialOrderRequestUncheckedCreateWithoutVendorInput>
  }

  export type SpecialOrderRequestUpdateWithWhereUniqueWithoutVendorInput = {
    where: SpecialOrderRequestWhereUniqueInput
    data: XOR<SpecialOrderRequestUpdateWithoutVendorInput, SpecialOrderRequestUncheckedUpdateWithoutVendorInput>
  }

  export type SpecialOrderRequestUpdateManyWithWhereWithoutVendorInput = {
    where: SpecialOrderRequestScalarWhereInput
    data: XOR<SpecialOrderRequestUpdateManyMutationInput, SpecialOrderRequestUncheckedUpdateManyWithoutVendorInput>
  }

  export type SpecialOrderOfferUpsertWithWhereUniqueWithoutVendorInput = {
    where: SpecialOrderOfferWhereUniqueInput
    update: XOR<SpecialOrderOfferUpdateWithoutVendorInput, SpecialOrderOfferUncheckedUpdateWithoutVendorInput>
    create: XOR<SpecialOrderOfferCreateWithoutVendorInput, SpecialOrderOfferUncheckedCreateWithoutVendorInput>
  }

  export type SpecialOrderOfferUpdateWithWhereUniqueWithoutVendorInput = {
    where: SpecialOrderOfferWhereUniqueInput
    data: XOR<SpecialOrderOfferUpdateWithoutVendorInput, SpecialOrderOfferUncheckedUpdateWithoutVendorInput>
  }

  export type SpecialOrderOfferUpdateManyWithWhereWithoutVendorInput = {
    where: SpecialOrderOfferScalarWhereInput
    data: XOR<SpecialOrderOfferUpdateManyMutationInput, SpecialOrderOfferUncheckedUpdateManyWithoutVendorInput>
  }

  export type SpecialOrderOfferScalarWhereInput = {
    AND?: SpecialOrderOfferScalarWhereInput | SpecialOrderOfferScalarWhereInput[]
    OR?: SpecialOrderOfferScalarWhereInput[]
    NOT?: SpecialOrderOfferScalarWhereInput | SpecialOrderOfferScalarWhereInput[]
    id?: StringFilter<"SpecialOrderOffer"> | string
    requestId?: StringFilter<"SpecialOrderOffer"> | string
    vendorId?: StringFilter<"SpecialOrderOffer"> | string
    price?: FloatFilter<"SpecialOrderOffer"> | number
    message?: StringNullableFilter<"SpecialOrderOffer"> | string | null
    status?: StringFilter<"SpecialOrderOffer"> | string
    createdAt?: DateTimeFilter<"SpecialOrderOffer"> | Date | string
    updatedAt?: DateTimeFilter<"SpecialOrderOffer"> | Date | string
  }

  export type UserCreateWithoutAddressesInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerCreateNestedManyWithoutVendorInput
    following?: VendorFollowerCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateWithoutAddressesInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewUncheckedCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewUncheckedCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderUncheckedCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyUncheckedCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonUncheckedCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestUncheckedCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityUncheckedCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityUncheckedCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerUncheckedCreateNestedManyWithoutVendorInput
    following?: VendorFollowerUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserCreateOrConnectWithoutAddressesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>
  }

  export type OrderCreateWithoutAddressInput = {
    id?: string
    basePrice: number
    extraCharge?: number
    totalPrice: number
    vendorNote?: string | null
    customerApproval?: boolean
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentInitiatedAt?: Date | string | null
    paymentStartedAt?: Date | string | null
    paidAt?: Date | string | null
    paymentStatus?: $Enums.PaymentStatus | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    protectedUntil?: Date | string | null
    paymentGraceMinutes?: number | null
    customer: UserCreateNestedOneWithoutCustomerOrdersInput
    vendor: UserCreateNestedOneWithoutVendorOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    Product?: ProductCreateNestedManyWithoutOrdersInput
    assignments?: DeliveryAssignmentCreateNestedManyWithoutOrderInput
    earnings?: DeliveryEarningCreateNestedManyWithoutOrderInput
    Activity?: ActivityCreateNestedManyWithoutOrderInput
    DeliveryBroadcast?: DeliveryBroadcastCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutAddressInput = {
    id?: string
    customerId: string
    vendorId: string
    basePrice: number
    extraCharge?: number
    totalPrice: number
    vendorNote?: string | null
    customerApproval?: boolean
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentInitiatedAt?: Date | string | null
    paymentStartedAt?: Date | string | null
    paidAt?: Date | string | null
    paymentStatus?: $Enums.PaymentStatus | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    protectedUntil?: Date | string | null
    paymentGraceMinutes?: number | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    Product?: ProductUncheckedCreateNestedManyWithoutOrdersInput
    assignments?: DeliveryAssignmentUncheckedCreateNestedManyWithoutOrderInput
    earnings?: DeliveryEarningUncheckedCreateNestedManyWithoutOrderInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutOrderInput
    DeliveryBroadcast?: DeliveryBroadcastUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutAddressInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutAddressInput, OrderUncheckedCreateWithoutAddressInput>
  }

  export type OrderCreateManyAddressInputEnvelope = {
    data: OrderCreateManyAddressInput | OrderCreateManyAddressInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAddressesInput = {
    update: XOR<UserUpdateWithoutAddressesInput, UserUncheckedUpdateWithoutAddressesInput>
    create: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAddressesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAddressesInput, UserUncheckedUpdateWithoutAddressesInput>
  }

  export type UserUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUncheckedUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUncheckedUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUncheckedUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUncheckedUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUncheckedUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUncheckedUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUncheckedUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUncheckedUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUncheckedUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type OrderUpsertWithWhereUniqueWithoutAddressInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutAddressInput, OrderUncheckedUpdateWithoutAddressInput>
    create: XOR<OrderCreateWithoutAddressInput, OrderUncheckedCreateWithoutAddressInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutAddressInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutAddressInput, OrderUncheckedUpdateWithoutAddressInput>
  }

  export type OrderUpdateManyWithWhereWithoutAddressInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutAddressInput>
  }

  export type UserCreateWithoutProductsInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    vendorReviewsReceived?: VendorReviewCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerCreateNestedManyWithoutVendorInput
    following?: VendorFollowerCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateWithoutProductsInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    vendorReviewsReceived?: VendorReviewUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewUncheckedCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewUncheckedCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderUncheckedCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyUncheckedCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonUncheckedCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestUncheckedCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityUncheckedCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityUncheckedCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerUncheckedCreateNestedManyWithoutVendorInput
    following?: VendorFollowerUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserCreateOrConnectWithoutProductsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProductsInput, UserUncheckedCreateWithoutProductsInput>
  }

  export type ProductReviewCreateWithoutProductInput = {
    id?: string
    rating: number
    comment?: string | null
    images?: ProductReviewCreateimagesInput | string[]
    createdAt?: Date | string
    verifiedPurchase?: boolean
    customer: UserCreateNestedOneWithoutProductReviewsGivenInput
    reply?: VendorReplyCreateNestedOneWithoutReviewInput
    votes?: ReviewVoteCreateNestedManyWithoutReviewInput
    reports?: ReviewReportCreateNestedManyWithoutReviewInput
  }

  export type ProductReviewUncheckedCreateWithoutProductInput = {
    id?: string
    customerId: string
    rating: number
    comment?: string | null
    images?: ProductReviewCreateimagesInput | string[]
    createdAt?: Date | string
    verifiedPurchase?: boolean
    reply?: VendorReplyUncheckedCreateNestedOneWithoutReviewInput
    votes?: ReviewVoteUncheckedCreateNestedManyWithoutReviewInput
    reports?: ReviewReportUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ProductReviewCreateOrConnectWithoutProductInput = {
    where: ProductReviewWhereUniqueInput
    create: XOR<ProductReviewCreateWithoutProductInput, ProductReviewUncheckedCreateWithoutProductInput>
  }

  export type ProductReviewCreateManyProductInputEnvelope = {
    data: ProductReviewCreateManyProductInput | ProductReviewCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutProductInput = {
    id?: string
    basePrice: number
    extraCharge?: number
    totalPrice: number
    vendorNote?: string | null
    customerApproval?: boolean
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentInitiatedAt?: Date | string | null
    paymentStartedAt?: Date | string | null
    paidAt?: Date | string | null
    paymentStatus?: $Enums.PaymentStatus | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    protectedUntil?: Date | string | null
    paymentGraceMinutes?: number | null
    customer: UserCreateNestedOneWithoutCustomerOrdersInput
    vendor: UserCreateNestedOneWithoutVendorOrdersInput
    address?: AddressCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    assignments?: DeliveryAssignmentCreateNestedManyWithoutOrderInput
    earnings?: DeliveryEarningCreateNestedManyWithoutOrderInput
    Activity?: ActivityCreateNestedManyWithoutOrderInput
    DeliveryBroadcast?: DeliveryBroadcastCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutProductInput = {
    id?: string
    customerId: string
    vendorId: string
    addressId?: string | null
    basePrice: number
    extraCharge?: number
    totalPrice: number
    vendorNote?: string | null
    customerApproval?: boolean
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentInitiatedAt?: Date | string | null
    paymentStartedAt?: Date | string | null
    paidAt?: Date | string | null
    paymentStatus?: $Enums.PaymentStatus | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    protectedUntil?: Date | string | null
    paymentGraceMinutes?: number | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    assignments?: DeliveryAssignmentUncheckedCreateNestedManyWithoutOrderInput
    earnings?: DeliveryEarningUncheckedCreateNestedManyWithoutOrderInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutOrderInput
    DeliveryBroadcast?: DeliveryBroadcastUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutProductInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutProductInput, OrderUncheckedCreateWithoutProductInput>
  }

  export type OrderItemCreateWithoutProductInput = {
    id?: string
    quantity: number
    unitPrice: number
    subtotal: number
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutItemsInput
    options?: OrderItemOptionCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutProductInput = {
    id?: string
    orderId: string
    quantity: number
    unitPrice: number
    subtotal: number
    createdAt?: Date | string
    options?: OrderItemOptionUncheckedCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemCreateOrConnectWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemCreateManyProductInputEnvelope = {
    data: OrderItemCreateManyProductInput | OrderItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductOptionCreateWithoutProductInput = {
    id?: string
    name: string
    price: number
    OrderItemOption?: OrderItemOptionCreateNestedManyWithoutProductOptionInput
    CartItemOption?: CartItemOptionCreateNestedManyWithoutProductOptionInput
  }

  export type ProductOptionUncheckedCreateWithoutProductInput = {
    id?: string
    name: string
    price: number
    OrderItemOption?: OrderItemOptionUncheckedCreateNestedManyWithoutProductOptionInput
    CartItemOption?: CartItemOptionUncheckedCreateNestedManyWithoutProductOptionInput
  }

  export type ProductOptionCreateOrConnectWithoutProductInput = {
    where: ProductOptionWhereUniqueInput
    create: XOR<ProductOptionCreateWithoutProductInput, ProductOptionUncheckedCreateWithoutProductInput>
  }

  export type ProductOptionCreateManyProductInputEnvelope = {
    data: ProductOptionCreateManyProductInput | ProductOptionCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CartItemCreateWithoutProductInput = {
    id?: string
    quantity: number
    unitPrice: number
    subtotal: number
    specialRequest?: string | null
    cart: CartCreateNestedOneWithoutItemsInput
    options?: CartItemOptionCreateNestedManyWithoutCartItemInput
  }

  export type CartItemUncheckedCreateWithoutProductInput = {
    id?: string
    cartId: string
    quantity: number
    unitPrice: number
    subtotal: number
    specialRequest?: string | null
    options?: CartItemOptionUncheckedCreateNestedManyWithoutCartItemInput
  }

  export type CartItemCreateOrConnectWithoutProductInput = {
    where: CartItemWhereUniqueInput
    create: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput>
  }

  export type CartItemCreateManyProductInputEnvelope = {
    data: CartItemCreateManyProductInput | CartItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type SpecialOrderRequestCreateWithoutProductInput = {
    id?: string
    quantity: number
    message: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: UserCreateNestedOneWithoutSpecialRequestsMadeInput
    vendor?: UserCreateNestedOneWithoutSpecialRequestsReceivedInput
    offers?: SpecialOrderOfferCreateNestedManyWithoutRequestInput
  }

  export type SpecialOrderRequestUncheckedCreateWithoutProductInput = {
    id?: string
    customerId: string
    vendorId?: string | null
    quantity: number
    message: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    offers?: SpecialOrderOfferUncheckedCreateNestedManyWithoutRequestInput
  }

  export type SpecialOrderRequestCreateOrConnectWithoutProductInput = {
    where: SpecialOrderRequestWhereUniqueInput
    create: XOR<SpecialOrderRequestCreateWithoutProductInput, SpecialOrderRequestUncheckedCreateWithoutProductInput>
  }

  export type SpecialOrderRequestCreateManyProductInputEnvelope = {
    data: SpecialOrderRequestCreateManyProductInput | SpecialOrderRequestCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductScheduleCreateWithoutProductInput = {
    id?: string
    goLiveAt?: Date | string | null
    takeDownAt?: Date | string | null
    isLive?: boolean
    graceMinutes?: number | null
    autoGraceEnabled?: boolean
    manualGraceEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductScheduleUncheckedCreateWithoutProductInput = {
    id?: string
    goLiveAt?: Date | string | null
    takeDownAt?: Date | string | null
    isLive?: boolean
    graceMinutes?: number | null
    autoGraceEnabled?: boolean
    manualGraceEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductScheduleCreateOrConnectWithoutProductInput = {
    where: ProductScheduleWhereUniqueInput
    create: XOR<ProductScheduleCreateWithoutProductInput, ProductScheduleUncheckedCreateWithoutProductInput>
  }

  export type UserUpsertWithoutProductsInput = {
    update: XOR<UserUpdateWithoutProductsInput, UserUncheckedUpdateWithoutProductsInput>
    create: XOR<UserCreateWithoutProductsInput, UserUncheckedCreateWithoutProductsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProductsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProductsInput, UserUncheckedUpdateWithoutProductsInput>
  }

  export type UserUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendorReviewsReceived?: VendorReviewUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendorReviewsReceived?: VendorReviewUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUncheckedUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUncheckedUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUncheckedUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUncheckedUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUncheckedUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUncheckedUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUncheckedUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUncheckedUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUncheckedUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type ProductReviewUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductReviewWhereUniqueInput
    update: XOR<ProductReviewUpdateWithoutProductInput, ProductReviewUncheckedUpdateWithoutProductInput>
    create: XOR<ProductReviewCreateWithoutProductInput, ProductReviewUncheckedCreateWithoutProductInput>
  }

  export type ProductReviewUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductReviewWhereUniqueInput
    data: XOR<ProductReviewUpdateWithoutProductInput, ProductReviewUncheckedUpdateWithoutProductInput>
  }

  export type ProductReviewUpdateManyWithWhereWithoutProductInput = {
    where: ProductReviewScalarWhereInput
    data: XOR<ProductReviewUpdateManyMutationInput, ProductReviewUncheckedUpdateManyWithoutProductInput>
  }

  export type OrderUpsertWithWhereUniqueWithoutProductInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutProductInput, OrderUncheckedUpdateWithoutProductInput>
    create: XOR<OrderCreateWithoutProductInput, OrderUncheckedCreateWithoutProductInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutProductInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutProductInput, OrderUncheckedUpdateWithoutProductInput>
  }

  export type OrderUpdateManyWithWhereWithoutProductInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutProductInput>
  }

  export type OrderItemUpsertWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutProductInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutProductInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    unitPrice?: FloatFilter<"OrderItem"> | number
    subtotal?: FloatFilter<"OrderItem"> | number
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
  }

  export type ProductOptionUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductOptionWhereUniqueInput
    update: XOR<ProductOptionUpdateWithoutProductInput, ProductOptionUncheckedUpdateWithoutProductInput>
    create: XOR<ProductOptionCreateWithoutProductInput, ProductOptionUncheckedCreateWithoutProductInput>
  }

  export type ProductOptionUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductOptionWhereUniqueInput
    data: XOR<ProductOptionUpdateWithoutProductInput, ProductOptionUncheckedUpdateWithoutProductInput>
  }

  export type ProductOptionUpdateManyWithWhereWithoutProductInput = {
    where: ProductOptionScalarWhereInput
    data: XOR<ProductOptionUpdateManyMutationInput, ProductOptionUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductOptionScalarWhereInput = {
    AND?: ProductOptionScalarWhereInput | ProductOptionScalarWhereInput[]
    OR?: ProductOptionScalarWhereInput[]
    NOT?: ProductOptionScalarWhereInput | ProductOptionScalarWhereInput[]
    id?: StringFilter<"ProductOption"> | string
    productId?: StringFilter<"ProductOption"> | string
    name?: StringFilter<"ProductOption"> | string
    price?: FloatFilter<"ProductOption"> | number
  }

  export type CartItemUpsertWithWhereUniqueWithoutProductInput = {
    where: CartItemWhereUniqueInput
    update: XOR<CartItemUpdateWithoutProductInput, CartItemUncheckedUpdateWithoutProductInput>
    create: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput>
  }

  export type CartItemUpdateWithWhereUniqueWithoutProductInput = {
    where: CartItemWhereUniqueInput
    data: XOR<CartItemUpdateWithoutProductInput, CartItemUncheckedUpdateWithoutProductInput>
  }

  export type CartItemUpdateManyWithWhereWithoutProductInput = {
    where: CartItemScalarWhereInput
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyWithoutProductInput>
  }

  export type CartItemScalarWhereInput = {
    AND?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
    OR?: CartItemScalarWhereInput[]
    NOT?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
    id?: StringFilter<"CartItem"> | string
    cartId?: StringFilter<"CartItem"> | string
    productId?: StringFilter<"CartItem"> | string
    quantity?: IntFilter<"CartItem"> | number
    unitPrice?: FloatFilter<"CartItem"> | number
    subtotal?: FloatFilter<"CartItem"> | number
    specialRequest?: StringNullableFilter<"CartItem"> | string | null
  }

  export type SpecialOrderRequestUpsertWithWhereUniqueWithoutProductInput = {
    where: SpecialOrderRequestWhereUniqueInput
    update: XOR<SpecialOrderRequestUpdateWithoutProductInput, SpecialOrderRequestUncheckedUpdateWithoutProductInput>
    create: XOR<SpecialOrderRequestCreateWithoutProductInput, SpecialOrderRequestUncheckedCreateWithoutProductInput>
  }

  export type SpecialOrderRequestUpdateWithWhereUniqueWithoutProductInput = {
    where: SpecialOrderRequestWhereUniqueInput
    data: XOR<SpecialOrderRequestUpdateWithoutProductInput, SpecialOrderRequestUncheckedUpdateWithoutProductInput>
  }

  export type SpecialOrderRequestUpdateManyWithWhereWithoutProductInput = {
    where: SpecialOrderRequestScalarWhereInput
    data: XOR<SpecialOrderRequestUpdateManyMutationInput, SpecialOrderRequestUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductScheduleUpsertWithoutProductInput = {
    update: XOR<ProductScheduleUpdateWithoutProductInput, ProductScheduleUncheckedUpdateWithoutProductInput>
    create: XOR<ProductScheduleCreateWithoutProductInput, ProductScheduleUncheckedCreateWithoutProductInput>
    where?: ProductScheduleWhereInput
  }

  export type ProductScheduleUpdateToOneWithWhereWithoutProductInput = {
    where?: ProductScheduleWhereInput
    data: XOR<ProductScheduleUpdateWithoutProductInput, ProductScheduleUncheckedUpdateWithoutProductInput>
  }

  export type ProductScheduleUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    goLiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    takeDownAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLive?: BoolFieldUpdateOperationsInput | boolean
    graceMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    autoGraceEnabled?: BoolFieldUpdateOperationsInput | boolean
    manualGraceEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductScheduleUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    goLiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    takeDownAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLive?: BoolFieldUpdateOperationsInput | boolean
    graceMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    autoGraceEnabled?: BoolFieldUpdateOperationsInput | boolean
    manualGraceEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateWithoutProductScheduleInput = {
    id?: string
    name: string
    description: string
    price: number
    archived?: boolean
    category: $Enums.Category
    images?: ProductCreateimagesInput | string[]
    thumbnail?: string | null
    video?: ProductCreatevideoInput | string[]
    averageRating?: number | null
    reviewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    totalViews?: number
    popularityScore?: number
    popularityUpdatedAt?: Date | string | null
    popularityPercent?: number
    isNew?: boolean
    isLive?: boolean
    liveUntil?: Date | string | null
    vendor: UserCreateNestedOneWithoutProductsInput
    reviews?: ProductReviewCreateNestedManyWithoutProductInput
    orders?: OrderCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    options?: ProductOptionCreateNestedManyWithoutProductInput
    CartItem?: CartItemCreateNestedManyWithoutProductInput
    specialRequests?: SpecialOrderRequestCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductScheduleInput = {
    id?: string
    name: string
    description: string
    price: number
    archived?: boolean
    category: $Enums.Category
    images?: ProductCreateimagesInput | string[]
    thumbnail?: string | null
    video?: ProductCreatevideoInput | string[]
    vendorId: string
    averageRating?: number | null
    reviewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    totalViews?: number
    popularityScore?: number
    popularityUpdatedAt?: Date | string | null
    popularityPercent?: number
    isNew?: boolean
    isLive?: boolean
    liveUntil?: Date | string | null
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    orders?: OrderUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    options?: ProductOptionUncheckedCreateNestedManyWithoutProductInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductInput
    specialRequests?: SpecialOrderRequestUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductScheduleInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductScheduleInput, ProductUncheckedCreateWithoutProductScheduleInput>
  }

  export type ProductUpsertWithoutProductScheduleInput = {
    update: XOR<ProductUpdateWithoutProductScheduleInput, ProductUncheckedUpdateWithoutProductScheduleInput>
    create: XOR<ProductCreateWithoutProductScheduleInput, ProductUncheckedCreateWithoutProductScheduleInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProductScheduleInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProductScheduleInput, ProductUncheckedUpdateWithoutProductScheduleInput>
  }

  export type ProductUpdateWithoutProductScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    images?: ProductUpdateimagesInput | string[]
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    video?: ProductUpdatevideoInput | string[]
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalViews?: IntFieldUpdateOperationsInput | number
    popularityScore?: FloatFieldUpdateOperationsInput | number
    popularityUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    popularityPercent?: FloatFieldUpdateOperationsInput | number
    isNew?: BoolFieldUpdateOperationsInput | boolean
    isLive?: BoolFieldUpdateOperationsInput | boolean
    liveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendor?: UserUpdateOneRequiredWithoutProductsNestedInput
    reviews?: ProductReviewUpdateManyWithoutProductNestedInput
    orders?: OrderUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    options?: ProductOptionUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUpdateManyWithoutProductNestedInput
    specialRequests?: SpecialOrderRequestUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    images?: ProductUpdateimagesInput | string[]
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    video?: ProductUpdatevideoInput | string[]
    vendorId?: StringFieldUpdateOperationsInput | string
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalViews?: IntFieldUpdateOperationsInput | number
    popularityScore?: FloatFieldUpdateOperationsInput | number
    popularityUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    popularityPercent?: FloatFieldUpdateOperationsInput | number
    isNew?: BoolFieldUpdateOperationsInput | boolean
    isLive?: BoolFieldUpdateOperationsInput | boolean
    liveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviews?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    options?: ProductOptionUncheckedUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    specialRequests?: SpecialOrderRequestUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateWithoutOptionsInput = {
    id?: string
    name: string
    description: string
    price: number
    archived?: boolean
    category: $Enums.Category
    images?: ProductCreateimagesInput | string[]
    thumbnail?: string | null
    video?: ProductCreatevideoInput | string[]
    averageRating?: number | null
    reviewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    totalViews?: number
    popularityScore?: number
    popularityUpdatedAt?: Date | string | null
    popularityPercent?: number
    isNew?: boolean
    isLive?: boolean
    liveUntil?: Date | string | null
    vendor: UserCreateNestedOneWithoutProductsInput
    reviews?: ProductReviewCreateNestedManyWithoutProductInput
    orders?: OrderCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    CartItem?: CartItemCreateNestedManyWithoutProductInput
    specialRequests?: SpecialOrderRequestCreateNestedManyWithoutProductInput
    productSchedule?: ProductScheduleCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOptionsInput = {
    id?: string
    name: string
    description: string
    price: number
    archived?: boolean
    category: $Enums.Category
    images?: ProductCreateimagesInput | string[]
    thumbnail?: string | null
    video?: ProductCreatevideoInput | string[]
    vendorId: string
    averageRating?: number | null
    reviewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    totalViews?: number
    popularityScore?: number
    popularityUpdatedAt?: Date | string | null
    popularityPercent?: number
    isNew?: boolean
    isLive?: boolean
    liveUntil?: Date | string | null
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    orders?: OrderUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductInput
    specialRequests?: SpecialOrderRequestUncheckedCreateNestedManyWithoutProductInput
    productSchedule?: ProductScheduleUncheckedCreateNestedOneWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOptionsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOptionsInput, ProductUncheckedCreateWithoutOptionsInput>
  }

  export type OrderItemOptionCreateWithoutProductOptionInput = {
    id?: string
    name: string
    price: number
    orderItem: OrderItemCreateNestedOneWithoutOptionsInput
  }

  export type OrderItemOptionUncheckedCreateWithoutProductOptionInput = {
    id?: string
    name: string
    price: number
    orderItemId: string
  }

  export type OrderItemOptionCreateOrConnectWithoutProductOptionInput = {
    where: OrderItemOptionWhereUniqueInput
    create: XOR<OrderItemOptionCreateWithoutProductOptionInput, OrderItemOptionUncheckedCreateWithoutProductOptionInput>
  }

  export type OrderItemOptionCreateManyProductOptionInputEnvelope = {
    data: OrderItemOptionCreateManyProductOptionInput | OrderItemOptionCreateManyProductOptionInput[]
    skipDuplicates?: boolean
  }

  export type CartItemOptionCreateWithoutProductOptionInput = {
    id?: string
    name: string
    price: number
    cartItem: CartItemCreateNestedOneWithoutOptionsInput
  }

  export type CartItemOptionUncheckedCreateWithoutProductOptionInput = {
    id?: string
    cartItemId: string
    name: string
    price: number
  }

  export type CartItemOptionCreateOrConnectWithoutProductOptionInput = {
    where: CartItemOptionWhereUniqueInput
    create: XOR<CartItemOptionCreateWithoutProductOptionInput, CartItemOptionUncheckedCreateWithoutProductOptionInput>
  }

  export type CartItemOptionCreateManyProductOptionInputEnvelope = {
    data: CartItemOptionCreateManyProductOptionInput | CartItemOptionCreateManyProductOptionInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithoutOptionsInput = {
    update: XOR<ProductUpdateWithoutOptionsInput, ProductUncheckedUpdateWithoutOptionsInput>
    create: XOR<ProductCreateWithoutOptionsInput, ProductUncheckedCreateWithoutOptionsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutOptionsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutOptionsInput, ProductUncheckedUpdateWithoutOptionsInput>
  }

  export type ProductUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    images?: ProductUpdateimagesInput | string[]
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    video?: ProductUpdatevideoInput | string[]
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalViews?: IntFieldUpdateOperationsInput | number
    popularityScore?: FloatFieldUpdateOperationsInput | number
    popularityUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    popularityPercent?: FloatFieldUpdateOperationsInput | number
    isNew?: BoolFieldUpdateOperationsInput | boolean
    isLive?: BoolFieldUpdateOperationsInput | boolean
    liveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendor?: UserUpdateOneRequiredWithoutProductsNestedInput
    reviews?: ProductReviewUpdateManyWithoutProductNestedInput
    orders?: OrderUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUpdateManyWithoutProductNestedInput
    specialRequests?: SpecialOrderRequestUpdateManyWithoutProductNestedInput
    productSchedule?: ProductScheduleUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    images?: ProductUpdateimagesInput | string[]
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    video?: ProductUpdatevideoInput | string[]
    vendorId?: StringFieldUpdateOperationsInput | string
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalViews?: IntFieldUpdateOperationsInput | number
    popularityScore?: FloatFieldUpdateOperationsInput | number
    popularityUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    popularityPercent?: FloatFieldUpdateOperationsInput | number
    isNew?: BoolFieldUpdateOperationsInput | boolean
    isLive?: BoolFieldUpdateOperationsInput | boolean
    liveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviews?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    specialRequests?: SpecialOrderRequestUncheckedUpdateManyWithoutProductNestedInput
    productSchedule?: ProductScheduleUncheckedUpdateOneWithoutProductNestedInput
  }

  export type OrderItemOptionUpsertWithWhereUniqueWithoutProductOptionInput = {
    where: OrderItemOptionWhereUniqueInput
    update: XOR<OrderItemOptionUpdateWithoutProductOptionInput, OrderItemOptionUncheckedUpdateWithoutProductOptionInput>
    create: XOR<OrderItemOptionCreateWithoutProductOptionInput, OrderItemOptionUncheckedCreateWithoutProductOptionInput>
  }

  export type OrderItemOptionUpdateWithWhereUniqueWithoutProductOptionInput = {
    where: OrderItemOptionWhereUniqueInput
    data: XOR<OrderItemOptionUpdateWithoutProductOptionInput, OrderItemOptionUncheckedUpdateWithoutProductOptionInput>
  }

  export type OrderItemOptionUpdateManyWithWhereWithoutProductOptionInput = {
    where: OrderItemOptionScalarWhereInput
    data: XOR<OrderItemOptionUpdateManyMutationInput, OrderItemOptionUncheckedUpdateManyWithoutProductOptionInput>
  }

  export type OrderItemOptionScalarWhereInput = {
    AND?: OrderItemOptionScalarWhereInput | OrderItemOptionScalarWhereInput[]
    OR?: OrderItemOptionScalarWhereInput[]
    NOT?: OrderItemOptionScalarWhereInput | OrderItemOptionScalarWhereInput[]
    id?: StringFilter<"OrderItemOption"> | string
    optionId?: StringFilter<"OrderItemOption"> | string
    name?: StringFilter<"OrderItemOption"> | string
    price?: FloatFilter<"OrderItemOption"> | number
    orderItemId?: StringFilter<"OrderItemOption"> | string
  }

  export type CartItemOptionUpsertWithWhereUniqueWithoutProductOptionInput = {
    where: CartItemOptionWhereUniqueInput
    update: XOR<CartItemOptionUpdateWithoutProductOptionInput, CartItemOptionUncheckedUpdateWithoutProductOptionInput>
    create: XOR<CartItemOptionCreateWithoutProductOptionInput, CartItemOptionUncheckedCreateWithoutProductOptionInput>
  }

  export type CartItemOptionUpdateWithWhereUniqueWithoutProductOptionInput = {
    where: CartItemOptionWhereUniqueInput
    data: XOR<CartItemOptionUpdateWithoutProductOptionInput, CartItemOptionUncheckedUpdateWithoutProductOptionInput>
  }

  export type CartItemOptionUpdateManyWithWhereWithoutProductOptionInput = {
    where: CartItemOptionScalarWhereInput
    data: XOR<CartItemOptionUpdateManyMutationInput, CartItemOptionUncheckedUpdateManyWithoutProductOptionInput>
  }

  export type CartItemOptionScalarWhereInput = {
    AND?: CartItemOptionScalarWhereInput | CartItemOptionScalarWhereInput[]
    OR?: CartItemOptionScalarWhereInput[]
    NOT?: CartItemOptionScalarWhereInput | CartItemOptionScalarWhereInput[]
    id?: StringFilter<"CartItemOption"> | string
    cartItemId?: StringFilter<"CartItemOption"> | string
    productOptionId?: StringFilter<"CartItemOption"> | string
    name?: StringFilter<"CartItemOption"> | string
    price?: FloatFilter<"CartItemOption"> | number
  }

  export type UserCreateWithoutCustomerOrdersInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerCreateNestedManyWithoutVendorInput
    following?: VendorFollowerCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateWithoutCustomerOrdersInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewUncheckedCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewUncheckedCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderUncheckedCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyUncheckedCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonUncheckedCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestUncheckedCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityUncheckedCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityUncheckedCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerUncheckedCreateNestedManyWithoutVendorInput
    following?: VendorFollowerUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserCreateOrConnectWithoutCustomerOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCustomerOrdersInput, UserUncheckedCreateWithoutCustomerOrdersInput>
  }

  export type UserCreateWithoutVendorOrdersInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderCreateNestedManyWithoutCustomerInput
    vendorRepliesSent?: VendorReplyCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerCreateNestedManyWithoutVendorInput
    following?: VendorFollowerCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateWithoutVendorOrdersInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewUncheckedCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewUncheckedCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    vendorRepliesSent?: VendorReplyUncheckedCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonUncheckedCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestUncheckedCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityUncheckedCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityUncheckedCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerUncheckedCreateNestedManyWithoutVendorInput
    following?: VendorFollowerUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserCreateOrConnectWithoutVendorOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVendorOrdersInput, UserUncheckedCreateWithoutVendorOrdersInput>
  }

  export type AddressCreateWithoutOrdersInput = {
    id?: string
    label: string
    street: string
    city: string
    state?: string | null
    country: string
    zipCode?: string | null
    landmark?: string | null
    latitude?: number | null
    longitude?: number | null
    isDefault?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAddressesInput
  }

  export type AddressUncheckedCreateWithoutOrdersInput = {
    id?: string
    userId: string
    label: string
    street: string
    city: string
    state?: string | null
    country: string
    zipCode?: string | null
    landmark?: string | null
    latitude?: number | null
    longitude?: number | null
    isDefault?: boolean
    createdAt?: Date | string
  }

  export type AddressCreateOrConnectWithoutOrdersInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutOrdersInput, AddressUncheckedCreateWithoutOrdersInput>
  }

  export type OrderItemCreateWithoutOrderInput = {
    id?: string
    quantity: number
    unitPrice: number
    subtotal: number
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutOrderItemsInput
    options?: OrderItemOptionCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: string
    productId: string
    quantity: number
    unitPrice: number
    subtotal: number
    createdAt?: Date | string
    options?: OrderItemOptionUncheckedCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutOrderInput = {
    id?: string
    amount: number
    reference: string
    status: string
    paystackData?: NullableJsonNullValueInput | InputJsonValue
    channel?: string | null
    ipAddress?: string
    userAgent?: string
    deviceId?: string | null
    geoCity?: string | null
    geoCountry?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    user: UserCreateNestedOneWithoutPaymentsInput
    Receipt?: ReceiptCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutOrderInput = {
    id?: string
    userId: string
    amount: number
    reference: string
    status: string
    paystackData?: NullableJsonNullValueInput | InputJsonValue
    channel?: string | null
    ipAddress?: string
    userAgent?: string
    deviceId?: string | null
    geoCity?: string | null
    geoCountry?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    Receipt?: ReceiptUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
  }

  export type PaymentCreateManyOrderInputEnvelope = {
    data: PaymentCreateManyOrderInput | PaymentCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutOrdersInput = {
    id?: string
    name: string
    description: string
    price: number
    archived?: boolean
    category: $Enums.Category
    images?: ProductCreateimagesInput | string[]
    thumbnail?: string | null
    video?: ProductCreatevideoInput | string[]
    averageRating?: number | null
    reviewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    totalViews?: number
    popularityScore?: number
    popularityUpdatedAt?: Date | string | null
    popularityPercent?: number
    isNew?: boolean
    isLive?: boolean
    liveUntil?: Date | string | null
    vendor: UserCreateNestedOneWithoutProductsInput
    reviews?: ProductReviewCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    options?: ProductOptionCreateNestedManyWithoutProductInput
    CartItem?: CartItemCreateNestedManyWithoutProductInput
    specialRequests?: SpecialOrderRequestCreateNestedManyWithoutProductInput
    productSchedule?: ProductScheduleCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOrdersInput = {
    id?: string
    name: string
    description: string
    price: number
    archived?: boolean
    category: $Enums.Category
    images?: ProductCreateimagesInput | string[]
    thumbnail?: string | null
    video?: ProductCreatevideoInput | string[]
    vendorId: string
    averageRating?: number | null
    reviewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    totalViews?: number
    popularityScore?: number
    popularityUpdatedAt?: Date | string | null
    popularityPercent?: number
    isNew?: boolean
    isLive?: boolean
    liveUntil?: Date | string | null
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    options?: ProductOptionUncheckedCreateNestedManyWithoutProductInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductInput
    specialRequests?: SpecialOrderRequestUncheckedCreateNestedManyWithoutProductInput
    productSchedule?: ProductScheduleUncheckedCreateNestedOneWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOrdersInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrdersInput, ProductUncheckedCreateWithoutOrdersInput>
  }

  export type DeliveryAssignmentCreateWithoutOrderInput = {
    id?: string
    status?: $Enums.DeliveryStatus
    assignedAt?: Date | string
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    declinedAt?: Date | string | null
    timeoutSeconds?: number
    attempts?: number
    batchId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveryPerson: DeliveryPersonCreateNestedOneWithoutAssignedOrdersInput
  }

  export type DeliveryAssignmentUncheckedCreateWithoutOrderInput = {
    id?: string
    deliveryPersonId: string
    status?: $Enums.DeliveryStatus
    assignedAt?: Date | string
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    declinedAt?: Date | string | null
    timeoutSeconds?: number
    attempts?: number
    batchId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryAssignmentCreateOrConnectWithoutOrderInput = {
    where: DeliveryAssignmentWhereUniqueInput
    create: XOR<DeliveryAssignmentCreateWithoutOrderInput, DeliveryAssignmentUncheckedCreateWithoutOrderInput>
  }

  export type DeliveryAssignmentCreateManyOrderInputEnvelope = {
    data: DeliveryAssignmentCreateManyOrderInput | DeliveryAssignmentCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryEarningCreateWithoutOrderInput = {
    id?: string
    baseFee: number
    distanceFee: number
    tip?: number
    deductions?: number
    totalEarned: number
    createdAt?: Date | string
    deliveryPerson: DeliveryPersonCreateNestedOneWithoutEarningsInput
  }

  export type DeliveryEarningUncheckedCreateWithoutOrderInput = {
    id?: string
    deliveryPersonId: string
    baseFee: number
    distanceFee: number
    tip?: number
    deductions?: number
    totalEarned: number
    createdAt?: Date | string
  }

  export type DeliveryEarningCreateOrConnectWithoutOrderInput = {
    where: DeliveryEarningWhereUniqueInput
    create: XOR<DeliveryEarningCreateWithoutOrderInput, DeliveryEarningUncheckedCreateWithoutOrderInput>
  }

  export type DeliveryEarningCreateManyOrderInputEnvelope = {
    data: DeliveryEarningCreateManyOrderInput | DeliveryEarningCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutOrderInput = {
    id?: string
    type: $Enums.ActivityType
    title: string
    message: string
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    vendor?: UserCreateNestedOneWithoutVendorActivitiesInput
    customer?: UserCreateNestedOneWithoutCustomerActivitiesInput
    delivery?: DeliveryPersonCreateNestedOneWithoutActivityInput
  }

  export type ActivityUncheckedCreateWithoutOrderInput = {
    id?: string
    vendorId?: string | null
    customerId?: string | null
    deliveryId?: string | null
    type: $Enums.ActivityType
    title: string
    message: string
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ActivityCreateOrConnectWithoutOrderInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutOrderInput, ActivityUncheckedCreateWithoutOrderInput>
  }

  export type ActivityCreateManyOrderInputEnvelope = {
    data: ActivityCreateManyOrderInput | ActivityCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryBroadcastCreateWithoutOrderInput = {
    id?: string
    driverIds?: DeliveryBroadcastCreatedriverIdsInput | string[]
    acceptedDriverId?: string | null
    status: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryBroadcastUncheckedCreateWithoutOrderInput = {
    id?: string
    driverIds?: DeliveryBroadcastCreatedriverIdsInput | string[]
    acceptedDriverId?: string | null
    status: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryBroadcastCreateOrConnectWithoutOrderInput = {
    where: DeliveryBroadcastWhereUniqueInput
    create: XOR<DeliveryBroadcastCreateWithoutOrderInput, DeliveryBroadcastUncheckedCreateWithoutOrderInput>
  }

  export type DeliveryBroadcastCreateManyOrderInputEnvelope = {
    data: DeliveryBroadcastCreateManyOrderInput | DeliveryBroadcastCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCustomerOrdersInput = {
    update: XOR<UserUpdateWithoutCustomerOrdersInput, UserUncheckedUpdateWithoutCustomerOrdersInput>
    create: XOR<UserCreateWithoutCustomerOrdersInput, UserUncheckedCreateWithoutCustomerOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCustomerOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCustomerOrdersInput, UserUncheckedUpdateWithoutCustomerOrdersInput>
  }

  export type UserUpdateWithoutCustomerOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateWithoutCustomerOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUncheckedUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUncheckedUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUncheckedUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUncheckedUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUncheckedUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUncheckedUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUncheckedUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUncheckedUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUncheckedUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type UserUpsertWithoutVendorOrdersInput = {
    update: XOR<UserUpdateWithoutVendorOrdersInput, UserUncheckedUpdateWithoutVendorOrdersInput>
    create: XOR<UserCreateWithoutVendorOrdersInput, UserUncheckedCreateWithoutVendorOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVendorOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVendorOrdersInput, UserUncheckedUpdateWithoutVendorOrdersInput>
  }

  export type UserUpdateWithoutVendorOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUpdateManyWithoutCustomerNestedInput
    vendorRepliesSent?: VendorReplyUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateWithoutVendorOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUncheckedUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUncheckedUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    vendorRepliesSent?: VendorReplyUncheckedUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUncheckedUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUncheckedUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUncheckedUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUncheckedUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUncheckedUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type AddressUpsertWithoutOrdersInput = {
    update: XOR<AddressUpdateWithoutOrdersInput, AddressUncheckedUpdateWithoutOrdersInput>
    create: XOR<AddressCreateWithoutOrdersInput, AddressUncheckedCreateWithoutOrdersInput>
    where?: AddressWhereInput
  }

  export type AddressUpdateToOneWithWhereWithoutOrdersInput = {
    where?: AddressWhereInput
    data: XOR<AddressUpdateWithoutOrdersInput, AddressUncheckedUpdateWithoutOrdersInput>
  }

  export type AddressUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAddressesNestedInput
  }

  export type AddressUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
  }

  export type PaymentUpdateManyWithWhereWithoutOrderInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutOrderInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutOrdersInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutOrdersInput, ProductUncheckedUpdateWithoutOrdersInput>
    create: XOR<ProductCreateWithoutOrdersInput, ProductUncheckedCreateWithoutOrdersInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutOrdersInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutOrdersInput, ProductUncheckedUpdateWithoutOrdersInput>
  }

  export type ProductUpdateManyWithWhereWithoutOrdersInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutOrdersInput>
  }

  export type DeliveryAssignmentUpsertWithWhereUniqueWithoutOrderInput = {
    where: DeliveryAssignmentWhereUniqueInput
    update: XOR<DeliveryAssignmentUpdateWithoutOrderInput, DeliveryAssignmentUncheckedUpdateWithoutOrderInput>
    create: XOR<DeliveryAssignmentCreateWithoutOrderInput, DeliveryAssignmentUncheckedCreateWithoutOrderInput>
  }

  export type DeliveryAssignmentUpdateWithWhereUniqueWithoutOrderInput = {
    where: DeliveryAssignmentWhereUniqueInput
    data: XOR<DeliveryAssignmentUpdateWithoutOrderInput, DeliveryAssignmentUncheckedUpdateWithoutOrderInput>
  }

  export type DeliveryAssignmentUpdateManyWithWhereWithoutOrderInput = {
    where: DeliveryAssignmentScalarWhereInput
    data: XOR<DeliveryAssignmentUpdateManyMutationInput, DeliveryAssignmentUncheckedUpdateManyWithoutOrderInput>
  }

  export type DeliveryAssignmentScalarWhereInput = {
    AND?: DeliveryAssignmentScalarWhereInput | DeliveryAssignmentScalarWhereInput[]
    OR?: DeliveryAssignmentScalarWhereInput[]
    NOT?: DeliveryAssignmentScalarWhereInput | DeliveryAssignmentScalarWhereInput[]
    id?: StringFilter<"DeliveryAssignment"> | string
    orderId?: StringFilter<"DeliveryAssignment"> | string
    deliveryPersonId?: StringFilter<"DeliveryAssignment"> | string
    status?: EnumDeliveryStatusFilter<"DeliveryAssignment"> | $Enums.DeliveryStatus
    assignedAt?: DateTimeFilter<"DeliveryAssignment"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"DeliveryAssignment"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"DeliveryAssignment"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"DeliveryAssignment"> | Date | string | null
    declinedAt?: DateTimeNullableFilter<"DeliveryAssignment"> | Date | string | null
    timeoutSeconds?: IntFilter<"DeliveryAssignment"> | number
    attempts?: IntFilter<"DeliveryAssignment"> | number
    batchId?: StringNullableFilter<"DeliveryAssignment"> | string | null
    createdAt?: DateTimeFilter<"DeliveryAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryAssignment"> | Date | string
  }

  export type DeliveryEarningUpsertWithWhereUniqueWithoutOrderInput = {
    where: DeliveryEarningWhereUniqueInput
    update: XOR<DeliveryEarningUpdateWithoutOrderInput, DeliveryEarningUncheckedUpdateWithoutOrderInput>
    create: XOR<DeliveryEarningCreateWithoutOrderInput, DeliveryEarningUncheckedCreateWithoutOrderInput>
  }

  export type DeliveryEarningUpdateWithWhereUniqueWithoutOrderInput = {
    where: DeliveryEarningWhereUniqueInput
    data: XOR<DeliveryEarningUpdateWithoutOrderInput, DeliveryEarningUncheckedUpdateWithoutOrderInput>
  }

  export type DeliveryEarningUpdateManyWithWhereWithoutOrderInput = {
    where: DeliveryEarningScalarWhereInput
    data: XOR<DeliveryEarningUpdateManyMutationInput, DeliveryEarningUncheckedUpdateManyWithoutOrderInput>
  }

  export type DeliveryEarningScalarWhereInput = {
    AND?: DeliveryEarningScalarWhereInput | DeliveryEarningScalarWhereInput[]
    OR?: DeliveryEarningScalarWhereInput[]
    NOT?: DeliveryEarningScalarWhereInput | DeliveryEarningScalarWhereInput[]
    id?: StringFilter<"DeliveryEarning"> | string
    deliveryPersonId?: StringFilter<"DeliveryEarning"> | string
    orderId?: StringFilter<"DeliveryEarning"> | string
    baseFee?: FloatFilter<"DeliveryEarning"> | number
    distanceFee?: FloatFilter<"DeliveryEarning"> | number
    tip?: FloatFilter<"DeliveryEarning"> | number
    deductions?: FloatFilter<"DeliveryEarning"> | number
    totalEarned?: FloatFilter<"DeliveryEarning"> | number
    createdAt?: DateTimeFilter<"DeliveryEarning"> | Date | string
  }

  export type ActivityUpsertWithWhereUniqueWithoutOrderInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutOrderInput, ActivityUncheckedUpdateWithoutOrderInput>
    create: XOR<ActivityCreateWithoutOrderInput, ActivityUncheckedCreateWithoutOrderInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutOrderInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutOrderInput, ActivityUncheckedUpdateWithoutOrderInput>
  }

  export type ActivityUpdateManyWithWhereWithoutOrderInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutOrderInput>
  }

  export type DeliveryBroadcastUpsertWithWhereUniqueWithoutOrderInput = {
    where: DeliveryBroadcastWhereUniqueInput
    update: XOR<DeliveryBroadcastUpdateWithoutOrderInput, DeliveryBroadcastUncheckedUpdateWithoutOrderInput>
    create: XOR<DeliveryBroadcastCreateWithoutOrderInput, DeliveryBroadcastUncheckedCreateWithoutOrderInput>
  }

  export type DeliveryBroadcastUpdateWithWhereUniqueWithoutOrderInput = {
    where: DeliveryBroadcastWhereUniqueInput
    data: XOR<DeliveryBroadcastUpdateWithoutOrderInput, DeliveryBroadcastUncheckedUpdateWithoutOrderInput>
  }

  export type DeliveryBroadcastUpdateManyWithWhereWithoutOrderInput = {
    where: DeliveryBroadcastScalarWhereInput
    data: XOR<DeliveryBroadcastUpdateManyMutationInput, DeliveryBroadcastUncheckedUpdateManyWithoutOrderInput>
  }

  export type DeliveryBroadcastScalarWhereInput = {
    AND?: DeliveryBroadcastScalarWhereInput | DeliveryBroadcastScalarWhereInput[]
    OR?: DeliveryBroadcastScalarWhereInput[]
    NOT?: DeliveryBroadcastScalarWhereInput | DeliveryBroadcastScalarWhereInput[]
    id?: StringFilter<"DeliveryBroadcast"> | string
    orderId?: StringFilter<"DeliveryBroadcast"> | string
    driverIds?: StringNullableListFilter<"DeliveryBroadcast">
    acceptedDriverId?: StringNullableFilter<"DeliveryBroadcast"> | string | null
    status?: StringFilter<"DeliveryBroadcast"> | string
    expiresAt?: DateTimeFilter<"DeliveryBroadcast"> | Date | string
    createdAt?: DateTimeFilter<"DeliveryBroadcast"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryBroadcast"> | Date | string
  }

  export type OrderCreateWithoutItemsInput = {
    id?: string
    basePrice: number
    extraCharge?: number
    totalPrice: number
    vendorNote?: string | null
    customerApproval?: boolean
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentInitiatedAt?: Date | string | null
    paymentStartedAt?: Date | string | null
    paidAt?: Date | string | null
    paymentStatus?: $Enums.PaymentStatus | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    protectedUntil?: Date | string | null
    paymentGraceMinutes?: number | null
    customer: UserCreateNestedOneWithoutCustomerOrdersInput
    vendor: UserCreateNestedOneWithoutVendorOrdersInput
    address?: AddressCreateNestedOneWithoutOrdersInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    Product?: ProductCreateNestedManyWithoutOrdersInput
    assignments?: DeliveryAssignmentCreateNestedManyWithoutOrderInput
    earnings?: DeliveryEarningCreateNestedManyWithoutOrderInput
    Activity?: ActivityCreateNestedManyWithoutOrderInput
    DeliveryBroadcast?: DeliveryBroadcastCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutItemsInput = {
    id?: string
    customerId: string
    vendorId: string
    addressId?: string | null
    basePrice: number
    extraCharge?: number
    totalPrice: number
    vendorNote?: string | null
    customerApproval?: boolean
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentInitiatedAt?: Date | string | null
    paymentStartedAt?: Date | string | null
    paidAt?: Date | string | null
    paymentStatus?: $Enums.PaymentStatus | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    protectedUntil?: Date | string | null
    paymentGraceMinutes?: number | null
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    Product?: ProductUncheckedCreateNestedManyWithoutOrdersInput
    assignments?: DeliveryAssignmentUncheckedCreateNestedManyWithoutOrderInput
    earnings?: DeliveryEarningUncheckedCreateNestedManyWithoutOrderInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutOrderInput
    DeliveryBroadcast?: DeliveryBroadcastUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutOrderItemsInput = {
    id?: string
    name: string
    description: string
    price: number
    archived?: boolean
    category: $Enums.Category
    images?: ProductCreateimagesInput | string[]
    thumbnail?: string | null
    video?: ProductCreatevideoInput | string[]
    averageRating?: number | null
    reviewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    totalViews?: number
    popularityScore?: number
    popularityUpdatedAt?: Date | string | null
    popularityPercent?: number
    isNew?: boolean
    isLive?: boolean
    liveUntil?: Date | string | null
    vendor: UserCreateNestedOneWithoutProductsInput
    reviews?: ProductReviewCreateNestedManyWithoutProductInput
    orders?: OrderCreateNestedManyWithoutProductInput
    options?: ProductOptionCreateNestedManyWithoutProductInput
    CartItem?: CartItemCreateNestedManyWithoutProductInput
    specialRequests?: SpecialOrderRequestCreateNestedManyWithoutProductInput
    productSchedule?: ProductScheduleCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    name: string
    description: string
    price: number
    archived?: boolean
    category: $Enums.Category
    images?: ProductCreateimagesInput | string[]
    thumbnail?: string | null
    video?: ProductCreatevideoInput | string[]
    vendorId: string
    averageRating?: number | null
    reviewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    totalViews?: number
    popularityScore?: number
    popularityUpdatedAt?: Date | string | null
    popularityPercent?: number
    isNew?: boolean
    isLive?: boolean
    liveUntil?: Date | string | null
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    orders?: OrderUncheckedCreateNestedManyWithoutProductInput
    options?: ProductOptionUncheckedCreateNestedManyWithoutProductInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductInput
    specialRequests?: SpecialOrderRequestUncheckedCreateNestedManyWithoutProductInput
    productSchedule?: ProductScheduleUncheckedCreateNestedOneWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOrderItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
  }

  export type OrderItemOptionCreateWithoutOrderItemInput = {
    id?: string
    name: string
    price: number
    productOption: ProductOptionCreateNestedOneWithoutOrderItemOptionInput
  }

  export type OrderItemOptionUncheckedCreateWithoutOrderItemInput = {
    id?: string
    optionId: string
    name: string
    price: number
  }

  export type OrderItemOptionCreateOrConnectWithoutOrderItemInput = {
    where: OrderItemOptionWhereUniqueInput
    create: XOR<OrderItemOptionCreateWithoutOrderItemInput, OrderItemOptionUncheckedCreateWithoutOrderItemInput>
  }

  export type OrderItemOptionCreateManyOrderItemInputEnvelope = {
    data: OrderItemOptionCreateManyOrderItemInput | OrderItemOptionCreateManyOrderItemInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithoutItemsInput = {
    update: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type OrderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraCharge?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    vendorNote?: NullableStringFieldUpdateOperationsInput | string | null
    customerApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentInitiatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    protectedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGraceMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    customer?: UserUpdateOneRequiredWithoutCustomerOrdersNestedInput
    vendor?: UserUpdateOneRequiredWithoutVendorOrdersNestedInput
    address?: AddressUpdateOneWithoutOrdersNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    Product?: ProductUpdateManyWithoutOrdersNestedInput
    assignments?: DeliveryAssignmentUpdateManyWithoutOrderNestedInput
    earnings?: DeliveryEarningUpdateManyWithoutOrderNestedInput
    Activity?: ActivityUpdateManyWithoutOrderNestedInput
    DeliveryBroadcast?: DeliveryBroadcastUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraCharge?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    vendorNote?: NullableStringFieldUpdateOperationsInput | string | null
    customerApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentInitiatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    protectedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGraceMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    Product?: ProductUncheckedUpdateManyWithoutOrdersNestedInput
    assignments?: DeliveryAssignmentUncheckedUpdateManyWithoutOrderNestedInput
    earnings?: DeliveryEarningUncheckedUpdateManyWithoutOrderNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutOrderNestedInput
    DeliveryBroadcast?: DeliveryBroadcastUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ProductUpsertWithoutOrderItemsInput = {
    update: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    images?: ProductUpdateimagesInput | string[]
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    video?: ProductUpdatevideoInput | string[]
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalViews?: IntFieldUpdateOperationsInput | number
    popularityScore?: FloatFieldUpdateOperationsInput | number
    popularityUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    popularityPercent?: FloatFieldUpdateOperationsInput | number
    isNew?: BoolFieldUpdateOperationsInput | boolean
    isLive?: BoolFieldUpdateOperationsInput | boolean
    liveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendor?: UserUpdateOneRequiredWithoutProductsNestedInput
    reviews?: ProductReviewUpdateManyWithoutProductNestedInput
    orders?: OrderUpdateManyWithoutProductNestedInput
    options?: ProductOptionUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUpdateManyWithoutProductNestedInput
    specialRequests?: SpecialOrderRequestUpdateManyWithoutProductNestedInput
    productSchedule?: ProductScheduleUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    images?: ProductUpdateimagesInput | string[]
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    video?: ProductUpdatevideoInput | string[]
    vendorId?: StringFieldUpdateOperationsInput | string
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalViews?: IntFieldUpdateOperationsInput | number
    popularityScore?: FloatFieldUpdateOperationsInput | number
    popularityUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    popularityPercent?: FloatFieldUpdateOperationsInput | number
    isNew?: BoolFieldUpdateOperationsInput | boolean
    isLive?: BoolFieldUpdateOperationsInput | boolean
    liveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviews?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProductNestedInput
    options?: ProductOptionUncheckedUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    specialRequests?: SpecialOrderRequestUncheckedUpdateManyWithoutProductNestedInput
    productSchedule?: ProductScheduleUncheckedUpdateOneWithoutProductNestedInput
  }

  export type OrderItemOptionUpsertWithWhereUniqueWithoutOrderItemInput = {
    where: OrderItemOptionWhereUniqueInput
    update: XOR<OrderItemOptionUpdateWithoutOrderItemInput, OrderItemOptionUncheckedUpdateWithoutOrderItemInput>
    create: XOR<OrderItemOptionCreateWithoutOrderItemInput, OrderItemOptionUncheckedCreateWithoutOrderItemInput>
  }

  export type OrderItemOptionUpdateWithWhereUniqueWithoutOrderItemInput = {
    where: OrderItemOptionWhereUniqueInput
    data: XOR<OrderItemOptionUpdateWithoutOrderItemInput, OrderItemOptionUncheckedUpdateWithoutOrderItemInput>
  }

  export type OrderItemOptionUpdateManyWithWhereWithoutOrderItemInput = {
    where: OrderItemOptionScalarWhereInput
    data: XOR<OrderItemOptionUpdateManyMutationInput, OrderItemOptionUncheckedUpdateManyWithoutOrderItemInput>
  }

  export type OrderItemCreateWithoutOptionsInput = {
    id?: string
    quantity: number
    unitPrice: number
    subtotal: number
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutOptionsInput = {
    id?: string
    orderId: string
    productId: string
    quantity: number
    unitPrice: number
    subtotal: number
    createdAt?: Date | string
  }

  export type OrderItemCreateOrConnectWithoutOptionsInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOptionsInput, OrderItemUncheckedCreateWithoutOptionsInput>
  }

  export type ProductOptionCreateWithoutOrderItemOptionInput = {
    id?: string
    name: string
    price: number
    product: ProductCreateNestedOneWithoutOptionsInput
    CartItemOption?: CartItemOptionCreateNestedManyWithoutProductOptionInput
  }

  export type ProductOptionUncheckedCreateWithoutOrderItemOptionInput = {
    id?: string
    productId: string
    name: string
    price: number
    CartItemOption?: CartItemOptionUncheckedCreateNestedManyWithoutProductOptionInput
  }

  export type ProductOptionCreateOrConnectWithoutOrderItemOptionInput = {
    where: ProductOptionWhereUniqueInput
    create: XOR<ProductOptionCreateWithoutOrderItemOptionInput, ProductOptionUncheckedCreateWithoutOrderItemOptionInput>
  }

  export type OrderItemUpsertWithoutOptionsInput = {
    update: XOR<OrderItemUpdateWithoutOptionsInput, OrderItemUncheckedUpdateWithoutOptionsInput>
    create: XOR<OrderItemCreateWithoutOptionsInput, OrderItemUncheckedCreateWithoutOptionsInput>
    where?: OrderItemWhereInput
  }

  export type OrderItemUpdateToOneWithWhereWithoutOptionsInput = {
    where?: OrderItemWhereInput
    data: XOR<OrderItemUpdateWithoutOptionsInput, OrderItemUncheckedUpdateWithoutOptionsInput>
  }

  export type OrderItemUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductOptionUpsertWithoutOrderItemOptionInput = {
    update: XOR<ProductOptionUpdateWithoutOrderItemOptionInput, ProductOptionUncheckedUpdateWithoutOrderItemOptionInput>
    create: XOR<ProductOptionCreateWithoutOrderItemOptionInput, ProductOptionUncheckedCreateWithoutOrderItemOptionInput>
    where?: ProductOptionWhereInput
  }

  export type ProductOptionUpdateToOneWithWhereWithoutOrderItemOptionInput = {
    where?: ProductOptionWhereInput
    data: XOR<ProductOptionUpdateWithoutOrderItemOptionInput, ProductOptionUncheckedUpdateWithoutOrderItemOptionInput>
  }

  export type ProductOptionUpdateWithoutOrderItemOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutOptionsNestedInput
    CartItemOption?: CartItemOptionUpdateManyWithoutProductOptionNestedInput
  }

  export type ProductOptionUncheckedUpdateWithoutOrderItemOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    CartItemOption?: CartItemOptionUncheckedUpdateManyWithoutProductOptionNestedInput
  }

  export type ProductCreateWithoutReviewsInput = {
    id?: string
    name: string
    description: string
    price: number
    archived?: boolean
    category: $Enums.Category
    images?: ProductCreateimagesInput | string[]
    thumbnail?: string | null
    video?: ProductCreatevideoInput | string[]
    averageRating?: number | null
    reviewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    totalViews?: number
    popularityScore?: number
    popularityUpdatedAt?: Date | string | null
    popularityPercent?: number
    isNew?: boolean
    isLive?: boolean
    liveUntil?: Date | string | null
    vendor: UserCreateNestedOneWithoutProductsInput
    orders?: OrderCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    options?: ProductOptionCreateNestedManyWithoutProductInput
    CartItem?: CartItemCreateNestedManyWithoutProductInput
    specialRequests?: SpecialOrderRequestCreateNestedManyWithoutProductInput
    productSchedule?: ProductScheduleCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutReviewsInput = {
    id?: string
    name: string
    description: string
    price: number
    archived?: boolean
    category: $Enums.Category
    images?: ProductCreateimagesInput | string[]
    thumbnail?: string | null
    video?: ProductCreatevideoInput | string[]
    vendorId: string
    averageRating?: number | null
    reviewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    totalViews?: number
    popularityScore?: number
    popularityUpdatedAt?: Date | string | null
    popularityPercent?: number
    isNew?: boolean
    isLive?: boolean
    liveUntil?: Date | string | null
    orders?: OrderUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    options?: ProductOptionUncheckedCreateNestedManyWithoutProductInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductInput
    specialRequests?: SpecialOrderRequestUncheckedCreateNestedManyWithoutProductInput
    productSchedule?: ProductScheduleUncheckedCreateNestedOneWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutReviewsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
  }

  export type UserCreateWithoutProductReviewsGivenInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerCreateNestedManyWithoutVendorInput
    following?: VendorFollowerCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateWithoutProductReviewsGivenInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewUncheckedCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderUncheckedCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyUncheckedCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonUncheckedCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestUncheckedCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityUncheckedCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityUncheckedCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerUncheckedCreateNestedManyWithoutVendorInput
    following?: VendorFollowerUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserCreateOrConnectWithoutProductReviewsGivenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProductReviewsGivenInput, UserUncheckedCreateWithoutProductReviewsGivenInput>
  }

  export type VendorReplyCreateWithoutReviewInput = {
    id?: string
    message: string
    createdAt?: Date | string
    vendor: UserCreateNestedOneWithoutVendorRepliesSentInput
  }

  export type VendorReplyUncheckedCreateWithoutReviewInput = {
    id?: string
    vendorId: string
    message: string
    createdAt?: Date | string
  }

  export type VendorReplyCreateOrConnectWithoutReviewInput = {
    where: VendorReplyWhereUniqueInput
    create: XOR<VendorReplyCreateWithoutReviewInput, VendorReplyUncheckedCreateWithoutReviewInput>
  }

  export type ReviewVoteCreateWithoutReviewInput = {
    id?: string
    isHelpful: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutReviewVotesInput
  }

  export type ReviewVoteUncheckedCreateWithoutReviewInput = {
    id?: string
    userId: string
    isHelpful: boolean
    createdAt?: Date | string
  }

  export type ReviewVoteCreateOrConnectWithoutReviewInput = {
    where: ReviewVoteWhereUniqueInput
    create: XOR<ReviewVoteCreateWithoutReviewInput, ReviewVoteUncheckedCreateWithoutReviewInput>
  }

  export type ReviewVoteCreateManyReviewInputEnvelope = {
    data: ReviewVoteCreateManyReviewInput | ReviewVoteCreateManyReviewInput[]
    skipDuplicates?: boolean
  }

  export type ReviewReportCreateWithoutReviewInput = {
    id?: string
    reason: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutReviewReportsInput
  }

  export type ReviewReportUncheckedCreateWithoutReviewInput = {
    id?: string
    userId: string
    reason: string
    createdAt?: Date | string
  }

  export type ReviewReportCreateOrConnectWithoutReviewInput = {
    where: ReviewReportWhereUniqueInput
    create: XOR<ReviewReportCreateWithoutReviewInput, ReviewReportUncheckedCreateWithoutReviewInput>
  }

  export type ReviewReportCreateManyReviewInputEnvelope = {
    data: ReviewReportCreateManyReviewInput | ReviewReportCreateManyReviewInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithoutReviewsInput = {
    update: XOR<ProductUpdateWithoutReviewsInput, ProductUncheckedUpdateWithoutReviewsInput>
    create: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutReviewsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutReviewsInput, ProductUncheckedUpdateWithoutReviewsInput>
  }

  export type ProductUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    images?: ProductUpdateimagesInput | string[]
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    video?: ProductUpdatevideoInput | string[]
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalViews?: IntFieldUpdateOperationsInput | number
    popularityScore?: FloatFieldUpdateOperationsInput | number
    popularityUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    popularityPercent?: FloatFieldUpdateOperationsInput | number
    isNew?: BoolFieldUpdateOperationsInput | boolean
    isLive?: BoolFieldUpdateOperationsInput | boolean
    liveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendor?: UserUpdateOneRequiredWithoutProductsNestedInput
    orders?: OrderUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    options?: ProductOptionUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUpdateManyWithoutProductNestedInput
    specialRequests?: SpecialOrderRequestUpdateManyWithoutProductNestedInput
    productSchedule?: ProductScheduleUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    images?: ProductUpdateimagesInput | string[]
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    video?: ProductUpdatevideoInput | string[]
    vendorId?: StringFieldUpdateOperationsInput | string
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalViews?: IntFieldUpdateOperationsInput | number
    popularityScore?: FloatFieldUpdateOperationsInput | number
    popularityUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    popularityPercent?: FloatFieldUpdateOperationsInput | number
    isNew?: BoolFieldUpdateOperationsInput | boolean
    isLive?: BoolFieldUpdateOperationsInput | boolean
    liveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrderUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    options?: ProductOptionUncheckedUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    specialRequests?: SpecialOrderRequestUncheckedUpdateManyWithoutProductNestedInput
    productSchedule?: ProductScheduleUncheckedUpdateOneWithoutProductNestedInput
  }

  export type UserUpsertWithoutProductReviewsGivenInput = {
    update: XOR<UserUpdateWithoutProductReviewsGivenInput, UserUncheckedUpdateWithoutProductReviewsGivenInput>
    create: XOR<UserCreateWithoutProductReviewsGivenInput, UserUncheckedCreateWithoutProductReviewsGivenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProductReviewsGivenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProductReviewsGivenInput, UserUncheckedUpdateWithoutProductReviewsGivenInput>
  }

  export type UserUpdateWithoutProductReviewsGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateWithoutProductReviewsGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUncheckedUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUncheckedUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUncheckedUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUncheckedUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUncheckedUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUncheckedUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUncheckedUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUncheckedUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type VendorReplyUpsertWithoutReviewInput = {
    update: XOR<VendorReplyUpdateWithoutReviewInput, VendorReplyUncheckedUpdateWithoutReviewInput>
    create: XOR<VendorReplyCreateWithoutReviewInput, VendorReplyUncheckedCreateWithoutReviewInput>
    where?: VendorReplyWhereInput
  }

  export type VendorReplyUpdateToOneWithWhereWithoutReviewInput = {
    where?: VendorReplyWhereInput
    data: XOR<VendorReplyUpdateWithoutReviewInput, VendorReplyUncheckedUpdateWithoutReviewInput>
  }

  export type VendorReplyUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: UserUpdateOneRequiredWithoutVendorRepliesSentNestedInput
  }

  export type VendorReplyUncheckedUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewVoteUpsertWithWhereUniqueWithoutReviewInput = {
    where: ReviewVoteWhereUniqueInput
    update: XOR<ReviewVoteUpdateWithoutReviewInput, ReviewVoteUncheckedUpdateWithoutReviewInput>
    create: XOR<ReviewVoteCreateWithoutReviewInput, ReviewVoteUncheckedCreateWithoutReviewInput>
  }

  export type ReviewVoteUpdateWithWhereUniqueWithoutReviewInput = {
    where: ReviewVoteWhereUniqueInput
    data: XOR<ReviewVoteUpdateWithoutReviewInput, ReviewVoteUncheckedUpdateWithoutReviewInput>
  }

  export type ReviewVoteUpdateManyWithWhereWithoutReviewInput = {
    where: ReviewVoteScalarWhereInput
    data: XOR<ReviewVoteUpdateManyMutationInput, ReviewVoteUncheckedUpdateManyWithoutReviewInput>
  }

  export type ReviewReportUpsertWithWhereUniqueWithoutReviewInput = {
    where: ReviewReportWhereUniqueInput
    update: XOR<ReviewReportUpdateWithoutReviewInput, ReviewReportUncheckedUpdateWithoutReviewInput>
    create: XOR<ReviewReportCreateWithoutReviewInput, ReviewReportUncheckedCreateWithoutReviewInput>
  }

  export type ReviewReportUpdateWithWhereUniqueWithoutReviewInput = {
    where: ReviewReportWhereUniqueInput
    data: XOR<ReviewReportUpdateWithoutReviewInput, ReviewReportUncheckedUpdateWithoutReviewInput>
  }

  export type ReviewReportUpdateManyWithWhereWithoutReviewInput = {
    where: ReviewReportScalarWhereInput
    data: XOR<ReviewReportUpdateManyMutationInput, ReviewReportUncheckedUpdateManyWithoutReviewInput>
  }

  export type ProductReviewCreateWithoutReplyInput = {
    id?: string
    rating: number
    comment?: string | null
    images?: ProductReviewCreateimagesInput | string[]
    createdAt?: Date | string
    verifiedPurchase?: boolean
    product: ProductCreateNestedOneWithoutReviewsInput
    customer: UserCreateNestedOneWithoutProductReviewsGivenInput
    votes?: ReviewVoteCreateNestedManyWithoutReviewInput
    reports?: ReviewReportCreateNestedManyWithoutReviewInput
  }

  export type ProductReviewUncheckedCreateWithoutReplyInput = {
    id?: string
    productId: string
    customerId: string
    rating: number
    comment?: string | null
    images?: ProductReviewCreateimagesInput | string[]
    createdAt?: Date | string
    verifiedPurchase?: boolean
    votes?: ReviewVoteUncheckedCreateNestedManyWithoutReviewInput
    reports?: ReviewReportUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ProductReviewCreateOrConnectWithoutReplyInput = {
    where: ProductReviewWhereUniqueInput
    create: XOR<ProductReviewCreateWithoutReplyInput, ProductReviewUncheckedCreateWithoutReplyInput>
  }

  export type UserCreateWithoutVendorRepliesSentInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerCreateNestedManyWithoutVendorInput
    following?: VendorFollowerCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateWithoutVendorRepliesSentInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewUncheckedCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewUncheckedCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderUncheckedCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonUncheckedCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestUncheckedCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityUncheckedCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityUncheckedCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerUncheckedCreateNestedManyWithoutVendorInput
    following?: VendorFollowerUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserCreateOrConnectWithoutVendorRepliesSentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVendorRepliesSentInput, UserUncheckedCreateWithoutVendorRepliesSentInput>
  }

  export type ProductReviewUpsertWithoutReplyInput = {
    update: XOR<ProductReviewUpdateWithoutReplyInput, ProductReviewUncheckedUpdateWithoutReplyInput>
    create: XOR<ProductReviewCreateWithoutReplyInput, ProductReviewUncheckedCreateWithoutReplyInput>
    where?: ProductReviewWhereInput
  }

  export type ProductReviewUpdateToOneWithWhereWithoutReplyInput = {
    where?: ProductReviewWhereInput
    data: XOR<ProductReviewUpdateWithoutReplyInput, ProductReviewUncheckedUpdateWithoutReplyInput>
  }

  export type ProductReviewUpdateWithoutReplyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProductReviewUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedPurchase?: BoolFieldUpdateOperationsInput | boolean
    product?: ProductUpdateOneRequiredWithoutReviewsNestedInput
    customer?: UserUpdateOneRequiredWithoutProductReviewsGivenNestedInput
    votes?: ReviewVoteUpdateManyWithoutReviewNestedInput
    reports?: ReviewReportUpdateManyWithoutReviewNestedInput
  }

  export type ProductReviewUncheckedUpdateWithoutReplyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProductReviewUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedPurchase?: BoolFieldUpdateOperationsInput | boolean
    votes?: ReviewVoteUncheckedUpdateManyWithoutReviewNestedInput
    reports?: ReviewReportUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type UserUpsertWithoutVendorRepliesSentInput = {
    update: XOR<UserUpdateWithoutVendorRepliesSentInput, UserUncheckedUpdateWithoutVendorRepliesSentInput>
    create: XOR<UserCreateWithoutVendorRepliesSentInput, UserUncheckedCreateWithoutVendorRepliesSentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVendorRepliesSentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVendorRepliesSentInput, UserUncheckedUpdateWithoutVendorRepliesSentInput>
  }

  export type UserUpdateWithoutVendorRepliesSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateWithoutVendorRepliesSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUncheckedUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUncheckedUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUncheckedUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUncheckedUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUncheckedUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUncheckedUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUncheckedUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUncheckedUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type ProductReviewCreateWithoutVotesInput = {
    id?: string
    rating: number
    comment?: string | null
    images?: ProductReviewCreateimagesInput | string[]
    createdAt?: Date | string
    verifiedPurchase?: boolean
    product: ProductCreateNestedOneWithoutReviewsInput
    customer: UserCreateNestedOneWithoutProductReviewsGivenInput
    reply?: VendorReplyCreateNestedOneWithoutReviewInput
    reports?: ReviewReportCreateNestedManyWithoutReviewInput
  }

  export type ProductReviewUncheckedCreateWithoutVotesInput = {
    id?: string
    productId: string
    customerId: string
    rating: number
    comment?: string | null
    images?: ProductReviewCreateimagesInput | string[]
    createdAt?: Date | string
    verifiedPurchase?: boolean
    reply?: VendorReplyUncheckedCreateNestedOneWithoutReviewInput
    reports?: ReviewReportUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ProductReviewCreateOrConnectWithoutVotesInput = {
    where: ProductReviewWhereUniqueInput
    create: XOR<ProductReviewCreateWithoutVotesInput, ProductReviewUncheckedCreateWithoutVotesInput>
  }

  export type UserCreateWithoutReviewVotesInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyCreateNestedManyWithoutVendorInput
    reviewReports?: ReviewReportCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerCreateNestedManyWithoutVendorInput
    following?: VendorFollowerCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateWithoutReviewVotesInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewUncheckedCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewUncheckedCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderUncheckedCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyUncheckedCreateNestedManyWithoutVendorInput
    reviewReports?: ReviewReportUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonUncheckedCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestUncheckedCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityUncheckedCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityUncheckedCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerUncheckedCreateNestedManyWithoutVendorInput
    following?: VendorFollowerUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserCreateOrConnectWithoutReviewVotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewVotesInput, UserUncheckedCreateWithoutReviewVotesInput>
  }

  export type ProductReviewUpsertWithoutVotesInput = {
    update: XOR<ProductReviewUpdateWithoutVotesInput, ProductReviewUncheckedUpdateWithoutVotesInput>
    create: XOR<ProductReviewCreateWithoutVotesInput, ProductReviewUncheckedCreateWithoutVotesInput>
    where?: ProductReviewWhereInput
  }

  export type ProductReviewUpdateToOneWithWhereWithoutVotesInput = {
    where?: ProductReviewWhereInput
    data: XOR<ProductReviewUpdateWithoutVotesInput, ProductReviewUncheckedUpdateWithoutVotesInput>
  }

  export type ProductReviewUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProductReviewUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedPurchase?: BoolFieldUpdateOperationsInput | boolean
    product?: ProductUpdateOneRequiredWithoutReviewsNestedInput
    customer?: UserUpdateOneRequiredWithoutProductReviewsGivenNestedInput
    reply?: VendorReplyUpdateOneWithoutReviewNestedInput
    reports?: ReviewReportUpdateManyWithoutReviewNestedInput
  }

  export type ProductReviewUncheckedUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProductReviewUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedPurchase?: BoolFieldUpdateOperationsInput | boolean
    reply?: VendorReplyUncheckedUpdateOneWithoutReviewNestedInput
    reports?: ReviewReportUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type UserUpsertWithoutReviewVotesInput = {
    update: XOR<UserUpdateWithoutReviewVotesInput, UserUncheckedUpdateWithoutReviewVotesInput>
    create: XOR<UserCreateWithoutReviewVotesInput, UserUncheckedCreateWithoutReviewVotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewVotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewVotesInput, UserUncheckedUpdateWithoutReviewVotesInput>
  }

  export type UserUpdateWithoutReviewVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUpdateManyWithoutVendorNestedInput
    reviewReports?: ReviewReportUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUncheckedUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUncheckedUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUncheckedUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUncheckedUpdateManyWithoutVendorNestedInput
    reviewReports?: ReviewReportUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUncheckedUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUncheckedUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUncheckedUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUncheckedUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUncheckedUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type ProductReviewCreateWithoutReportsInput = {
    id?: string
    rating: number
    comment?: string | null
    images?: ProductReviewCreateimagesInput | string[]
    createdAt?: Date | string
    verifiedPurchase?: boolean
    product: ProductCreateNestedOneWithoutReviewsInput
    customer: UserCreateNestedOneWithoutProductReviewsGivenInput
    reply?: VendorReplyCreateNestedOneWithoutReviewInput
    votes?: ReviewVoteCreateNestedManyWithoutReviewInput
  }

  export type ProductReviewUncheckedCreateWithoutReportsInput = {
    id?: string
    productId: string
    customerId: string
    rating: number
    comment?: string | null
    images?: ProductReviewCreateimagesInput | string[]
    createdAt?: Date | string
    verifiedPurchase?: boolean
    reply?: VendorReplyUncheckedCreateNestedOneWithoutReviewInput
    votes?: ReviewVoteUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ProductReviewCreateOrConnectWithoutReportsInput = {
    where: ProductReviewWhereUniqueInput
    create: XOR<ProductReviewCreateWithoutReportsInput, ProductReviewUncheckedCreateWithoutReportsInput>
  }

  export type UserCreateWithoutReviewReportsInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerCreateNestedManyWithoutVendorInput
    following?: VendorFollowerCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateWithoutReviewReportsInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewUncheckedCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewUncheckedCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderUncheckedCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyUncheckedCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonUncheckedCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestUncheckedCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityUncheckedCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityUncheckedCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerUncheckedCreateNestedManyWithoutVendorInput
    following?: VendorFollowerUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserCreateOrConnectWithoutReviewReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewReportsInput, UserUncheckedCreateWithoutReviewReportsInput>
  }

  export type ProductReviewUpsertWithoutReportsInput = {
    update: XOR<ProductReviewUpdateWithoutReportsInput, ProductReviewUncheckedUpdateWithoutReportsInput>
    create: XOR<ProductReviewCreateWithoutReportsInput, ProductReviewUncheckedCreateWithoutReportsInput>
    where?: ProductReviewWhereInput
  }

  export type ProductReviewUpdateToOneWithWhereWithoutReportsInput = {
    where?: ProductReviewWhereInput
    data: XOR<ProductReviewUpdateWithoutReportsInput, ProductReviewUncheckedUpdateWithoutReportsInput>
  }

  export type ProductReviewUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProductReviewUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedPurchase?: BoolFieldUpdateOperationsInput | boolean
    product?: ProductUpdateOneRequiredWithoutReviewsNestedInput
    customer?: UserUpdateOneRequiredWithoutProductReviewsGivenNestedInput
    reply?: VendorReplyUpdateOneWithoutReviewNestedInput
    votes?: ReviewVoteUpdateManyWithoutReviewNestedInput
  }

  export type ProductReviewUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProductReviewUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedPurchase?: BoolFieldUpdateOperationsInput | boolean
    reply?: VendorReplyUncheckedUpdateOneWithoutReviewNestedInput
    votes?: ReviewVoteUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type UserUpsertWithoutReviewReportsInput = {
    update: XOR<UserUpdateWithoutReviewReportsInput, UserUncheckedUpdateWithoutReviewReportsInput>
    create: XOR<UserCreateWithoutReviewReportsInput, UserUncheckedCreateWithoutReviewReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewReportsInput, UserUncheckedUpdateWithoutReviewReportsInput>
  }

  export type UserUpdateWithoutReviewReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUncheckedUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUncheckedUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUncheckedUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUncheckedUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUncheckedUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUncheckedUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUncheckedUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUncheckedUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUncheckedUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type UserCreateWithoutVendorReviewsReceivedInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerCreateNestedManyWithoutVendorInput
    following?: VendorFollowerCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateWithoutVendorReviewsReceivedInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewUncheckedCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewUncheckedCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderUncheckedCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyUncheckedCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonUncheckedCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestUncheckedCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityUncheckedCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityUncheckedCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerUncheckedCreateNestedManyWithoutVendorInput
    following?: VendorFollowerUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserCreateOrConnectWithoutVendorReviewsReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVendorReviewsReceivedInput, UserUncheckedCreateWithoutVendorReviewsReceivedInput>
  }

  export type UserCreateWithoutVendorReviewsGivenInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewCreateNestedManyWithoutVendorInput
    productReviewsGiven?: ProductReviewCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerCreateNestedManyWithoutVendorInput
    following?: VendorFollowerCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateWithoutVendorReviewsGivenInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewUncheckedCreateNestedManyWithoutVendorInput
    productReviewsGiven?: ProductReviewUncheckedCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderUncheckedCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyUncheckedCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonUncheckedCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestUncheckedCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityUncheckedCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityUncheckedCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerUncheckedCreateNestedManyWithoutVendorInput
    following?: VendorFollowerUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserCreateOrConnectWithoutVendorReviewsGivenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVendorReviewsGivenInput, UserUncheckedCreateWithoutVendorReviewsGivenInput>
  }

  export type UserUpsertWithoutVendorReviewsReceivedInput = {
    update: XOR<UserUpdateWithoutVendorReviewsReceivedInput, UserUncheckedUpdateWithoutVendorReviewsReceivedInput>
    create: XOR<UserCreateWithoutVendorReviewsReceivedInput, UserUncheckedCreateWithoutVendorReviewsReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVendorReviewsReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVendorReviewsReceivedInput, UserUncheckedUpdateWithoutVendorReviewsReceivedInput>
  }

  export type UserUpdateWithoutVendorReviewsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateWithoutVendorReviewsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUncheckedUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUncheckedUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUncheckedUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUncheckedUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUncheckedUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUncheckedUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUncheckedUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUncheckedUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUncheckedUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type UserUpsertWithoutVendorReviewsGivenInput = {
    update: XOR<UserUpdateWithoutVendorReviewsGivenInput, UserUncheckedUpdateWithoutVendorReviewsGivenInput>
    create: XOR<UserCreateWithoutVendorReviewsGivenInput, UserUncheckedCreateWithoutVendorReviewsGivenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVendorReviewsGivenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVendorReviewsGivenInput, UserUncheckedUpdateWithoutVendorReviewsGivenInput>
  }

  export type UserUpdateWithoutVendorReviewsGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUpdateManyWithoutVendorNestedInput
    productReviewsGiven?: ProductReviewUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateWithoutVendorReviewsGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUncheckedUpdateManyWithoutVendorNestedInput
    productReviewsGiven?: ProductReviewUncheckedUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUncheckedUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUncheckedUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUncheckedUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUncheckedUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUncheckedUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUncheckedUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUncheckedUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerCreateNestedManyWithoutVendorInput
    following?: VendorFollowerCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewUncheckedCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewUncheckedCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderUncheckedCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyUncheckedCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportUncheckedCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonUncheckedCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestUncheckedCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityUncheckedCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityUncheckedCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerUncheckedCreateNestedManyWithoutVendorInput
    following?: VendorFollowerUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUncheckedUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUncheckedUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUncheckedUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUncheckedUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUncheckedUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUncheckedUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUncheckedUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUncheckedUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUncheckedUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUncheckedUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type UserCreateWithoutLoginHistoryInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerCreateNestedManyWithoutVendorInput
    following?: VendorFollowerCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateWithoutLoginHistoryInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewUncheckedCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewUncheckedCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderUncheckedCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyUncheckedCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonUncheckedCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestUncheckedCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityUncheckedCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityUncheckedCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerUncheckedCreateNestedManyWithoutVendorInput
    following?: VendorFollowerUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserCreateOrConnectWithoutLoginHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLoginHistoryInput, UserUncheckedCreateWithoutLoginHistoryInput>
  }

  export type UserUpsertWithoutLoginHistoryInput = {
    update: XOR<UserUpdateWithoutLoginHistoryInput, UserUncheckedUpdateWithoutLoginHistoryInput>
    create: XOR<UserCreateWithoutLoginHistoryInput, UserUncheckedCreateWithoutLoginHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLoginHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLoginHistoryInput, UserUncheckedUpdateWithoutLoginHistoryInput>
  }

  export type UserUpdateWithoutLoginHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateWithoutLoginHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUncheckedUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUncheckedUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUncheckedUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUncheckedUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUncheckedUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUncheckedUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUncheckedUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUncheckedUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUncheckedUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type UserCreateWithoutPasswordResetTokenInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerCreateNestedManyWithoutVendorInput
    following?: VendorFollowerCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateWithoutPasswordResetTokenInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewUncheckedCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewUncheckedCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderUncheckedCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyUncheckedCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestUncheckedCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityUncheckedCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityUncheckedCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerUncheckedCreateNestedManyWithoutVendorInput
    following?: VendorFollowerUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserCreateOrConnectWithoutPasswordResetTokenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordResetTokenInput, UserUncheckedCreateWithoutPasswordResetTokenInput>
  }

  export type UserUpsertWithoutPasswordResetTokenInput = {
    update: XOR<UserUpdateWithoutPasswordResetTokenInput, UserUncheckedUpdateWithoutPasswordResetTokenInput>
    create: XOR<UserCreateWithoutPasswordResetTokenInput, UserUncheckedCreateWithoutPasswordResetTokenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordResetTokenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordResetTokenInput, UserUncheckedUpdateWithoutPasswordResetTokenInput>
  }

  export type UserUpdateWithoutPasswordResetTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordResetTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUncheckedUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUncheckedUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUncheckedUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUncheckedUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUncheckedUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUncheckedUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUncheckedUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUncheckedUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type UserCreateWithoutPaymentsInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenCreateNestedOneWithoutUserInput
    RefundRequest?: RefundRequestCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerCreateNestedManyWithoutVendorInput
    following?: VendorFollowerCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateWithoutPaymentsInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewUncheckedCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewUncheckedCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderUncheckedCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyUncheckedCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonUncheckedCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput
    RefundRequest?: RefundRequestUncheckedCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityUncheckedCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityUncheckedCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerUncheckedCreateNestedManyWithoutVendorInput
    following?: VendorFollowerUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserCreateOrConnectWithoutPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
  }

  export type OrderCreateWithoutPaymentsInput = {
    id?: string
    basePrice: number
    extraCharge?: number
    totalPrice: number
    vendorNote?: string | null
    customerApproval?: boolean
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentInitiatedAt?: Date | string | null
    paymentStartedAt?: Date | string | null
    paidAt?: Date | string | null
    paymentStatus?: $Enums.PaymentStatus | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    protectedUntil?: Date | string | null
    paymentGraceMinutes?: number | null
    customer: UserCreateNestedOneWithoutCustomerOrdersInput
    vendor: UserCreateNestedOneWithoutVendorOrdersInput
    address?: AddressCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    Product?: ProductCreateNestedManyWithoutOrdersInput
    assignments?: DeliveryAssignmentCreateNestedManyWithoutOrderInput
    earnings?: DeliveryEarningCreateNestedManyWithoutOrderInput
    Activity?: ActivityCreateNestedManyWithoutOrderInput
    DeliveryBroadcast?: DeliveryBroadcastCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutPaymentsInput = {
    id?: string
    customerId: string
    vendorId: string
    addressId?: string | null
    basePrice: number
    extraCharge?: number
    totalPrice: number
    vendorNote?: string | null
    customerApproval?: boolean
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentInitiatedAt?: Date | string | null
    paymentStartedAt?: Date | string | null
    paidAt?: Date | string | null
    paymentStatus?: $Enums.PaymentStatus | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    protectedUntil?: Date | string | null
    paymentGraceMinutes?: number | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    Product?: ProductUncheckedCreateNestedManyWithoutOrdersInput
    assignments?: DeliveryAssignmentUncheckedCreateNestedManyWithoutOrderInput
    earnings?: DeliveryEarningUncheckedCreateNestedManyWithoutOrderInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutOrderInput
    DeliveryBroadcast?: DeliveryBroadcastUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutPaymentsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
  }

  export type ReceiptCreateWithoutPaymentInput = {
    id?: string
    pdfUrl?: string | null
    createdAt?: Date | string
  }

  export type ReceiptUncheckedCreateWithoutPaymentInput = {
    id?: string
    pdfUrl?: string | null
    createdAt?: Date | string
  }

  export type ReceiptCreateOrConnectWithoutPaymentInput = {
    where: ReceiptWhereUniqueInput
    create: XOR<ReceiptCreateWithoutPaymentInput, ReceiptUncheckedCreateWithoutPaymentInput>
  }

  export type ReceiptCreateManyPaymentInputEnvelope = {
    data: ReceiptCreateManyPaymentInput | ReceiptCreateManyPaymentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPaymentsInput = {
    update: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUpdateOneWithoutUserNestedInput
    RefundRequest?: RefundRequestUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUncheckedUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUncheckedUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUncheckedUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUncheckedUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUncheckedUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput
    RefundRequest?: RefundRequestUncheckedUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUncheckedUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUncheckedUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUncheckedUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type OrderUpsertWithoutPaymentsInput = {
    update: XOR<OrderUpdateWithoutPaymentsInput, OrderUncheckedUpdateWithoutPaymentsInput>
    create: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutPaymentsInput, OrderUncheckedUpdateWithoutPaymentsInput>
  }

  export type OrderUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraCharge?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    vendorNote?: NullableStringFieldUpdateOperationsInput | string | null
    customerApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentInitiatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    protectedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGraceMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    customer?: UserUpdateOneRequiredWithoutCustomerOrdersNestedInput
    vendor?: UserUpdateOneRequiredWithoutVendorOrdersNestedInput
    address?: AddressUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    Product?: ProductUpdateManyWithoutOrdersNestedInput
    assignments?: DeliveryAssignmentUpdateManyWithoutOrderNestedInput
    earnings?: DeliveryEarningUpdateManyWithoutOrderNestedInput
    Activity?: ActivityUpdateManyWithoutOrderNestedInput
    DeliveryBroadcast?: DeliveryBroadcastUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraCharge?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    vendorNote?: NullableStringFieldUpdateOperationsInput | string | null
    customerApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentInitiatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    protectedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGraceMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    Product?: ProductUncheckedUpdateManyWithoutOrdersNestedInput
    assignments?: DeliveryAssignmentUncheckedUpdateManyWithoutOrderNestedInput
    earnings?: DeliveryEarningUncheckedUpdateManyWithoutOrderNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutOrderNestedInput
    DeliveryBroadcast?: DeliveryBroadcastUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ReceiptUpsertWithWhereUniqueWithoutPaymentInput = {
    where: ReceiptWhereUniqueInput
    update: XOR<ReceiptUpdateWithoutPaymentInput, ReceiptUncheckedUpdateWithoutPaymentInput>
    create: XOR<ReceiptCreateWithoutPaymentInput, ReceiptUncheckedCreateWithoutPaymentInput>
  }

  export type ReceiptUpdateWithWhereUniqueWithoutPaymentInput = {
    where: ReceiptWhereUniqueInput
    data: XOR<ReceiptUpdateWithoutPaymentInput, ReceiptUncheckedUpdateWithoutPaymentInput>
  }

  export type ReceiptUpdateManyWithWhereWithoutPaymentInput = {
    where: ReceiptScalarWhereInput
    data: XOR<ReceiptUpdateManyMutationInput, ReceiptUncheckedUpdateManyWithoutPaymentInput>
  }

  export type ReceiptScalarWhereInput = {
    AND?: ReceiptScalarWhereInput | ReceiptScalarWhereInput[]
    OR?: ReceiptScalarWhereInput[]
    NOT?: ReceiptScalarWhereInput | ReceiptScalarWhereInput[]
    id?: StringFilter<"Receipt"> | string
    paymentId?: StringFilter<"Receipt"> | string
    pdfUrl?: StringNullableFilter<"Receipt"> | string | null
    createdAt?: DateTimeFilter<"Receipt"> | Date | string
  }

  export type UserCreateWithoutRefundRequestInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerCreateNestedManyWithoutVendorInput
    following?: VendorFollowerCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateWithoutRefundRequestInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewUncheckedCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewUncheckedCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderUncheckedCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyUncheckedCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonUncheckedCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityUncheckedCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityUncheckedCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerUncheckedCreateNestedManyWithoutVendorInput
    following?: VendorFollowerUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserCreateOrConnectWithoutRefundRequestInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefundRequestInput, UserUncheckedCreateWithoutRefundRequestInput>
  }

  export type UserUpsertWithoutRefundRequestInput = {
    update: XOR<UserUpdateWithoutRefundRequestInput, UserUncheckedUpdateWithoutRefundRequestInput>
    create: XOR<UserCreateWithoutRefundRequestInput, UserUncheckedCreateWithoutRefundRequestInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefundRequestInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefundRequestInput, UserUncheckedUpdateWithoutRefundRequestInput>
  }

  export type UserUpdateWithoutRefundRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateWithoutRefundRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUncheckedUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUncheckedUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUncheckedUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUncheckedUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUncheckedUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUncheckedUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUncheckedUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUncheckedUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type UserCreateWithoutCartsInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    UserPaymentMethod?: UserPaymentMethodCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerCreateNestedManyWithoutVendorInput
    following?: VendorFollowerCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateWithoutCartsInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewUncheckedCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewUncheckedCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderUncheckedCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyUncheckedCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    UserPaymentMethod?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonUncheckedCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestUncheckedCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityUncheckedCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityUncheckedCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerUncheckedCreateNestedManyWithoutVendorInput
    following?: VendorFollowerUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserCreateOrConnectWithoutCartsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCartsInput, UserUncheckedCreateWithoutCartsInput>
  }

  export type CartItemCreateWithoutCartInput = {
    id?: string
    quantity: number
    unitPrice: number
    subtotal: number
    specialRequest?: string | null
    product: ProductCreateNestedOneWithoutCartItemInput
    options?: CartItemOptionCreateNestedManyWithoutCartItemInput
  }

  export type CartItemUncheckedCreateWithoutCartInput = {
    id?: string
    productId: string
    quantity: number
    unitPrice: number
    subtotal: number
    specialRequest?: string | null
    options?: CartItemOptionUncheckedCreateNestedManyWithoutCartItemInput
  }

  export type CartItemCreateOrConnectWithoutCartInput = {
    where: CartItemWhereUniqueInput
    create: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput>
  }

  export type CartItemCreateManyCartInputEnvelope = {
    data: CartItemCreateManyCartInput | CartItemCreateManyCartInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCartsInput = {
    update: XOR<UserUpdateWithoutCartsInput, UserUncheckedUpdateWithoutCartsInput>
    create: XOR<UserCreateWithoutCartsInput, UserUncheckedCreateWithoutCartsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCartsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCartsInput, UserUncheckedUpdateWithoutCartsInput>
  }

  export type UserUpdateWithoutCartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    UserPaymentMethod?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateWithoutCartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUncheckedUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUncheckedUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUncheckedUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUncheckedUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    UserPaymentMethod?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUncheckedUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUncheckedUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUncheckedUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUncheckedUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUncheckedUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type CartItemUpsertWithWhereUniqueWithoutCartInput = {
    where: CartItemWhereUniqueInput
    update: XOR<CartItemUpdateWithoutCartInput, CartItemUncheckedUpdateWithoutCartInput>
    create: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput>
  }

  export type CartItemUpdateWithWhereUniqueWithoutCartInput = {
    where: CartItemWhereUniqueInput
    data: XOR<CartItemUpdateWithoutCartInput, CartItemUncheckedUpdateWithoutCartInput>
  }

  export type CartItemUpdateManyWithWhereWithoutCartInput = {
    where: CartItemScalarWhereInput
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyWithoutCartInput>
  }

  export type CartCreateWithoutItemsInput = {
    id?: string
    basePrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: UserCreateNestedOneWithoutCartsInput
  }

  export type CartUncheckedCreateWithoutItemsInput = {
    id?: string
    customerId: string
    basePrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartCreateOrConnectWithoutItemsInput = {
    where: CartWhereUniqueInput
    create: XOR<CartCreateWithoutItemsInput, CartUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutCartItemInput = {
    id?: string
    name: string
    description: string
    price: number
    archived?: boolean
    category: $Enums.Category
    images?: ProductCreateimagesInput | string[]
    thumbnail?: string | null
    video?: ProductCreatevideoInput | string[]
    averageRating?: number | null
    reviewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    totalViews?: number
    popularityScore?: number
    popularityUpdatedAt?: Date | string | null
    popularityPercent?: number
    isNew?: boolean
    isLive?: boolean
    liveUntil?: Date | string | null
    vendor: UserCreateNestedOneWithoutProductsInput
    reviews?: ProductReviewCreateNestedManyWithoutProductInput
    orders?: OrderCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    options?: ProductOptionCreateNestedManyWithoutProductInput
    specialRequests?: SpecialOrderRequestCreateNestedManyWithoutProductInput
    productSchedule?: ProductScheduleCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCartItemInput = {
    id?: string
    name: string
    description: string
    price: number
    archived?: boolean
    category: $Enums.Category
    images?: ProductCreateimagesInput | string[]
    thumbnail?: string | null
    video?: ProductCreatevideoInput | string[]
    vendorId: string
    averageRating?: number | null
    reviewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    totalViews?: number
    popularityScore?: number
    popularityUpdatedAt?: Date | string | null
    popularityPercent?: number
    isNew?: boolean
    isLive?: boolean
    liveUntil?: Date | string | null
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    orders?: OrderUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    options?: ProductOptionUncheckedCreateNestedManyWithoutProductInput
    specialRequests?: SpecialOrderRequestUncheckedCreateNestedManyWithoutProductInput
    productSchedule?: ProductScheduleUncheckedCreateNestedOneWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCartItemInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCartItemInput, ProductUncheckedCreateWithoutCartItemInput>
  }

  export type CartItemOptionCreateWithoutCartItemInput = {
    id?: string
    name: string
    price: number
    productOption: ProductOptionCreateNestedOneWithoutCartItemOptionInput
  }

  export type CartItemOptionUncheckedCreateWithoutCartItemInput = {
    id?: string
    productOptionId: string
    name: string
    price: number
  }

  export type CartItemOptionCreateOrConnectWithoutCartItemInput = {
    where: CartItemOptionWhereUniqueInput
    create: XOR<CartItemOptionCreateWithoutCartItemInput, CartItemOptionUncheckedCreateWithoutCartItemInput>
  }

  export type CartItemOptionCreateManyCartItemInputEnvelope = {
    data: CartItemOptionCreateManyCartItemInput | CartItemOptionCreateManyCartItemInput[]
    skipDuplicates?: boolean
  }

  export type CartUpsertWithoutItemsInput = {
    update: XOR<CartUpdateWithoutItemsInput, CartUncheckedUpdateWithoutItemsInput>
    create: XOR<CartCreateWithoutItemsInput, CartUncheckedCreateWithoutItemsInput>
    where?: CartWhereInput
  }

  export type CartUpdateToOneWithWhereWithoutItemsInput = {
    where?: CartWhereInput
    data: XOR<CartUpdateWithoutItemsInput, CartUncheckedUpdateWithoutItemsInput>
  }

  export type CartUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutCartsNestedInput
  }

  export type CartUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutCartItemInput = {
    update: XOR<ProductUpdateWithoutCartItemInput, ProductUncheckedUpdateWithoutCartItemInput>
    create: XOR<ProductCreateWithoutCartItemInput, ProductUncheckedCreateWithoutCartItemInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutCartItemInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutCartItemInput, ProductUncheckedUpdateWithoutCartItemInput>
  }

  export type ProductUpdateWithoutCartItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    images?: ProductUpdateimagesInput | string[]
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    video?: ProductUpdatevideoInput | string[]
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalViews?: IntFieldUpdateOperationsInput | number
    popularityScore?: FloatFieldUpdateOperationsInput | number
    popularityUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    popularityPercent?: FloatFieldUpdateOperationsInput | number
    isNew?: BoolFieldUpdateOperationsInput | boolean
    isLive?: BoolFieldUpdateOperationsInput | boolean
    liveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendor?: UserUpdateOneRequiredWithoutProductsNestedInput
    reviews?: ProductReviewUpdateManyWithoutProductNestedInput
    orders?: OrderUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    options?: ProductOptionUpdateManyWithoutProductNestedInput
    specialRequests?: SpecialOrderRequestUpdateManyWithoutProductNestedInput
    productSchedule?: ProductScheduleUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCartItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    images?: ProductUpdateimagesInput | string[]
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    video?: ProductUpdatevideoInput | string[]
    vendorId?: StringFieldUpdateOperationsInput | string
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalViews?: IntFieldUpdateOperationsInput | number
    popularityScore?: FloatFieldUpdateOperationsInput | number
    popularityUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    popularityPercent?: FloatFieldUpdateOperationsInput | number
    isNew?: BoolFieldUpdateOperationsInput | boolean
    isLive?: BoolFieldUpdateOperationsInput | boolean
    liveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviews?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    options?: ProductOptionUncheckedUpdateManyWithoutProductNestedInput
    specialRequests?: SpecialOrderRequestUncheckedUpdateManyWithoutProductNestedInput
    productSchedule?: ProductScheduleUncheckedUpdateOneWithoutProductNestedInput
  }

  export type CartItemOptionUpsertWithWhereUniqueWithoutCartItemInput = {
    where: CartItemOptionWhereUniqueInput
    update: XOR<CartItemOptionUpdateWithoutCartItemInput, CartItemOptionUncheckedUpdateWithoutCartItemInput>
    create: XOR<CartItemOptionCreateWithoutCartItemInput, CartItemOptionUncheckedCreateWithoutCartItemInput>
  }

  export type CartItemOptionUpdateWithWhereUniqueWithoutCartItemInput = {
    where: CartItemOptionWhereUniqueInput
    data: XOR<CartItemOptionUpdateWithoutCartItemInput, CartItemOptionUncheckedUpdateWithoutCartItemInput>
  }

  export type CartItemOptionUpdateManyWithWhereWithoutCartItemInput = {
    where: CartItemOptionScalarWhereInput
    data: XOR<CartItemOptionUpdateManyMutationInput, CartItemOptionUncheckedUpdateManyWithoutCartItemInput>
  }

  export type CartItemCreateWithoutOptionsInput = {
    id?: string
    quantity: number
    unitPrice: number
    subtotal: number
    specialRequest?: string | null
    cart: CartCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutCartItemInput
  }

  export type CartItemUncheckedCreateWithoutOptionsInput = {
    id?: string
    cartId: string
    productId: string
    quantity: number
    unitPrice: number
    subtotal: number
    specialRequest?: string | null
  }

  export type CartItemCreateOrConnectWithoutOptionsInput = {
    where: CartItemWhereUniqueInput
    create: XOR<CartItemCreateWithoutOptionsInput, CartItemUncheckedCreateWithoutOptionsInput>
  }

  export type ProductOptionCreateWithoutCartItemOptionInput = {
    id?: string
    name: string
    price: number
    product: ProductCreateNestedOneWithoutOptionsInput
    OrderItemOption?: OrderItemOptionCreateNestedManyWithoutProductOptionInput
  }

  export type ProductOptionUncheckedCreateWithoutCartItemOptionInput = {
    id?: string
    productId: string
    name: string
    price: number
    OrderItemOption?: OrderItemOptionUncheckedCreateNestedManyWithoutProductOptionInput
  }

  export type ProductOptionCreateOrConnectWithoutCartItemOptionInput = {
    where: ProductOptionWhereUniqueInput
    create: XOR<ProductOptionCreateWithoutCartItemOptionInput, ProductOptionUncheckedCreateWithoutCartItemOptionInput>
  }

  export type CartItemUpsertWithoutOptionsInput = {
    update: XOR<CartItemUpdateWithoutOptionsInput, CartItemUncheckedUpdateWithoutOptionsInput>
    create: XOR<CartItemCreateWithoutOptionsInput, CartItemUncheckedCreateWithoutOptionsInput>
    where?: CartItemWhereInput
  }

  export type CartItemUpdateToOneWithWhereWithoutOptionsInput = {
    where?: CartItemWhereInput
    data: XOR<CartItemUpdateWithoutOptionsInput, CartItemUncheckedUpdateWithoutOptionsInput>
  }

  export type CartItemUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    specialRequest?: NullableStringFieldUpdateOperationsInput | string | null
    cart?: CartUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutCartItemNestedInput
  }

  export type CartItemUncheckedUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    specialRequest?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductOptionUpsertWithoutCartItemOptionInput = {
    update: XOR<ProductOptionUpdateWithoutCartItemOptionInput, ProductOptionUncheckedUpdateWithoutCartItemOptionInput>
    create: XOR<ProductOptionCreateWithoutCartItemOptionInput, ProductOptionUncheckedCreateWithoutCartItemOptionInput>
    where?: ProductOptionWhereInput
  }

  export type ProductOptionUpdateToOneWithWhereWithoutCartItemOptionInput = {
    where?: ProductOptionWhereInput
    data: XOR<ProductOptionUpdateWithoutCartItemOptionInput, ProductOptionUncheckedUpdateWithoutCartItemOptionInput>
  }

  export type ProductOptionUpdateWithoutCartItemOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutOptionsNestedInput
    OrderItemOption?: OrderItemOptionUpdateManyWithoutProductOptionNestedInput
  }

  export type ProductOptionUncheckedUpdateWithoutCartItemOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    OrderItemOption?: OrderItemOptionUncheckedUpdateManyWithoutProductOptionNestedInput
  }

  export type UserCreateWithoutUserPaymentMethodInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutCustomerInput
    deliveryPerson?: DeliveryPersonCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerCreateNestedManyWithoutVendorInput
    following?: VendorFollowerCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateWithoutUserPaymentMethodInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewUncheckedCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewUncheckedCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderUncheckedCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyUncheckedCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutCustomerInput
    deliveryPerson?: DeliveryPersonUncheckedCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestUncheckedCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityUncheckedCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityUncheckedCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerUncheckedCreateNestedManyWithoutVendorInput
    following?: VendorFollowerUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserCreateOrConnectWithoutUserPaymentMethodInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserPaymentMethodInput, UserUncheckedCreateWithoutUserPaymentMethodInput>
  }

  export type UserUpsertWithoutUserPaymentMethodInput = {
    update: XOR<UserUpdateWithoutUserPaymentMethodInput, UserUncheckedUpdateWithoutUserPaymentMethodInput>
    create: XOR<UserCreateWithoutUserPaymentMethodInput, UserUncheckedCreateWithoutUserPaymentMethodInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserPaymentMethodInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserPaymentMethodInput, UserUncheckedUpdateWithoutUserPaymentMethodInput>
  }

  export type UserUpdateWithoutUserPaymentMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutCustomerNestedInput
    deliveryPerson?: DeliveryPersonUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateWithoutUserPaymentMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUncheckedUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUncheckedUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUncheckedUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUncheckedUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutCustomerNestedInput
    deliveryPerson?: DeliveryPersonUncheckedUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUncheckedUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUncheckedUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUncheckedUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUncheckedUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type UserCreateWithoutDeliveryPersonInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodCreateNestedManyWithoutUserInput
    passwordResetToken?: PasswordResetTokenCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerCreateNestedManyWithoutVendorInput
    following?: VendorFollowerCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateWithoutDeliveryPersonInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewUncheckedCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewUncheckedCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderUncheckedCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyUncheckedCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    passwordResetToken?: PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestUncheckedCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityUncheckedCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityUncheckedCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerUncheckedCreateNestedManyWithoutVendorInput
    following?: VendorFollowerUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserCreateOrConnectWithoutDeliveryPersonInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeliveryPersonInput, UserUncheckedCreateWithoutDeliveryPersonInput>
  }

  export type DeliveryAssignmentCreateWithoutDeliveryPersonInput = {
    id?: string
    status?: $Enums.DeliveryStatus
    assignedAt?: Date | string
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    declinedAt?: Date | string | null
    timeoutSeconds?: number
    attempts?: number
    batchId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutAssignmentsInput
  }

  export type DeliveryAssignmentUncheckedCreateWithoutDeliveryPersonInput = {
    id?: string
    orderId: string
    status?: $Enums.DeliveryStatus
    assignedAt?: Date | string
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    declinedAt?: Date | string | null
    timeoutSeconds?: number
    attempts?: number
    batchId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryAssignmentCreateOrConnectWithoutDeliveryPersonInput = {
    where: DeliveryAssignmentWhereUniqueInput
    create: XOR<DeliveryAssignmentCreateWithoutDeliveryPersonInput, DeliveryAssignmentUncheckedCreateWithoutDeliveryPersonInput>
  }

  export type DeliveryAssignmentCreateManyDeliveryPersonInputEnvelope = {
    data: DeliveryAssignmentCreateManyDeliveryPersonInput | DeliveryAssignmentCreateManyDeliveryPersonInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryEarningCreateWithoutDeliveryPersonInput = {
    id?: string
    baseFee: number
    distanceFee: number
    tip?: number
    deductions?: number
    totalEarned: number
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutEarningsInput
  }

  export type DeliveryEarningUncheckedCreateWithoutDeliveryPersonInput = {
    id?: string
    orderId: string
    baseFee: number
    distanceFee: number
    tip?: number
    deductions?: number
    totalEarned: number
    createdAt?: Date | string
  }

  export type DeliveryEarningCreateOrConnectWithoutDeliveryPersonInput = {
    where: DeliveryEarningWhereUniqueInput
    create: XOR<DeliveryEarningCreateWithoutDeliveryPersonInput, DeliveryEarningUncheckedCreateWithoutDeliveryPersonInput>
  }

  export type DeliveryEarningCreateManyDeliveryPersonInputEnvelope = {
    data: DeliveryEarningCreateManyDeliveryPersonInput | DeliveryEarningCreateManyDeliveryPersonInput[]
    skipDuplicates?: boolean
  }

  export type DriverLocationLogCreateWithoutDriverInput = {
    id?: string
    latitude: number
    longitude: number
    timestamp?: Date | string
  }

  export type DriverLocationLogUncheckedCreateWithoutDriverInput = {
    id?: string
    latitude: number
    longitude: number
    timestamp?: Date | string
  }

  export type DriverLocationLogCreateOrConnectWithoutDriverInput = {
    where: DriverLocationLogWhereUniqueInput
    create: XOR<DriverLocationLogCreateWithoutDriverInput, DriverLocationLogUncheckedCreateWithoutDriverInput>
  }

  export type DriverLocationLogCreateManyDriverInputEnvelope = {
    data: DriverLocationLogCreateManyDriverInput | DriverLocationLogCreateManyDriverInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutDeliveryInput = {
    id?: string
    type: $Enums.ActivityType
    title: string
    message: string
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    order?: OrderCreateNestedOneWithoutActivityInput
    vendor?: UserCreateNestedOneWithoutVendorActivitiesInput
    customer?: UserCreateNestedOneWithoutCustomerActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutDeliveryInput = {
    id?: string
    orderId?: string | null
    vendorId?: string | null
    customerId?: string | null
    type: $Enums.ActivityType
    title: string
    message: string
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ActivityCreateOrConnectWithoutDeliveryInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutDeliveryInput, ActivityUncheckedCreateWithoutDeliveryInput>
  }

  export type ActivityCreateManyDeliveryInputEnvelope = {
    data: ActivityCreateManyDeliveryInput | ActivityCreateManyDeliveryInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutDeliveryPersonInput = {
    update: XOR<UserUpdateWithoutDeliveryPersonInput, UserUncheckedUpdateWithoutDeliveryPersonInput>
    create: XOR<UserCreateWithoutDeliveryPersonInput, UserUncheckedCreateWithoutDeliveryPersonInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeliveryPersonInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeliveryPersonInput, UserUncheckedUpdateWithoutDeliveryPersonInput>
  }

  export type UserUpdateWithoutDeliveryPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateWithoutDeliveryPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUncheckedUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUncheckedUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUncheckedUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUncheckedUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUncheckedUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUncheckedUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUncheckedUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUncheckedUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type DeliveryAssignmentUpsertWithWhereUniqueWithoutDeliveryPersonInput = {
    where: DeliveryAssignmentWhereUniqueInput
    update: XOR<DeliveryAssignmentUpdateWithoutDeliveryPersonInput, DeliveryAssignmentUncheckedUpdateWithoutDeliveryPersonInput>
    create: XOR<DeliveryAssignmentCreateWithoutDeliveryPersonInput, DeliveryAssignmentUncheckedCreateWithoutDeliveryPersonInput>
  }

  export type DeliveryAssignmentUpdateWithWhereUniqueWithoutDeliveryPersonInput = {
    where: DeliveryAssignmentWhereUniqueInput
    data: XOR<DeliveryAssignmentUpdateWithoutDeliveryPersonInput, DeliveryAssignmentUncheckedUpdateWithoutDeliveryPersonInput>
  }

  export type DeliveryAssignmentUpdateManyWithWhereWithoutDeliveryPersonInput = {
    where: DeliveryAssignmentScalarWhereInput
    data: XOR<DeliveryAssignmentUpdateManyMutationInput, DeliveryAssignmentUncheckedUpdateManyWithoutDeliveryPersonInput>
  }

  export type DeliveryEarningUpsertWithWhereUniqueWithoutDeliveryPersonInput = {
    where: DeliveryEarningWhereUniqueInput
    update: XOR<DeliveryEarningUpdateWithoutDeliveryPersonInput, DeliveryEarningUncheckedUpdateWithoutDeliveryPersonInput>
    create: XOR<DeliveryEarningCreateWithoutDeliveryPersonInput, DeliveryEarningUncheckedCreateWithoutDeliveryPersonInput>
  }

  export type DeliveryEarningUpdateWithWhereUniqueWithoutDeliveryPersonInput = {
    where: DeliveryEarningWhereUniqueInput
    data: XOR<DeliveryEarningUpdateWithoutDeliveryPersonInput, DeliveryEarningUncheckedUpdateWithoutDeliveryPersonInput>
  }

  export type DeliveryEarningUpdateManyWithWhereWithoutDeliveryPersonInput = {
    where: DeliveryEarningScalarWhereInput
    data: XOR<DeliveryEarningUpdateManyMutationInput, DeliveryEarningUncheckedUpdateManyWithoutDeliveryPersonInput>
  }

  export type DriverLocationLogUpsertWithWhereUniqueWithoutDriverInput = {
    where: DriverLocationLogWhereUniqueInput
    update: XOR<DriverLocationLogUpdateWithoutDriverInput, DriverLocationLogUncheckedUpdateWithoutDriverInput>
    create: XOR<DriverLocationLogCreateWithoutDriverInput, DriverLocationLogUncheckedCreateWithoutDriverInput>
  }

  export type DriverLocationLogUpdateWithWhereUniqueWithoutDriverInput = {
    where: DriverLocationLogWhereUniqueInput
    data: XOR<DriverLocationLogUpdateWithoutDriverInput, DriverLocationLogUncheckedUpdateWithoutDriverInput>
  }

  export type DriverLocationLogUpdateManyWithWhereWithoutDriverInput = {
    where: DriverLocationLogScalarWhereInput
    data: XOR<DriverLocationLogUpdateManyMutationInput, DriverLocationLogUncheckedUpdateManyWithoutDriverInput>
  }

  export type DriverLocationLogScalarWhereInput = {
    AND?: DriverLocationLogScalarWhereInput | DriverLocationLogScalarWhereInput[]
    OR?: DriverLocationLogScalarWhereInput[]
    NOT?: DriverLocationLogScalarWhereInput | DriverLocationLogScalarWhereInput[]
    id?: StringFilter<"DriverLocationLog"> | string
    driverId?: StringFilter<"DriverLocationLog"> | string
    latitude?: FloatFilter<"DriverLocationLog"> | number
    longitude?: FloatFilter<"DriverLocationLog"> | number
    timestamp?: DateTimeFilter<"DriverLocationLog"> | Date | string
  }

  export type ActivityUpsertWithWhereUniqueWithoutDeliveryInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutDeliveryInput, ActivityUncheckedUpdateWithoutDeliveryInput>
    create: XOR<ActivityCreateWithoutDeliveryInput, ActivityUncheckedCreateWithoutDeliveryInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutDeliveryInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutDeliveryInput, ActivityUncheckedUpdateWithoutDeliveryInput>
  }

  export type ActivityUpdateManyWithWhereWithoutDeliveryInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutDeliveryInput>
  }

  export type OrderCreateWithoutAssignmentsInput = {
    id?: string
    basePrice: number
    extraCharge?: number
    totalPrice: number
    vendorNote?: string | null
    customerApproval?: boolean
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentInitiatedAt?: Date | string | null
    paymentStartedAt?: Date | string | null
    paidAt?: Date | string | null
    paymentStatus?: $Enums.PaymentStatus | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    protectedUntil?: Date | string | null
    paymentGraceMinutes?: number | null
    customer: UserCreateNestedOneWithoutCustomerOrdersInput
    vendor: UserCreateNestedOneWithoutVendorOrdersInput
    address?: AddressCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    Product?: ProductCreateNestedManyWithoutOrdersInput
    earnings?: DeliveryEarningCreateNestedManyWithoutOrderInput
    Activity?: ActivityCreateNestedManyWithoutOrderInput
    DeliveryBroadcast?: DeliveryBroadcastCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    customerId: string
    vendorId: string
    addressId?: string | null
    basePrice: number
    extraCharge?: number
    totalPrice: number
    vendorNote?: string | null
    customerApproval?: boolean
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentInitiatedAt?: Date | string | null
    paymentStartedAt?: Date | string | null
    paidAt?: Date | string | null
    paymentStatus?: $Enums.PaymentStatus | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    protectedUntil?: Date | string | null
    paymentGraceMinutes?: number | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    Product?: ProductUncheckedCreateNestedManyWithoutOrdersInput
    earnings?: DeliveryEarningUncheckedCreateNestedManyWithoutOrderInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutOrderInput
    DeliveryBroadcast?: DeliveryBroadcastUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutAssignmentsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutAssignmentsInput, OrderUncheckedCreateWithoutAssignmentsInput>
  }

  export type DeliveryPersonCreateWithoutAssignedOrdersInput = {
    id?: string
    vehicleType?: string | null
    licensePlate?: string | null
    status?: string
    rating?: number
    totalDeliveries?: number
    isOnline?: boolean
    latitude?: number | null
    longitude?: number | null
    lastSeenAt?: Date | string | null
    walletBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDeliveryPersonInput
    earnings?: DeliveryEarningCreateNestedManyWithoutDeliveryPersonInput
    DriverLocationLog?: DriverLocationLogCreateNestedManyWithoutDriverInput
    Activity?: ActivityCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryPersonUncheckedCreateWithoutAssignedOrdersInput = {
    id?: string
    userId: string
    vehicleType?: string | null
    licensePlate?: string | null
    status?: string
    rating?: number
    totalDeliveries?: number
    isOnline?: boolean
    latitude?: number | null
    longitude?: number | null
    lastSeenAt?: Date | string | null
    walletBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    earnings?: DeliveryEarningUncheckedCreateNestedManyWithoutDeliveryPersonInput
    DriverLocationLog?: DriverLocationLogUncheckedCreateNestedManyWithoutDriverInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryPersonCreateOrConnectWithoutAssignedOrdersInput = {
    where: DeliveryPersonWhereUniqueInput
    create: XOR<DeliveryPersonCreateWithoutAssignedOrdersInput, DeliveryPersonUncheckedCreateWithoutAssignedOrdersInput>
  }

  export type OrderUpsertWithoutAssignmentsInput = {
    update: XOR<OrderUpdateWithoutAssignmentsInput, OrderUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<OrderCreateWithoutAssignmentsInput, OrderUncheckedCreateWithoutAssignmentsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutAssignmentsInput, OrderUncheckedUpdateWithoutAssignmentsInput>
  }

  export type OrderUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraCharge?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    vendorNote?: NullableStringFieldUpdateOperationsInput | string | null
    customerApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentInitiatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    protectedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGraceMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    customer?: UserUpdateOneRequiredWithoutCustomerOrdersNestedInput
    vendor?: UserUpdateOneRequiredWithoutVendorOrdersNestedInput
    address?: AddressUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    Product?: ProductUpdateManyWithoutOrdersNestedInput
    earnings?: DeliveryEarningUpdateManyWithoutOrderNestedInput
    Activity?: ActivityUpdateManyWithoutOrderNestedInput
    DeliveryBroadcast?: DeliveryBroadcastUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraCharge?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    vendorNote?: NullableStringFieldUpdateOperationsInput | string | null
    customerApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentInitiatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    protectedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGraceMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    Product?: ProductUncheckedUpdateManyWithoutOrdersNestedInput
    earnings?: DeliveryEarningUncheckedUpdateManyWithoutOrderNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutOrderNestedInput
    DeliveryBroadcast?: DeliveryBroadcastUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type DeliveryPersonUpsertWithoutAssignedOrdersInput = {
    update: XOR<DeliveryPersonUpdateWithoutAssignedOrdersInput, DeliveryPersonUncheckedUpdateWithoutAssignedOrdersInput>
    create: XOR<DeliveryPersonCreateWithoutAssignedOrdersInput, DeliveryPersonUncheckedCreateWithoutAssignedOrdersInput>
    where?: DeliveryPersonWhereInput
  }

  export type DeliveryPersonUpdateToOneWithWhereWithoutAssignedOrdersInput = {
    where?: DeliveryPersonWhereInput
    data: XOR<DeliveryPersonUpdateWithoutAssignedOrdersInput, DeliveryPersonUncheckedUpdateWithoutAssignedOrdersInput>
  }

  export type DeliveryPersonUpdateWithoutAssignedOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    totalDeliveries?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDeliveryPersonNestedInput
    earnings?: DeliveryEarningUpdateManyWithoutDeliveryPersonNestedInput
    DriverLocationLog?: DriverLocationLogUpdateManyWithoutDriverNestedInput
    Activity?: ActivityUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryPersonUncheckedUpdateWithoutAssignedOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    totalDeliveries?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    earnings?: DeliveryEarningUncheckedUpdateManyWithoutDeliveryPersonNestedInput
    DriverLocationLog?: DriverLocationLogUncheckedUpdateManyWithoutDriverNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryPersonCreateWithoutEarningsInput = {
    id?: string
    vehicleType?: string | null
    licensePlate?: string | null
    status?: string
    rating?: number
    totalDeliveries?: number
    isOnline?: boolean
    latitude?: number | null
    longitude?: number | null
    lastSeenAt?: Date | string | null
    walletBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDeliveryPersonInput
    assignedOrders?: DeliveryAssignmentCreateNestedManyWithoutDeliveryPersonInput
    DriverLocationLog?: DriverLocationLogCreateNestedManyWithoutDriverInput
    Activity?: ActivityCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryPersonUncheckedCreateWithoutEarningsInput = {
    id?: string
    userId: string
    vehicleType?: string | null
    licensePlate?: string | null
    status?: string
    rating?: number
    totalDeliveries?: number
    isOnline?: boolean
    latitude?: number | null
    longitude?: number | null
    lastSeenAt?: Date | string | null
    walletBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedOrders?: DeliveryAssignmentUncheckedCreateNestedManyWithoutDeliveryPersonInput
    DriverLocationLog?: DriverLocationLogUncheckedCreateNestedManyWithoutDriverInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryPersonCreateOrConnectWithoutEarningsInput = {
    where: DeliveryPersonWhereUniqueInput
    create: XOR<DeliveryPersonCreateWithoutEarningsInput, DeliveryPersonUncheckedCreateWithoutEarningsInput>
  }

  export type OrderCreateWithoutEarningsInput = {
    id?: string
    basePrice: number
    extraCharge?: number
    totalPrice: number
    vendorNote?: string | null
    customerApproval?: boolean
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentInitiatedAt?: Date | string | null
    paymentStartedAt?: Date | string | null
    paidAt?: Date | string | null
    paymentStatus?: $Enums.PaymentStatus | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    protectedUntil?: Date | string | null
    paymentGraceMinutes?: number | null
    customer: UserCreateNestedOneWithoutCustomerOrdersInput
    vendor: UserCreateNestedOneWithoutVendorOrdersInput
    address?: AddressCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    Product?: ProductCreateNestedManyWithoutOrdersInput
    assignments?: DeliveryAssignmentCreateNestedManyWithoutOrderInput
    Activity?: ActivityCreateNestedManyWithoutOrderInput
    DeliveryBroadcast?: DeliveryBroadcastCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutEarningsInput = {
    id?: string
    customerId: string
    vendorId: string
    addressId?: string | null
    basePrice: number
    extraCharge?: number
    totalPrice: number
    vendorNote?: string | null
    customerApproval?: boolean
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentInitiatedAt?: Date | string | null
    paymentStartedAt?: Date | string | null
    paidAt?: Date | string | null
    paymentStatus?: $Enums.PaymentStatus | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    protectedUntil?: Date | string | null
    paymentGraceMinutes?: number | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    Product?: ProductUncheckedCreateNestedManyWithoutOrdersInput
    assignments?: DeliveryAssignmentUncheckedCreateNestedManyWithoutOrderInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutOrderInput
    DeliveryBroadcast?: DeliveryBroadcastUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutEarningsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutEarningsInput, OrderUncheckedCreateWithoutEarningsInput>
  }

  export type DeliveryPersonUpsertWithoutEarningsInput = {
    update: XOR<DeliveryPersonUpdateWithoutEarningsInput, DeliveryPersonUncheckedUpdateWithoutEarningsInput>
    create: XOR<DeliveryPersonCreateWithoutEarningsInput, DeliveryPersonUncheckedCreateWithoutEarningsInput>
    where?: DeliveryPersonWhereInput
  }

  export type DeliveryPersonUpdateToOneWithWhereWithoutEarningsInput = {
    where?: DeliveryPersonWhereInput
    data: XOR<DeliveryPersonUpdateWithoutEarningsInput, DeliveryPersonUncheckedUpdateWithoutEarningsInput>
  }

  export type DeliveryPersonUpdateWithoutEarningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    totalDeliveries?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDeliveryPersonNestedInput
    assignedOrders?: DeliveryAssignmentUpdateManyWithoutDeliveryPersonNestedInput
    DriverLocationLog?: DriverLocationLogUpdateManyWithoutDriverNestedInput
    Activity?: ActivityUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryPersonUncheckedUpdateWithoutEarningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    totalDeliveries?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedOrders?: DeliveryAssignmentUncheckedUpdateManyWithoutDeliveryPersonNestedInput
    DriverLocationLog?: DriverLocationLogUncheckedUpdateManyWithoutDriverNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutDeliveryNestedInput
  }

  export type OrderUpsertWithoutEarningsInput = {
    update: XOR<OrderUpdateWithoutEarningsInput, OrderUncheckedUpdateWithoutEarningsInput>
    create: XOR<OrderCreateWithoutEarningsInput, OrderUncheckedCreateWithoutEarningsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutEarningsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutEarningsInput, OrderUncheckedUpdateWithoutEarningsInput>
  }

  export type OrderUpdateWithoutEarningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraCharge?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    vendorNote?: NullableStringFieldUpdateOperationsInput | string | null
    customerApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentInitiatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    protectedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGraceMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    customer?: UserUpdateOneRequiredWithoutCustomerOrdersNestedInput
    vendor?: UserUpdateOneRequiredWithoutVendorOrdersNestedInput
    address?: AddressUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    Product?: ProductUpdateManyWithoutOrdersNestedInput
    assignments?: DeliveryAssignmentUpdateManyWithoutOrderNestedInput
    Activity?: ActivityUpdateManyWithoutOrderNestedInput
    DeliveryBroadcast?: DeliveryBroadcastUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutEarningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraCharge?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    vendorNote?: NullableStringFieldUpdateOperationsInput | string | null
    customerApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentInitiatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    protectedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGraceMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    Product?: ProductUncheckedUpdateManyWithoutOrdersNestedInput
    assignments?: DeliveryAssignmentUncheckedUpdateManyWithoutOrderNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutOrderNestedInput
    DeliveryBroadcast?: DeliveryBroadcastUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type DeliveryPersonCreateWithoutDriverLocationLogInput = {
    id?: string
    vehicleType?: string | null
    licensePlate?: string | null
    status?: string
    rating?: number
    totalDeliveries?: number
    isOnline?: boolean
    latitude?: number | null
    longitude?: number | null
    lastSeenAt?: Date | string | null
    walletBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDeliveryPersonInput
    assignedOrders?: DeliveryAssignmentCreateNestedManyWithoutDeliveryPersonInput
    earnings?: DeliveryEarningCreateNestedManyWithoutDeliveryPersonInput
    Activity?: ActivityCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryPersonUncheckedCreateWithoutDriverLocationLogInput = {
    id?: string
    userId: string
    vehicleType?: string | null
    licensePlate?: string | null
    status?: string
    rating?: number
    totalDeliveries?: number
    isOnline?: boolean
    latitude?: number | null
    longitude?: number | null
    lastSeenAt?: Date | string | null
    walletBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedOrders?: DeliveryAssignmentUncheckedCreateNestedManyWithoutDeliveryPersonInput
    earnings?: DeliveryEarningUncheckedCreateNestedManyWithoutDeliveryPersonInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryPersonCreateOrConnectWithoutDriverLocationLogInput = {
    where: DeliveryPersonWhereUniqueInput
    create: XOR<DeliveryPersonCreateWithoutDriverLocationLogInput, DeliveryPersonUncheckedCreateWithoutDriverLocationLogInput>
  }

  export type DeliveryPersonUpsertWithoutDriverLocationLogInput = {
    update: XOR<DeliveryPersonUpdateWithoutDriverLocationLogInput, DeliveryPersonUncheckedUpdateWithoutDriverLocationLogInput>
    create: XOR<DeliveryPersonCreateWithoutDriverLocationLogInput, DeliveryPersonUncheckedCreateWithoutDriverLocationLogInput>
    where?: DeliveryPersonWhereInput
  }

  export type DeliveryPersonUpdateToOneWithWhereWithoutDriverLocationLogInput = {
    where?: DeliveryPersonWhereInput
    data: XOR<DeliveryPersonUpdateWithoutDriverLocationLogInput, DeliveryPersonUncheckedUpdateWithoutDriverLocationLogInput>
  }

  export type DeliveryPersonUpdateWithoutDriverLocationLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    totalDeliveries?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDeliveryPersonNestedInput
    assignedOrders?: DeliveryAssignmentUpdateManyWithoutDeliveryPersonNestedInput
    earnings?: DeliveryEarningUpdateManyWithoutDeliveryPersonNestedInput
    Activity?: ActivityUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryPersonUncheckedUpdateWithoutDriverLocationLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    totalDeliveries?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedOrders?: DeliveryAssignmentUncheckedUpdateManyWithoutDeliveryPersonNestedInput
    earnings?: DeliveryEarningUncheckedUpdateManyWithoutDeliveryPersonNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutDeliveryNestedInput
  }

  export type OrderCreateWithoutActivityInput = {
    id?: string
    basePrice: number
    extraCharge?: number
    totalPrice: number
    vendorNote?: string | null
    customerApproval?: boolean
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentInitiatedAt?: Date | string | null
    paymentStartedAt?: Date | string | null
    paidAt?: Date | string | null
    paymentStatus?: $Enums.PaymentStatus | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    protectedUntil?: Date | string | null
    paymentGraceMinutes?: number | null
    customer: UserCreateNestedOneWithoutCustomerOrdersInput
    vendor: UserCreateNestedOneWithoutVendorOrdersInput
    address?: AddressCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    Product?: ProductCreateNestedManyWithoutOrdersInput
    assignments?: DeliveryAssignmentCreateNestedManyWithoutOrderInput
    earnings?: DeliveryEarningCreateNestedManyWithoutOrderInput
    DeliveryBroadcast?: DeliveryBroadcastCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutActivityInput = {
    id?: string
    customerId: string
    vendorId: string
    addressId?: string | null
    basePrice: number
    extraCharge?: number
    totalPrice: number
    vendorNote?: string | null
    customerApproval?: boolean
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentInitiatedAt?: Date | string | null
    paymentStartedAt?: Date | string | null
    paidAt?: Date | string | null
    paymentStatus?: $Enums.PaymentStatus | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    protectedUntil?: Date | string | null
    paymentGraceMinutes?: number | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    Product?: ProductUncheckedCreateNestedManyWithoutOrdersInput
    assignments?: DeliveryAssignmentUncheckedCreateNestedManyWithoutOrderInput
    earnings?: DeliveryEarningUncheckedCreateNestedManyWithoutOrderInput
    DeliveryBroadcast?: DeliveryBroadcastUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutActivityInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutActivityInput, OrderUncheckedCreateWithoutActivityInput>
  }

  export type UserCreateWithoutVendorActivitiesInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestCreateNestedManyWithoutUserInput
    customerActivities?: ActivityCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerCreateNestedManyWithoutVendorInput
    following?: VendorFollowerCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateWithoutVendorActivitiesInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewUncheckedCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewUncheckedCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderUncheckedCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyUncheckedCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonUncheckedCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestUncheckedCreateNestedManyWithoutUserInput
    customerActivities?: ActivityUncheckedCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerUncheckedCreateNestedManyWithoutVendorInput
    following?: VendorFollowerUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserCreateOrConnectWithoutVendorActivitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVendorActivitiesInput, UserUncheckedCreateWithoutVendorActivitiesInput>
  }

  export type UserCreateWithoutCustomerActivitiesInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityCreateNestedManyWithoutVendorInput
    followers?: VendorFollowerCreateNestedManyWithoutVendorInput
    following?: VendorFollowerCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateWithoutCustomerActivitiesInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewUncheckedCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewUncheckedCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderUncheckedCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyUncheckedCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonUncheckedCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestUncheckedCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityUncheckedCreateNestedManyWithoutVendorInput
    followers?: VendorFollowerUncheckedCreateNestedManyWithoutVendorInput
    following?: VendorFollowerUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserCreateOrConnectWithoutCustomerActivitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCustomerActivitiesInput, UserUncheckedCreateWithoutCustomerActivitiesInput>
  }

  export type DeliveryPersonCreateWithoutActivityInput = {
    id?: string
    vehicleType?: string | null
    licensePlate?: string | null
    status?: string
    rating?: number
    totalDeliveries?: number
    isOnline?: boolean
    latitude?: number | null
    longitude?: number | null
    lastSeenAt?: Date | string | null
    walletBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDeliveryPersonInput
    assignedOrders?: DeliveryAssignmentCreateNestedManyWithoutDeliveryPersonInput
    earnings?: DeliveryEarningCreateNestedManyWithoutDeliveryPersonInput
    DriverLocationLog?: DriverLocationLogCreateNestedManyWithoutDriverInput
  }

  export type DeliveryPersonUncheckedCreateWithoutActivityInput = {
    id?: string
    userId: string
    vehicleType?: string | null
    licensePlate?: string | null
    status?: string
    rating?: number
    totalDeliveries?: number
    isOnline?: boolean
    latitude?: number | null
    longitude?: number | null
    lastSeenAt?: Date | string | null
    walletBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedOrders?: DeliveryAssignmentUncheckedCreateNestedManyWithoutDeliveryPersonInput
    earnings?: DeliveryEarningUncheckedCreateNestedManyWithoutDeliveryPersonInput
    DriverLocationLog?: DriverLocationLogUncheckedCreateNestedManyWithoutDriverInput
  }

  export type DeliveryPersonCreateOrConnectWithoutActivityInput = {
    where: DeliveryPersonWhereUniqueInput
    create: XOR<DeliveryPersonCreateWithoutActivityInput, DeliveryPersonUncheckedCreateWithoutActivityInput>
  }

  export type OrderUpsertWithoutActivityInput = {
    update: XOR<OrderUpdateWithoutActivityInput, OrderUncheckedUpdateWithoutActivityInput>
    create: XOR<OrderCreateWithoutActivityInput, OrderUncheckedCreateWithoutActivityInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutActivityInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutActivityInput, OrderUncheckedUpdateWithoutActivityInput>
  }

  export type OrderUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraCharge?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    vendorNote?: NullableStringFieldUpdateOperationsInput | string | null
    customerApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentInitiatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    protectedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGraceMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    customer?: UserUpdateOneRequiredWithoutCustomerOrdersNestedInput
    vendor?: UserUpdateOneRequiredWithoutVendorOrdersNestedInput
    address?: AddressUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    Product?: ProductUpdateManyWithoutOrdersNestedInput
    assignments?: DeliveryAssignmentUpdateManyWithoutOrderNestedInput
    earnings?: DeliveryEarningUpdateManyWithoutOrderNestedInput
    DeliveryBroadcast?: DeliveryBroadcastUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraCharge?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    vendorNote?: NullableStringFieldUpdateOperationsInput | string | null
    customerApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentInitiatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    protectedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGraceMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    Product?: ProductUncheckedUpdateManyWithoutOrdersNestedInput
    assignments?: DeliveryAssignmentUncheckedUpdateManyWithoutOrderNestedInput
    earnings?: DeliveryEarningUncheckedUpdateManyWithoutOrderNestedInput
    DeliveryBroadcast?: DeliveryBroadcastUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type UserUpsertWithoutVendorActivitiesInput = {
    update: XOR<UserUpdateWithoutVendorActivitiesInput, UserUncheckedUpdateWithoutVendorActivitiesInput>
    create: XOR<UserCreateWithoutVendorActivitiesInput, UserUncheckedCreateWithoutVendorActivitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVendorActivitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVendorActivitiesInput, UserUncheckedUpdateWithoutVendorActivitiesInput>
  }

  export type UserUpdateWithoutVendorActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUpdateManyWithoutUserNestedInput
    customerActivities?: ActivityUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateWithoutVendorActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUncheckedUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUncheckedUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUncheckedUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUncheckedUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUncheckedUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUncheckedUpdateManyWithoutUserNestedInput
    customerActivities?: ActivityUncheckedUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUncheckedUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type UserUpsertWithoutCustomerActivitiesInput = {
    update: XOR<UserUpdateWithoutCustomerActivitiesInput, UserUncheckedUpdateWithoutCustomerActivitiesInput>
    create: XOR<UserCreateWithoutCustomerActivitiesInput, UserUncheckedCreateWithoutCustomerActivitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCustomerActivitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCustomerActivitiesInput, UserUncheckedUpdateWithoutCustomerActivitiesInput>
  }

  export type UserUpdateWithoutCustomerActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUpdateManyWithoutVendorNestedInput
    followers?: VendorFollowerUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateWithoutCustomerActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUncheckedUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUncheckedUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUncheckedUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUncheckedUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUncheckedUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUncheckedUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUncheckedUpdateManyWithoutVendorNestedInput
    followers?: VendorFollowerUncheckedUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type DeliveryPersonUpsertWithoutActivityInput = {
    update: XOR<DeliveryPersonUpdateWithoutActivityInput, DeliveryPersonUncheckedUpdateWithoutActivityInput>
    create: XOR<DeliveryPersonCreateWithoutActivityInput, DeliveryPersonUncheckedCreateWithoutActivityInput>
    where?: DeliveryPersonWhereInput
  }

  export type DeliveryPersonUpdateToOneWithWhereWithoutActivityInput = {
    where?: DeliveryPersonWhereInput
    data: XOR<DeliveryPersonUpdateWithoutActivityInput, DeliveryPersonUncheckedUpdateWithoutActivityInput>
  }

  export type DeliveryPersonUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    totalDeliveries?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDeliveryPersonNestedInput
    assignedOrders?: DeliveryAssignmentUpdateManyWithoutDeliveryPersonNestedInput
    earnings?: DeliveryEarningUpdateManyWithoutDeliveryPersonNestedInput
    DriverLocationLog?: DriverLocationLogUpdateManyWithoutDriverNestedInput
  }

  export type DeliveryPersonUncheckedUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    totalDeliveries?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedOrders?: DeliveryAssignmentUncheckedUpdateManyWithoutDeliveryPersonNestedInput
    earnings?: DeliveryEarningUncheckedUpdateManyWithoutDeliveryPersonNestedInput
    DriverLocationLog?: DriverLocationLogUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type OrderCreateWithoutDeliveryBroadcastInput = {
    id?: string
    basePrice: number
    extraCharge?: number
    totalPrice: number
    vendorNote?: string | null
    customerApproval?: boolean
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentInitiatedAt?: Date | string | null
    paymentStartedAt?: Date | string | null
    paidAt?: Date | string | null
    paymentStatus?: $Enums.PaymentStatus | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    protectedUntil?: Date | string | null
    paymentGraceMinutes?: number | null
    customer: UserCreateNestedOneWithoutCustomerOrdersInput
    vendor: UserCreateNestedOneWithoutVendorOrdersInput
    address?: AddressCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    Product?: ProductCreateNestedManyWithoutOrdersInput
    assignments?: DeliveryAssignmentCreateNestedManyWithoutOrderInput
    earnings?: DeliveryEarningCreateNestedManyWithoutOrderInput
    Activity?: ActivityCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutDeliveryBroadcastInput = {
    id?: string
    customerId: string
    vendorId: string
    addressId?: string | null
    basePrice: number
    extraCharge?: number
    totalPrice: number
    vendorNote?: string | null
    customerApproval?: boolean
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentInitiatedAt?: Date | string | null
    paymentStartedAt?: Date | string | null
    paidAt?: Date | string | null
    paymentStatus?: $Enums.PaymentStatus | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    protectedUntil?: Date | string | null
    paymentGraceMinutes?: number | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    Product?: ProductUncheckedCreateNestedManyWithoutOrdersInput
    assignments?: DeliveryAssignmentUncheckedCreateNestedManyWithoutOrderInput
    earnings?: DeliveryEarningUncheckedCreateNestedManyWithoutOrderInput
    Activity?: ActivityUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutDeliveryBroadcastInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutDeliveryBroadcastInput, OrderUncheckedCreateWithoutDeliveryBroadcastInput>
  }

  export type OrderUpsertWithoutDeliveryBroadcastInput = {
    update: XOR<OrderUpdateWithoutDeliveryBroadcastInput, OrderUncheckedUpdateWithoutDeliveryBroadcastInput>
    create: XOR<OrderCreateWithoutDeliveryBroadcastInput, OrderUncheckedCreateWithoutDeliveryBroadcastInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutDeliveryBroadcastInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutDeliveryBroadcastInput, OrderUncheckedUpdateWithoutDeliveryBroadcastInput>
  }

  export type OrderUpdateWithoutDeliveryBroadcastInput = {
    id?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraCharge?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    vendorNote?: NullableStringFieldUpdateOperationsInput | string | null
    customerApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentInitiatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    protectedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGraceMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    customer?: UserUpdateOneRequiredWithoutCustomerOrdersNestedInput
    vendor?: UserUpdateOneRequiredWithoutVendorOrdersNestedInput
    address?: AddressUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    Product?: ProductUpdateManyWithoutOrdersNestedInput
    assignments?: DeliveryAssignmentUpdateManyWithoutOrderNestedInput
    earnings?: DeliveryEarningUpdateManyWithoutOrderNestedInput
    Activity?: ActivityUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutDeliveryBroadcastInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraCharge?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    vendorNote?: NullableStringFieldUpdateOperationsInput | string | null
    customerApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentInitiatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    protectedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGraceMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    Product?: ProductUncheckedUpdateManyWithoutOrdersNestedInput
    assignments?: DeliveryAssignmentUncheckedUpdateManyWithoutOrderNestedInput
    earnings?: DeliveryEarningUncheckedUpdateManyWithoutOrderNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type PaymentCreateWithoutReceiptInput = {
    id?: string
    amount: number
    reference: string
    status: string
    paystackData?: NullableJsonNullValueInput | InputJsonValue
    channel?: string | null
    ipAddress?: string
    userAgent?: string
    deviceId?: string | null
    geoCity?: string | null
    geoCountry?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    user: UserCreateNestedOneWithoutPaymentsInput
    order: OrderCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutReceiptInput = {
    id?: string
    userId: string
    orderId: string
    amount: number
    reference: string
    status: string
    paystackData?: NullableJsonNullValueInput | InputJsonValue
    channel?: string | null
    ipAddress?: string
    userAgent?: string
    deviceId?: string | null
    geoCity?: string | null
    geoCountry?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
  }

  export type PaymentCreateOrConnectWithoutReceiptInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutReceiptInput, PaymentUncheckedCreateWithoutReceiptInput>
  }

  export type PaymentUpsertWithoutReceiptInput = {
    update: XOR<PaymentUpdateWithoutReceiptInput, PaymentUncheckedUpdateWithoutReceiptInput>
    create: XOR<PaymentCreateWithoutReceiptInput, PaymentUncheckedCreateWithoutReceiptInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutReceiptInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutReceiptInput, PaymentUncheckedUpdateWithoutReceiptInput>
  }

  export type PaymentUpdateWithoutReceiptInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paystackData?: NullableJsonNullValueInput | InputJsonValue
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
    order?: OrderUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutReceiptInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paystackData?: NullableJsonNullValueInput | InputJsonValue
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateWithoutFollowersInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityCreateNestedManyWithoutCustomerInput
    following?: VendorFollowerCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateWithoutFollowersInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewUncheckedCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewUncheckedCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderUncheckedCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyUncheckedCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonUncheckedCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestUncheckedCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityUncheckedCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityUncheckedCreateNestedManyWithoutCustomerInput
    following?: VendorFollowerUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserCreateOrConnectWithoutFollowersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
  }

  export type UserCreateWithoutFollowingInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerCreateNestedManyWithoutVendorInput
    specialRequestsMade?: SpecialOrderRequestCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateWithoutFollowingInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewUncheckedCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewUncheckedCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderUncheckedCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyUncheckedCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonUncheckedCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestUncheckedCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityUncheckedCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityUncheckedCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerUncheckedCreateNestedManyWithoutVendorInput
    specialRequestsMade?: SpecialOrderRequestUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserCreateOrConnectWithoutFollowingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
  }

  export type UserUpsertWithoutFollowersInput = {
    update: XOR<UserUpdateWithoutFollowersInput, UserUncheckedUpdateWithoutFollowersInput>
    create: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFollowersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFollowersInput, UserUncheckedUpdateWithoutFollowersInput>
  }

  export type UserUpdateWithoutFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUpdateManyWithoutCustomerNestedInput
    following?: VendorFollowerUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUncheckedUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUncheckedUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUncheckedUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUncheckedUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUncheckedUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUncheckedUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUncheckedUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUncheckedUpdateManyWithoutCustomerNestedInput
    following?: VendorFollowerUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type UserUpsertWithoutFollowingInput = {
    update: XOR<UserUpdateWithoutFollowingInput, UserUncheckedUpdateWithoutFollowingInput>
    create: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFollowingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFollowingInput, UserUncheckedUpdateWithoutFollowingInput>
  }

  export type UserUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUpdateManyWithoutVendorNestedInput
    specialRequestsMade?: SpecialOrderRequestUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUncheckedUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUncheckedUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUncheckedUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUncheckedUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUncheckedUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUncheckedUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUncheckedUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUncheckedUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUncheckedUpdateManyWithoutVendorNestedInput
    specialRequestsMade?: SpecialOrderRequestUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type UserCreateWithoutSpecialRequestsMadeInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerCreateNestedManyWithoutVendorInput
    following?: VendorFollowerCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateWithoutSpecialRequestsMadeInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewUncheckedCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewUncheckedCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderUncheckedCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyUncheckedCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonUncheckedCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestUncheckedCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityUncheckedCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityUncheckedCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerUncheckedCreateNestedManyWithoutVendorInput
    following?: VendorFollowerUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedCreateNestedManyWithoutVendorInput
    specialOffersSent?: SpecialOrderOfferUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserCreateOrConnectWithoutSpecialRequestsMadeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSpecialRequestsMadeInput, UserUncheckedCreateWithoutSpecialRequestsMadeInput>
  }

  export type UserCreateWithoutSpecialRequestsReceivedInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerCreateNestedManyWithoutVendorInput
    following?: VendorFollowerCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestCreateNestedManyWithoutCustomerInput
    specialOffersSent?: SpecialOrderOfferCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateWithoutSpecialRequestsReceivedInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewUncheckedCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewUncheckedCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderUncheckedCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyUncheckedCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonUncheckedCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestUncheckedCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityUncheckedCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityUncheckedCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerUncheckedCreateNestedManyWithoutVendorInput
    following?: VendorFollowerUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestUncheckedCreateNestedManyWithoutCustomerInput
    specialOffersSent?: SpecialOrderOfferUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserCreateOrConnectWithoutSpecialRequestsReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSpecialRequestsReceivedInput, UserUncheckedCreateWithoutSpecialRequestsReceivedInput>
  }

  export type ProductCreateWithoutSpecialRequestsInput = {
    id?: string
    name: string
    description: string
    price: number
    archived?: boolean
    category: $Enums.Category
    images?: ProductCreateimagesInput | string[]
    thumbnail?: string | null
    video?: ProductCreatevideoInput | string[]
    averageRating?: number | null
    reviewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    totalViews?: number
    popularityScore?: number
    popularityUpdatedAt?: Date | string | null
    popularityPercent?: number
    isNew?: boolean
    isLive?: boolean
    liveUntil?: Date | string | null
    vendor: UserCreateNestedOneWithoutProductsInput
    reviews?: ProductReviewCreateNestedManyWithoutProductInput
    orders?: OrderCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    options?: ProductOptionCreateNestedManyWithoutProductInput
    CartItem?: CartItemCreateNestedManyWithoutProductInput
    productSchedule?: ProductScheduleCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSpecialRequestsInput = {
    id?: string
    name: string
    description: string
    price: number
    archived?: boolean
    category: $Enums.Category
    images?: ProductCreateimagesInput | string[]
    thumbnail?: string | null
    video?: ProductCreatevideoInput | string[]
    vendorId: string
    averageRating?: number | null
    reviewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    totalViews?: number
    popularityScore?: number
    popularityUpdatedAt?: Date | string | null
    popularityPercent?: number
    isNew?: boolean
    isLive?: boolean
    liveUntil?: Date | string | null
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    orders?: OrderUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    options?: ProductOptionUncheckedCreateNestedManyWithoutProductInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductInput
    productSchedule?: ProductScheduleUncheckedCreateNestedOneWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSpecialRequestsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSpecialRequestsInput, ProductUncheckedCreateWithoutSpecialRequestsInput>
  }

  export type SpecialOrderOfferCreateWithoutRequestInput = {
    id?: string
    price: number
    message?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: UserCreateNestedOneWithoutSpecialOffersSentInput
  }

  export type SpecialOrderOfferUncheckedCreateWithoutRequestInput = {
    id?: string
    vendorId: string
    price: number
    message?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpecialOrderOfferCreateOrConnectWithoutRequestInput = {
    where: SpecialOrderOfferWhereUniqueInput
    create: XOR<SpecialOrderOfferCreateWithoutRequestInput, SpecialOrderOfferUncheckedCreateWithoutRequestInput>
  }

  export type SpecialOrderOfferCreateManyRequestInputEnvelope = {
    data: SpecialOrderOfferCreateManyRequestInput | SpecialOrderOfferCreateManyRequestInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSpecialRequestsMadeInput = {
    update: XOR<UserUpdateWithoutSpecialRequestsMadeInput, UserUncheckedUpdateWithoutSpecialRequestsMadeInput>
    create: XOR<UserCreateWithoutSpecialRequestsMadeInput, UserUncheckedCreateWithoutSpecialRequestsMadeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSpecialRequestsMadeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSpecialRequestsMadeInput, UserUncheckedUpdateWithoutSpecialRequestsMadeInput>
  }

  export type UserUpdateWithoutSpecialRequestsMadeInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateWithoutSpecialRequestsMadeInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUncheckedUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUncheckedUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUncheckedUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUncheckedUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUncheckedUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUncheckedUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUncheckedUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUncheckedUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUncheckedUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedUpdateManyWithoutVendorNestedInput
    specialOffersSent?: SpecialOrderOfferUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type UserUpsertWithoutSpecialRequestsReceivedInput = {
    update: XOR<UserUpdateWithoutSpecialRequestsReceivedInput, UserUncheckedUpdateWithoutSpecialRequestsReceivedInput>
    create: XOR<UserCreateWithoutSpecialRequestsReceivedInput, UserUncheckedCreateWithoutSpecialRequestsReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSpecialRequestsReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSpecialRequestsReceivedInput, UserUncheckedUpdateWithoutSpecialRequestsReceivedInput>
  }

  export type UserUpdateWithoutSpecialRequestsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUpdateManyWithoutCustomerNestedInput
    specialOffersSent?: SpecialOrderOfferUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateWithoutSpecialRequestsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUncheckedUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUncheckedUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUncheckedUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUncheckedUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUncheckedUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUncheckedUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUncheckedUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUncheckedUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUncheckedUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUncheckedUpdateManyWithoutCustomerNestedInput
    specialOffersSent?: SpecialOrderOfferUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type ProductUpsertWithoutSpecialRequestsInput = {
    update: XOR<ProductUpdateWithoutSpecialRequestsInput, ProductUncheckedUpdateWithoutSpecialRequestsInput>
    create: XOR<ProductCreateWithoutSpecialRequestsInput, ProductUncheckedCreateWithoutSpecialRequestsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutSpecialRequestsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutSpecialRequestsInput, ProductUncheckedUpdateWithoutSpecialRequestsInput>
  }

  export type ProductUpdateWithoutSpecialRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    images?: ProductUpdateimagesInput | string[]
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    video?: ProductUpdatevideoInput | string[]
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalViews?: IntFieldUpdateOperationsInput | number
    popularityScore?: FloatFieldUpdateOperationsInput | number
    popularityUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    popularityPercent?: FloatFieldUpdateOperationsInput | number
    isNew?: BoolFieldUpdateOperationsInput | boolean
    isLive?: BoolFieldUpdateOperationsInput | boolean
    liveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendor?: UserUpdateOneRequiredWithoutProductsNestedInput
    reviews?: ProductReviewUpdateManyWithoutProductNestedInput
    orders?: OrderUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    options?: ProductOptionUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUpdateManyWithoutProductNestedInput
    productSchedule?: ProductScheduleUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSpecialRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    images?: ProductUpdateimagesInput | string[]
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    video?: ProductUpdatevideoInput | string[]
    vendorId?: StringFieldUpdateOperationsInput | string
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalViews?: IntFieldUpdateOperationsInput | number
    popularityScore?: FloatFieldUpdateOperationsInput | number
    popularityUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    popularityPercent?: FloatFieldUpdateOperationsInput | number
    isNew?: BoolFieldUpdateOperationsInput | boolean
    isLive?: BoolFieldUpdateOperationsInput | boolean
    liveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviews?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    options?: ProductOptionUncheckedUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    productSchedule?: ProductScheduleUncheckedUpdateOneWithoutProductNestedInput
  }

  export type SpecialOrderOfferUpsertWithWhereUniqueWithoutRequestInput = {
    where: SpecialOrderOfferWhereUniqueInput
    update: XOR<SpecialOrderOfferUpdateWithoutRequestInput, SpecialOrderOfferUncheckedUpdateWithoutRequestInput>
    create: XOR<SpecialOrderOfferCreateWithoutRequestInput, SpecialOrderOfferUncheckedCreateWithoutRequestInput>
  }

  export type SpecialOrderOfferUpdateWithWhereUniqueWithoutRequestInput = {
    where: SpecialOrderOfferWhereUniqueInput
    data: XOR<SpecialOrderOfferUpdateWithoutRequestInput, SpecialOrderOfferUncheckedUpdateWithoutRequestInput>
  }

  export type SpecialOrderOfferUpdateManyWithWhereWithoutRequestInput = {
    where: SpecialOrderOfferScalarWhereInput
    data: XOR<SpecialOrderOfferUpdateManyMutationInput, SpecialOrderOfferUncheckedUpdateManyWithoutRequestInput>
  }

  export type SpecialOrderRequestCreateWithoutOffersInput = {
    id?: string
    quantity: number
    message: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: UserCreateNestedOneWithoutSpecialRequestsMadeInput
    vendor?: UserCreateNestedOneWithoutSpecialRequestsReceivedInput
    product: ProductCreateNestedOneWithoutSpecialRequestsInput
  }

  export type SpecialOrderRequestUncheckedCreateWithoutOffersInput = {
    id?: string
    customerId: string
    vendorId?: string | null
    productId: string
    quantity: number
    message: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpecialOrderRequestCreateOrConnectWithoutOffersInput = {
    where: SpecialOrderRequestWhereUniqueInput
    create: XOR<SpecialOrderRequestCreateWithoutOffersInput, SpecialOrderRequestUncheckedCreateWithoutOffersInput>
  }

  export type UserCreateWithoutSpecialOffersSentInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerCreateNestedManyWithoutVendorInput
    following?: VendorFollowerCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestCreateNestedManyWithoutVendorInput
  }

  export type UserUncheckedCreateWithoutSpecialOffersSentInput = {
    id?: string
    username?: string | null
    name: string
    email: string
    phoneNumber?: string | null
    password?: string | null
    avatarUrl?: string | null
    preferences?: UserCreatepreferencesInput | string[]
    bio?: string | null
    role?: $Enums.Role | null
    brandName?: string | null
    brandLogo?: string | null
    googleId?: string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: UserCreateauthProvidersInput | string[]
    lastLoginAt?: Date | string | null
    loginMethod?: string | null
    isEmailVerified?: boolean
    emailVerificationToken?: string | null
    emailVerificationExpiresAt?: Date | string | null
    products?: ProductUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsReceived?: VendorReviewUncheckedCreateNestedManyWithoutVendorInput
    vendorReviewsGiven?: VendorReviewUncheckedCreateNestedManyWithoutCustomerInput
    productReviewsGiven?: ProductReviewUncheckedCreateNestedManyWithoutCustomerInput
    customerOrders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    vendorOrders?: OrderUncheckedCreateNestedManyWithoutVendorInput
    vendorRepliesSent?: VendorReplyUncheckedCreateNestedManyWithoutVendorInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    loginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutCustomerInput
    UserPaymentMethod?: UserPaymentMethodUncheckedCreateNestedManyWithoutUserInput
    deliveryPerson?: DeliveryPersonUncheckedCreateNestedOneWithoutUserInput
    passwordResetToken?: PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    RefundRequest?: RefundRequestUncheckedCreateNestedManyWithoutUserInput
    vendorActivities?: ActivityUncheckedCreateNestedManyWithoutVendorInput
    customerActivities?: ActivityUncheckedCreateNestedManyWithoutCustomerInput
    followers?: VendorFollowerUncheckedCreateNestedManyWithoutVendorInput
    following?: VendorFollowerUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsMade?: SpecialOrderRequestUncheckedCreateNestedManyWithoutCustomerInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedCreateNestedManyWithoutVendorInput
  }

  export type UserCreateOrConnectWithoutSpecialOffersSentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSpecialOffersSentInput, UserUncheckedCreateWithoutSpecialOffersSentInput>
  }

  export type SpecialOrderRequestUpsertWithoutOffersInput = {
    update: XOR<SpecialOrderRequestUpdateWithoutOffersInput, SpecialOrderRequestUncheckedUpdateWithoutOffersInput>
    create: XOR<SpecialOrderRequestCreateWithoutOffersInput, SpecialOrderRequestUncheckedCreateWithoutOffersInput>
    where?: SpecialOrderRequestWhereInput
  }

  export type SpecialOrderRequestUpdateToOneWithWhereWithoutOffersInput = {
    where?: SpecialOrderRequestWhereInput
    data: XOR<SpecialOrderRequestUpdateWithoutOffersInput, SpecialOrderRequestUncheckedUpdateWithoutOffersInput>
  }

  export type SpecialOrderRequestUpdateWithoutOffersInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutSpecialRequestsMadeNestedInput
    vendor?: UserUpdateOneWithoutSpecialRequestsReceivedNestedInput
    product?: ProductUpdateOneRequiredWithoutSpecialRequestsNestedInput
  }

  export type SpecialOrderRequestUncheckedUpdateWithoutOffersInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutSpecialOffersSentInput = {
    update: XOR<UserUpdateWithoutSpecialOffersSentInput, UserUncheckedUpdateWithoutSpecialOffersSentInput>
    create: XOR<UserCreateWithoutSpecialOffersSentInput, UserUncheckedCreateWithoutSpecialOffersSentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSpecialOffersSentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSpecialOffersSentInput, UserUncheckedUpdateWithoutSpecialOffersSentInput>
  }

  export type UserUpdateWithoutSpecialOffersSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUpdateManyWithoutVendorNestedInput
  }

  export type UserUncheckedUpdateWithoutSpecialOffersSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: UserUpdatepreferencesInput | string[]
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    brandLogo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: UserUpdateauthProvidersInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginMethod?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsReceived?: VendorReviewUncheckedUpdateManyWithoutVendorNestedInput
    vendorReviewsGiven?: VendorReviewUncheckedUpdateManyWithoutCustomerNestedInput
    productReviewsGiven?: ProductReviewUncheckedUpdateManyWithoutCustomerNestedInput
    customerOrders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    vendorOrders?: OrderUncheckedUpdateManyWithoutVendorNestedInput
    vendorRepliesSent?: VendorReplyUncheckedUpdateManyWithoutVendorNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    loginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutCustomerNestedInput
    UserPaymentMethod?: UserPaymentMethodUncheckedUpdateManyWithoutUserNestedInput
    deliveryPerson?: DeliveryPersonUncheckedUpdateOneWithoutUserNestedInput
    passwordResetToken?: PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    RefundRequest?: RefundRequestUncheckedUpdateManyWithoutUserNestedInput
    vendorActivities?: ActivityUncheckedUpdateManyWithoutVendorNestedInput
    customerActivities?: ActivityUncheckedUpdateManyWithoutCustomerNestedInput
    followers?: VendorFollowerUncheckedUpdateManyWithoutVendorNestedInput
    following?: VendorFollowerUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsMade?: SpecialOrderRequestUncheckedUpdateManyWithoutCustomerNestedInput
    specialRequestsReceived?: SpecialOrderRequestUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type ProductCreateManyVendorInput = {
    id?: string
    name: string
    description: string
    price: number
    archived?: boolean
    category: $Enums.Category
    images?: ProductCreateimagesInput | string[]
    thumbnail?: string | null
    video?: ProductCreatevideoInput | string[]
    averageRating?: number | null
    reviewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    totalViews?: number
    popularityScore?: number
    popularityUpdatedAt?: Date | string | null
    popularityPercent?: number
    isNew?: boolean
    isLive?: boolean
    liveUntil?: Date | string | null
  }

  export type VendorReviewCreateManyVendorInput = {
    id?: string
    customerId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type VendorReviewCreateManyCustomerInput = {
    id?: string
    vendorId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type ProductReviewCreateManyCustomerInput = {
    id?: string
    productId: string
    rating: number
    comment?: string | null
    images?: ProductReviewCreateimagesInput | string[]
    createdAt?: Date | string
    verifiedPurchase?: boolean
  }

  export type OrderCreateManyCustomerInput = {
    id?: string
    vendorId: string
    addressId?: string | null
    basePrice: number
    extraCharge?: number
    totalPrice: number
    vendorNote?: string | null
    customerApproval?: boolean
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentInitiatedAt?: Date | string | null
    paymentStartedAt?: Date | string | null
    paidAt?: Date | string | null
    paymentStatus?: $Enums.PaymentStatus | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    protectedUntil?: Date | string | null
    paymentGraceMinutes?: number | null
  }

  export type OrderCreateManyVendorInput = {
    id?: string
    customerId: string
    addressId?: string | null
    basePrice: number
    extraCharge?: number
    totalPrice: number
    vendorNote?: string | null
    customerApproval?: boolean
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentInitiatedAt?: Date | string | null
    paymentStartedAt?: Date | string | null
    paidAt?: Date | string | null
    paymentStatus?: $Enums.PaymentStatus | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    protectedUntil?: Date | string | null
    paymentGraceMinutes?: number | null
  }

  export type VendorReplyCreateManyVendorInput = {
    id?: string
    reviewId: string
    message: string
    createdAt?: Date | string
  }

  export type ReviewVoteCreateManyUserInput = {
    id?: string
    reviewId: string
    isHelpful: boolean
    createdAt?: Date | string
  }

  export type ReviewReportCreateManyUserInput = {
    id?: string
    reviewId: string
    reason: string
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    title: string
    message: string
    type: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
  }

  export type LoginHistoryCreateManyUserInput = {
    id?: string
    method: string
    deviceId?: string | null
    location?: string | null
    ip?: string | null
    userAgent?: string | null
    geoCity?: string | null
    geoRegion?: string | null
    geoCountry?: string | null
    createdAt?: Date | string
  }

  export type AddressCreateManyUserInput = {
    id?: string
    label: string
    street: string
    city: string
    state?: string | null
    country: string
    zipCode?: string | null
    landmark?: string | null
    latitude?: number | null
    longitude?: number | null
    isDefault?: boolean
    createdAt?: Date | string
  }

  export type CartCreateManyCustomerInput = {
    id?: string
    basePrice?: number
    totalPrice?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPaymentMethodCreateManyUserInput = {
    id?: string
    cardToken: string
    last4: string
    brand: string
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyUserInput = {
    id?: string
    orderId: string
    amount: number
    reference: string
    status: string
    paystackData?: NullableJsonNullValueInput | InputJsonValue
    channel?: string | null
    ipAddress?: string
    userAgent?: string
    deviceId?: string | null
    geoCity?: string | null
    geoCountry?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
  }

  export type RefundRequestCreateManyUserInput = {
    id?: string
    paymentRef: string
    reason: string
    status?: $Enums.RefundStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityCreateManyVendorInput = {
    id?: string
    orderId?: string | null
    customerId?: string | null
    deliveryId?: string | null
    type: $Enums.ActivityType
    title: string
    message: string
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ActivityCreateManyCustomerInput = {
    id?: string
    orderId?: string | null
    vendorId?: string | null
    deliveryId?: string | null
    type: $Enums.ActivityType
    title: string
    message: string
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type VendorFollowerCreateManyVendorInput = {
    id?: string
    customerId: string
    createdAt?: Date | string
  }

  export type VendorFollowerCreateManyCustomerInput = {
    id?: string
    vendorId: string
    createdAt?: Date | string
  }

  export type SpecialOrderRequestCreateManyCustomerInput = {
    id?: string
    vendorId?: string | null
    productId: string
    quantity: number
    message: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpecialOrderRequestCreateManyVendorInput = {
    id?: string
    customerId: string
    productId: string
    quantity: number
    message: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpecialOrderOfferCreateManyVendorInput = {
    id?: string
    requestId: string
    price: number
    message?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    images?: ProductUpdateimagesInput | string[]
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    video?: ProductUpdatevideoInput | string[]
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalViews?: IntFieldUpdateOperationsInput | number
    popularityScore?: FloatFieldUpdateOperationsInput | number
    popularityUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    popularityPercent?: FloatFieldUpdateOperationsInput | number
    isNew?: BoolFieldUpdateOperationsInput | boolean
    isLive?: BoolFieldUpdateOperationsInput | boolean
    liveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviews?: ProductReviewUpdateManyWithoutProductNestedInput
    orders?: OrderUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    options?: ProductOptionUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUpdateManyWithoutProductNestedInput
    specialRequests?: SpecialOrderRequestUpdateManyWithoutProductNestedInput
    productSchedule?: ProductScheduleUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    images?: ProductUpdateimagesInput | string[]
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    video?: ProductUpdatevideoInput | string[]
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalViews?: IntFieldUpdateOperationsInput | number
    popularityScore?: FloatFieldUpdateOperationsInput | number
    popularityUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    popularityPercent?: FloatFieldUpdateOperationsInput | number
    isNew?: BoolFieldUpdateOperationsInput | boolean
    isLive?: BoolFieldUpdateOperationsInput | boolean
    liveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviews?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    options?: ProductOptionUncheckedUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    specialRequests?: SpecialOrderRequestUncheckedUpdateManyWithoutProductNestedInput
    productSchedule?: ProductScheduleUncheckedUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    images?: ProductUpdateimagesInput | string[]
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    video?: ProductUpdatevideoInput | string[]
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalViews?: IntFieldUpdateOperationsInput | number
    popularityScore?: FloatFieldUpdateOperationsInput | number
    popularityUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    popularityPercent?: FloatFieldUpdateOperationsInput | number
    isNew?: BoolFieldUpdateOperationsInput | boolean
    isLive?: BoolFieldUpdateOperationsInput | boolean
    liveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VendorReviewUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutVendorReviewsGivenNestedInput
  }

  export type VendorReviewUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorReviewUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorReviewUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: UserUpdateOneRequiredWithoutVendorReviewsReceivedNestedInput
  }

  export type VendorReviewUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorReviewUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductReviewUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProductReviewUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedPurchase?: BoolFieldUpdateOperationsInput | boolean
    product?: ProductUpdateOneRequiredWithoutReviewsNestedInput
    reply?: VendorReplyUpdateOneWithoutReviewNestedInput
    votes?: ReviewVoteUpdateManyWithoutReviewNestedInput
    reports?: ReviewReportUpdateManyWithoutReviewNestedInput
  }

  export type ProductReviewUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProductReviewUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedPurchase?: BoolFieldUpdateOperationsInput | boolean
    reply?: VendorReplyUncheckedUpdateOneWithoutReviewNestedInput
    votes?: ReviewVoteUncheckedUpdateManyWithoutReviewNestedInput
    reports?: ReviewReportUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ProductReviewUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProductReviewUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedPurchase?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrderUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraCharge?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    vendorNote?: NullableStringFieldUpdateOperationsInput | string | null
    customerApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentInitiatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    protectedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGraceMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    vendor?: UserUpdateOneRequiredWithoutVendorOrdersNestedInput
    address?: AddressUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    Product?: ProductUpdateManyWithoutOrdersNestedInput
    assignments?: DeliveryAssignmentUpdateManyWithoutOrderNestedInput
    earnings?: DeliveryEarningUpdateManyWithoutOrderNestedInput
    Activity?: ActivityUpdateManyWithoutOrderNestedInput
    DeliveryBroadcast?: DeliveryBroadcastUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraCharge?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    vendorNote?: NullableStringFieldUpdateOperationsInput | string | null
    customerApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentInitiatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    protectedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGraceMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    Product?: ProductUncheckedUpdateManyWithoutOrdersNestedInput
    assignments?: DeliveryAssignmentUncheckedUpdateManyWithoutOrderNestedInput
    earnings?: DeliveryEarningUncheckedUpdateManyWithoutOrderNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutOrderNestedInput
    DeliveryBroadcast?: DeliveryBroadcastUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraCharge?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    vendorNote?: NullableStringFieldUpdateOperationsInput | string | null
    customerApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentInitiatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    protectedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGraceMinutes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OrderUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraCharge?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    vendorNote?: NullableStringFieldUpdateOperationsInput | string | null
    customerApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentInitiatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    protectedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGraceMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    customer?: UserUpdateOneRequiredWithoutCustomerOrdersNestedInput
    address?: AddressUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    Product?: ProductUpdateManyWithoutOrdersNestedInput
    assignments?: DeliveryAssignmentUpdateManyWithoutOrderNestedInput
    earnings?: DeliveryEarningUpdateManyWithoutOrderNestedInput
    Activity?: ActivityUpdateManyWithoutOrderNestedInput
    DeliveryBroadcast?: DeliveryBroadcastUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraCharge?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    vendorNote?: NullableStringFieldUpdateOperationsInput | string | null
    customerApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentInitiatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    protectedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGraceMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    Product?: ProductUncheckedUpdateManyWithoutOrdersNestedInput
    assignments?: DeliveryAssignmentUncheckedUpdateManyWithoutOrderNestedInput
    earnings?: DeliveryEarningUncheckedUpdateManyWithoutOrderNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutOrderNestedInput
    DeliveryBroadcast?: DeliveryBroadcastUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraCharge?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    vendorNote?: NullableStringFieldUpdateOperationsInput | string | null
    customerApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentInitiatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    protectedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGraceMinutes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VendorReplyUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ProductReviewUpdateOneRequiredWithoutReplyNestedInput
  }

  export type VendorReplyUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorReplyUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewVoteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isHelpful?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ProductReviewUpdateOneRequiredWithoutVotesNestedInput
  }

  export type ReviewVoteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    isHelpful?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewVoteUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    isHelpful?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewReportUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ProductReviewUpdateOneRequiredWithoutReportsNestedInput
  }

  export type ReviewReportUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewReportUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoRegion?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CartItemUpdateManyWithoutCartNestedInput
  }

  export type CartUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CartItemUncheckedUpdateManyWithoutCartNestedInput
  }

  export type CartUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPaymentMethodUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardToken?: StringFieldUpdateOperationsInput | string
    last4?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPaymentMethodUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardToken?: StringFieldUpdateOperationsInput | string
    last4?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPaymentMethodUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardToken?: StringFieldUpdateOperationsInput | string
    last4?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paystackData?: NullableJsonNullValueInput | InputJsonValue
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: OrderUpdateOneRequiredWithoutPaymentsNestedInput
    Receipt?: ReceiptUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paystackData?: NullableJsonNullValueInput | InputJsonValue
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Receipt?: ReceiptUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paystackData?: NullableJsonNullValueInput | InputJsonValue
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefundRequestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRef?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundRequestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRef?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundRequestUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRef?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneWithoutActivityNestedInput
    customer?: UserUpdateOneWithoutCustomerActivitiesNestedInput
    delivery?: DeliveryPersonUpdateOneWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneWithoutActivityNestedInput
    vendor?: UserUpdateOneWithoutVendorActivitiesNestedInput
    delivery?: DeliveryPersonUpdateOneWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorFollowerUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutFollowingNestedInput
  }

  export type VendorFollowerUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorFollowerUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorFollowerUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: UserUpdateOneRequiredWithoutFollowersNestedInput
  }

  export type VendorFollowerUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorFollowerUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialOrderRequestUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: UserUpdateOneWithoutSpecialRequestsReceivedNestedInput
    product?: ProductUpdateOneRequiredWithoutSpecialRequestsNestedInput
    offers?: SpecialOrderOfferUpdateManyWithoutRequestNestedInput
  }

  export type SpecialOrderRequestUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offers?: SpecialOrderOfferUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type SpecialOrderRequestUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialOrderRequestUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutSpecialRequestsMadeNestedInput
    product?: ProductUpdateOneRequiredWithoutSpecialRequestsNestedInput
    offers?: SpecialOrderOfferUpdateManyWithoutRequestNestedInput
  }

  export type SpecialOrderRequestUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offers?: SpecialOrderOfferUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type SpecialOrderRequestUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialOrderOfferUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: SpecialOrderRequestUpdateOneRequiredWithoutOffersNestedInput
  }

  export type SpecialOrderOfferUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialOrderOfferUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyAddressInput = {
    id?: string
    customerId: string
    vendorId: string
    basePrice: number
    extraCharge?: number
    totalPrice: number
    vendorNote?: string | null
    customerApproval?: boolean
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentInitiatedAt?: Date | string | null
    paymentStartedAt?: Date | string | null
    paidAt?: Date | string | null
    paymentStatus?: $Enums.PaymentStatus | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    protectedUntil?: Date | string | null
    paymentGraceMinutes?: number | null
  }

  export type OrderUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraCharge?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    vendorNote?: NullableStringFieldUpdateOperationsInput | string | null
    customerApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentInitiatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    protectedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGraceMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    customer?: UserUpdateOneRequiredWithoutCustomerOrdersNestedInput
    vendor?: UserUpdateOneRequiredWithoutVendorOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    Product?: ProductUpdateManyWithoutOrdersNestedInput
    assignments?: DeliveryAssignmentUpdateManyWithoutOrderNestedInput
    earnings?: DeliveryEarningUpdateManyWithoutOrderNestedInput
    Activity?: ActivityUpdateManyWithoutOrderNestedInput
    DeliveryBroadcast?: DeliveryBroadcastUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraCharge?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    vendorNote?: NullableStringFieldUpdateOperationsInput | string | null
    customerApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentInitiatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    protectedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGraceMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    Product?: ProductUncheckedUpdateManyWithoutOrdersNestedInput
    assignments?: DeliveryAssignmentUncheckedUpdateManyWithoutOrderNestedInput
    earnings?: DeliveryEarningUncheckedUpdateManyWithoutOrderNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutOrderNestedInput
    DeliveryBroadcast?: DeliveryBroadcastUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraCharge?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    vendorNote?: NullableStringFieldUpdateOperationsInput | string | null
    customerApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentInitiatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    protectedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGraceMinutes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductReviewCreateManyProductInput = {
    id?: string
    customerId: string
    rating: number
    comment?: string | null
    images?: ProductReviewCreateimagesInput | string[]
    createdAt?: Date | string
    verifiedPurchase?: boolean
  }

  export type OrderItemCreateManyProductInput = {
    id?: string
    orderId: string
    quantity: number
    unitPrice: number
    subtotal: number
    createdAt?: Date | string
  }

  export type ProductOptionCreateManyProductInput = {
    id?: string
    name: string
    price: number
  }

  export type CartItemCreateManyProductInput = {
    id?: string
    cartId: string
    quantity: number
    unitPrice: number
    subtotal: number
    specialRequest?: string | null
  }

  export type SpecialOrderRequestCreateManyProductInput = {
    id?: string
    customerId: string
    vendorId?: string | null
    quantity: number
    message: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductReviewUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProductReviewUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedPurchase?: BoolFieldUpdateOperationsInput | boolean
    customer?: UserUpdateOneRequiredWithoutProductReviewsGivenNestedInput
    reply?: VendorReplyUpdateOneWithoutReviewNestedInput
    votes?: ReviewVoteUpdateManyWithoutReviewNestedInput
    reports?: ReviewReportUpdateManyWithoutReviewNestedInput
  }

  export type ProductReviewUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProductReviewUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedPurchase?: BoolFieldUpdateOperationsInput | boolean
    reply?: VendorReplyUncheckedUpdateOneWithoutReviewNestedInput
    votes?: ReviewVoteUncheckedUpdateManyWithoutReviewNestedInput
    reports?: ReviewReportUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ProductReviewUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProductReviewUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedPurchase?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrderUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraCharge?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    vendorNote?: NullableStringFieldUpdateOperationsInput | string | null
    customerApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentInitiatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    protectedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGraceMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    customer?: UserUpdateOneRequiredWithoutCustomerOrdersNestedInput
    vendor?: UserUpdateOneRequiredWithoutVendorOrdersNestedInput
    address?: AddressUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    assignments?: DeliveryAssignmentUpdateManyWithoutOrderNestedInput
    earnings?: DeliveryEarningUpdateManyWithoutOrderNestedInput
    Activity?: ActivityUpdateManyWithoutOrderNestedInput
    DeliveryBroadcast?: DeliveryBroadcastUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraCharge?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    vendorNote?: NullableStringFieldUpdateOperationsInput | string | null
    customerApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentInitiatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    protectedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGraceMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    assignments?: DeliveryAssignmentUncheckedUpdateManyWithoutOrderNestedInput
    earnings?: DeliveryEarningUncheckedUpdateManyWithoutOrderNestedInput
    Activity?: ActivityUncheckedUpdateManyWithoutOrderNestedInput
    DeliveryBroadcast?: DeliveryBroadcastUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    extraCharge?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    vendorNote?: NullableStringFieldUpdateOperationsInput | string | null
    customerApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentInitiatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    protectedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentGraceMinutes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OrderItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    options?: OrderItemOptionUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: OrderItemOptionUncheckedUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductOptionUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    OrderItemOption?: OrderItemOptionUpdateManyWithoutProductOptionNestedInput
    CartItemOption?: CartItemOptionUpdateManyWithoutProductOptionNestedInput
  }

  export type ProductOptionUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    OrderItemOption?: OrderItemOptionUncheckedUpdateManyWithoutProductOptionNestedInput
    CartItemOption?: CartItemOptionUncheckedUpdateManyWithoutProductOptionNestedInput
  }

  export type ProductOptionUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type CartItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    specialRequest?: NullableStringFieldUpdateOperationsInput | string | null
    cart?: CartUpdateOneRequiredWithoutItemsNestedInput
    options?: CartItemOptionUpdateManyWithoutCartItemNestedInput
  }

  export type CartItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    specialRequest?: NullableStringFieldUpdateOperationsInput | string | null
    options?: CartItemOptionUncheckedUpdateManyWithoutCartItemNestedInput
  }

  export type CartItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    specialRequest?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpecialOrderRequestUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutSpecialRequestsMadeNestedInput
    vendor?: UserUpdateOneWithoutSpecialRequestsReceivedNestedInput
    offers?: SpecialOrderOfferUpdateManyWithoutRequestNestedInput
  }

  export type SpecialOrderRequestUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offers?: SpecialOrderOfferUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type SpecialOrderRequestUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemOptionCreateManyProductOptionInput = {
    id?: string
    name: string
    price: number
    orderItemId: string
  }

  export type CartItemOptionCreateManyProductOptionInput = {
    id?: string
    cartItemId: string
    name: string
    price: number
  }

  export type OrderItemOptionUpdateWithoutProductOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    orderItem?: OrderItemUpdateOneRequiredWithoutOptionsNestedInput
  }

  export type OrderItemOptionUncheckedUpdateWithoutProductOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    orderItemId?: StringFieldUpdateOperationsInput | string
  }

  export type OrderItemOptionUncheckedUpdateManyWithoutProductOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    orderItemId?: StringFieldUpdateOperationsInput | string
  }

  export type CartItemOptionUpdateWithoutProductOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    cartItem?: CartItemUpdateOneRequiredWithoutOptionsNestedInput
  }

  export type CartItemOptionUncheckedUpdateWithoutProductOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartItemId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type CartItemOptionUncheckedUpdateManyWithoutProductOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartItemId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type OrderItemCreateManyOrderInput = {
    id?: string
    productId: string
    quantity: number
    unitPrice: number
    subtotal: number
    createdAt?: Date | string
  }

  export type PaymentCreateManyOrderInput = {
    id?: string
    userId: string
    amount: number
    reference: string
    status: string
    paystackData?: NullableJsonNullValueInput | InputJsonValue
    channel?: string | null
    ipAddress?: string
    userAgent?: string
    deviceId?: string | null
    geoCity?: string | null
    geoCountry?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
  }

  export type DeliveryAssignmentCreateManyOrderInput = {
    id?: string
    deliveryPersonId: string
    status?: $Enums.DeliveryStatus
    assignedAt?: Date | string
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    declinedAt?: Date | string | null
    timeoutSeconds?: number
    attempts?: number
    batchId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryEarningCreateManyOrderInput = {
    id?: string
    deliveryPersonId: string
    baseFee: number
    distanceFee: number
    tip?: number
    deductions?: number
    totalEarned: number
    createdAt?: Date | string
  }

  export type ActivityCreateManyOrderInput = {
    id?: string
    vendorId?: string | null
    customerId?: string | null
    deliveryId?: string | null
    type: $Enums.ActivityType
    title: string
    message: string
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DeliveryBroadcastCreateManyOrderInput = {
    id?: string
    driverIds?: DeliveryBroadcastCreatedriverIdsInput | string[]
    acceptedDriverId?: string | null
    status: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
    options?: OrderItemOptionUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: OrderItemOptionUncheckedUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paystackData?: NullableJsonNullValueInput | InputJsonValue
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
    Receipt?: ReceiptUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paystackData?: NullableJsonNullValueInput | InputJsonValue
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Receipt?: ReceiptUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paystackData?: NullableJsonNullValueInput | InputJsonValue
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    geoCity?: NullableStringFieldUpdateOperationsInput | string | null
    geoCountry?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    images?: ProductUpdateimagesInput | string[]
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    video?: ProductUpdatevideoInput | string[]
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalViews?: IntFieldUpdateOperationsInput | number
    popularityScore?: FloatFieldUpdateOperationsInput | number
    popularityUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    popularityPercent?: FloatFieldUpdateOperationsInput | number
    isNew?: BoolFieldUpdateOperationsInput | boolean
    isLive?: BoolFieldUpdateOperationsInput | boolean
    liveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendor?: UserUpdateOneRequiredWithoutProductsNestedInput
    reviews?: ProductReviewUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    options?: ProductOptionUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUpdateManyWithoutProductNestedInput
    specialRequests?: SpecialOrderRequestUpdateManyWithoutProductNestedInput
    productSchedule?: ProductScheduleUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    images?: ProductUpdateimagesInput | string[]
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    video?: ProductUpdatevideoInput | string[]
    vendorId?: StringFieldUpdateOperationsInput | string
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalViews?: IntFieldUpdateOperationsInput | number
    popularityScore?: FloatFieldUpdateOperationsInput | number
    popularityUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    popularityPercent?: FloatFieldUpdateOperationsInput | number
    isNew?: BoolFieldUpdateOperationsInput | boolean
    isLive?: BoolFieldUpdateOperationsInput | boolean
    liveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviews?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    options?: ProductOptionUncheckedUpdateManyWithoutProductNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    specialRequests?: SpecialOrderRequestUncheckedUpdateManyWithoutProductNestedInput
    productSchedule?: ProductScheduleUncheckedUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    images?: ProductUpdateimagesInput | string[]
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    video?: ProductUpdatevideoInput | string[]
    vendorId?: StringFieldUpdateOperationsInput | string
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalViews?: IntFieldUpdateOperationsInput | number
    popularityScore?: FloatFieldUpdateOperationsInput | number
    popularityUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    popularityPercent?: FloatFieldUpdateOperationsInput | number
    isNew?: BoolFieldUpdateOperationsInput | boolean
    isLive?: BoolFieldUpdateOperationsInput | boolean
    liveUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeliveryAssignmentUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeoutSeconds?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryPerson?: DeliveryPersonUpdateOneRequiredWithoutAssignedOrdersNestedInput
  }

  export type DeliveryAssignmentUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryPersonId?: StringFieldUpdateOperationsInput | string
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeoutSeconds?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryAssignmentUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryPersonId?: StringFieldUpdateOperationsInput | string
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeoutSeconds?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryEarningUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    baseFee?: FloatFieldUpdateOperationsInput | number
    distanceFee?: FloatFieldUpdateOperationsInput | number
    tip?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    totalEarned?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryPerson?: DeliveryPersonUpdateOneRequiredWithoutEarningsNestedInput
  }

  export type DeliveryEarningUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryPersonId?: StringFieldUpdateOperationsInput | string
    baseFee?: FloatFieldUpdateOperationsInput | number
    distanceFee?: FloatFieldUpdateOperationsInput | number
    tip?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    totalEarned?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryEarningUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryPersonId?: StringFieldUpdateOperationsInput | string
    baseFee?: FloatFieldUpdateOperationsInput | number
    distanceFee?: FloatFieldUpdateOperationsInput | number
    tip?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    totalEarned?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: UserUpdateOneWithoutVendorActivitiesNestedInput
    customer?: UserUpdateOneWithoutCustomerActivitiesNestedInput
    delivery?: DeliveryPersonUpdateOneWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryBroadcastUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverIds?: DeliveryBroadcastUpdatedriverIdsInput | string[]
    acceptedDriverId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryBroadcastUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverIds?: DeliveryBroadcastUpdatedriverIdsInput | string[]
    acceptedDriverId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryBroadcastUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverIds?: DeliveryBroadcastUpdatedriverIdsInput | string[]
    acceptedDriverId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemOptionCreateManyOrderItemInput = {
    id?: string
    optionId: string
    name: string
    price: number
  }

  export type OrderItemOptionUpdateWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    productOption?: ProductOptionUpdateOneRequiredWithoutOrderItemOptionNestedInput
  }

  export type OrderItemOptionUncheckedUpdateWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type OrderItemOptionUncheckedUpdateManyWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type ReviewVoteCreateManyReviewInput = {
    id?: string
    userId: string
    isHelpful: boolean
    createdAt?: Date | string
  }

  export type ReviewReportCreateManyReviewInput = {
    id?: string
    userId: string
    reason: string
    createdAt?: Date | string
  }

  export type ReviewVoteUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    isHelpful?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewVotesNestedInput
  }

  export type ReviewVoteUncheckedUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isHelpful?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewVoteUncheckedUpdateManyWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isHelpful?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewReportUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewReportsNestedInput
  }

  export type ReviewReportUncheckedUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewReportUncheckedUpdateManyWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceiptCreateManyPaymentInput = {
    id?: string
    pdfUrl?: string | null
    createdAt?: Date | string
  }

  export type ReceiptUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceiptUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceiptUncheckedUpdateManyWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemCreateManyCartInput = {
    id?: string
    productId: string
    quantity: number
    unitPrice: number
    subtotal: number
    specialRequest?: string | null
  }

  export type CartItemUpdateWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    specialRequest?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutCartItemNestedInput
    options?: CartItemOptionUpdateManyWithoutCartItemNestedInput
  }

  export type CartItemUncheckedUpdateWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    specialRequest?: NullableStringFieldUpdateOperationsInput | string | null
    options?: CartItemOptionUncheckedUpdateManyWithoutCartItemNestedInput
  }

  export type CartItemUncheckedUpdateManyWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    specialRequest?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CartItemOptionCreateManyCartItemInput = {
    id?: string
    productOptionId: string
    name: string
    price: number
  }

  export type CartItemOptionUpdateWithoutCartItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    productOption?: ProductOptionUpdateOneRequiredWithoutCartItemOptionNestedInput
  }

  export type CartItemOptionUncheckedUpdateWithoutCartItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    productOptionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type CartItemOptionUncheckedUpdateManyWithoutCartItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    productOptionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type DeliveryAssignmentCreateManyDeliveryPersonInput = {
    id?: string
    orderId: string
    status?: $Enums.DeliveryStatus
    assignedAt?: Date | string
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    declinedAt?: Date | string | null
    timeoutSeconds?: number
    attempts?: number
    batchId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryEarningCreateManyDeliveryPersonInput = {
    id?: string
    orderId: string
    baseFee: number
    distanceFee: number
    tip?: number
    deductions?: number
    totalEarned: number
    createdAt?: Date | string
  }

  export type DriverLocationLogCreateManyDriverInput = {
    id?: string
    latitude: number
    longitude: number
    timestamp?: Date | string
  }

  export type ActivityCreateManyDeliveryInput = {
    id?: string
    orderId?: string | null
    vendorId?: string | null
    customerId?: string | null
    type: $Enums.ActivityType
    title: string
    message: string
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DeliveryAssignmentUpdateWithoutDeliveryPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeoutSeconds?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type DeliveryAssignmentUncheckedUpdateWithoutDeliveryPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeoutSeconds?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryAssignmentUncheckedUpdateManyWithoutDeliveryPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    declinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeoutSeconds?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryEarningUpdateWithoutDeliveryPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    baseFee?: FloatFieldUpdateOperationsInput | number
    distanceFee?: FloatFieldUpdateOperationsInput | number
    tip?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    totalEarned?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutEarningsNestedInput
  }

  export type DeliveryEarningUncheckedUpdateWithoutDeliveryPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    baseFee?: FloatFieldUpdateOperationsInput | number
    distanceFee?: FloatFieldUpdateOperationsInput | number
    tip?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    totalEarned?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryEarningUncheckedUpdateManyWithoutDeliveryPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    baseFee?: FloatFieldUpdateOperationsInput | number
    distanceFee?: FloatFieldUpdateOperationsInput | number
    tip?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    totalEarned?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverLocationLogUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverLocationLogUncheckedUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverLocationLogUncheckedUpdateManyWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUpdateWithoutDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneWithoutActivityNestedInput
    vendor?: UserUpdateOneWithoutVendorActivitiesNestedInput
    customer?: UserUpdateOneWithoutCustomerActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyWithoutDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialOrderOfferCreateManyRequestInput = {
    id?: string
    vendorId: string
    price: number
    message?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpecialOrderOfferUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: UserUpdateOneRequiredWithoutSpecialOffersSentNestedInput
  }

  export type SpecialOrderOfferUncheckedUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialOrderOfferUncheckedUpdateManyWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}